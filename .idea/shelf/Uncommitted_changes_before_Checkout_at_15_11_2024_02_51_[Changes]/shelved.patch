Index: app/src/main/java/com/android/bookswap/ui/navigation/BottomNavigationMenu.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/navigation/BottomNavigationMenu.kt b/app/src/main/java/com/android/bookswap/ui/navigation/BottomNavigationMenu.kt
new file mode 100644
--- /dev/null	(date 1730449039974)
+++ b/app/src/main/java/com/android/bookswap/ui/navigation/BottomNavigationMenu.kt	(date 1730449039974)
@@ -0,0 +1,49 @@
+package com.android.bookswap.ui.navigation
+
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.shape.RoundedCornerShape
+import androidx.compose.material.BottomNavigation
+import androidx.compose.material.BottomNavigationItem
+import androidx.compose.material3.Icon
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.draw.clip
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.unit.dp
+import com.android.bookswap.ui.theme.ColorVariable
+
+/** Constants * */
+val BOTTOM_NAV_HEIGHT = 60.dp
+private val ROUNDED_CORNER_SIZE = 60.dp
+
+/**
+ * This Composable function creates a bottom navigation menu for the app Displaying different tabs
+ * (destinations) based on the provided list of destinations (tabList).
+ */
+@Composable
+fun BottomNavigationMenu(
+    onTabSelect: (TopLevelDestination) -> Unit,
+    tabList: List<TopLevelDestination>,
+    selectedItem: String
+) {
+  BottomNavigation(
+      modifier = Modifier.fillMaxWidth().height(BOTTOM_NAV_HEIGHT).testTag("bottomNavigationMenu"),
+      backgroundColor = ColorVariable.Primary, // Color of the bottom navigation bar
+      content = {
+        tabList.forEach { tab ->
+          BottomNavigationItem(
+              icon = {
+                // Display the icon for each tab
+                Icon(
+                    tab.icon,
+                    contentDescription = "icon_${tab.textId}",
+                    tint = ColorVariable.BackGround)
+              },
+              selected = tab.route == selectedItem,
+              onClick = { onTabSelect(tab) },
+              modifier = Modifier.clip(RoundedCornerShape(ROUNDED_CORNER_SIZE)).testTag(tab.textId))
+        }
+      },
+  )
+}
Index: app/src/test/java/com/android/bookswap/model/map/BookManagerViewModelTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/model/map/BookManagerViewModelTest.kt b/app/src/test/java/com/android/bookswap/model/map/BookManagerViewModelTest.kt
new file mode 100644
--- /dev/null	(date 1731617426321)
+++ b/app/src/test/java/com/android/bookswap/model/map/BookManagerViewModelTest.kt	(date 1731617426321)
@@ -0,0 +1,179 @@
+package com.android.bookswap.model.map
+
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.UserBooksWithLocation
+import com.android.bookswap.data.repository.UsersRepository
+import com.android.bookswap.data.source.network.BooksFirestoreSource
+import io.mockk.every
+import io.mockk.mockk
+import java.util.UUID
+import junit.framework.TestCase.assertEquals
+import kotlin.math.abs
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.first
+import kotlinx.coroutines.test.runTest
+import org.junit.Before
+import org.junit.Test
+
+class BookManagerViewModelTest {
+
+  private val user1 =
+      DataUser(
+          userUUID = UUID(1, 1),
+          bookList = listOf(UUID(1, 2), UUID(2, 1)),
+          longitude = 50.0,
+          latitude = 50.0)
+  private val user2 =
+      DataUser(
+          userUUID = UUID(2, 2), bookList = listOf(UUID(1, 1)), longitude = 0.0, latitude = 0.0)
+  private val users = listOf(user2, user1)
+
+  private val book1 =
+      DataBook(
+          uuid = UUID(1, 2),
+          title = "Book 1",
+          author = "Author 1",
+          description = "Description of Book 1",
+          rating = 5,
+          photo = "url_to_photo_1",
+          language = BookLanguages.ENGLISH,
+          isbn = "123-456-789",
+          genres = listOf(BookGenres.FICTION, BookGenres.HORROR))
+
+  private val book2 =
+      DataBook(
+          uuid = UUID(2, 1),
+          title = "Book 2",
+          author = "Author 2",
+          description = "Description of Book 2",
+          rating = 4,
+          photo = "url_to_photo_2",
+          language = BookLanguages.GERMAN,
+          isbn = "234-567-890",
+          genres = listOf(BookGenres.FICTION))
+
+  private val book3 =
+      DataBook(
+          uuid = UUID(1, 1),
+          title = "Book 3",
+          author = "Author 3",
+          description = "Description of Book 3",
+          rating = 4,
+          photo = "url_to_photo_3",
+          language = BookLanguages.GERMAN,
+          isbn = "234-567-890",
+          genres = listOf(BookGenres.NONFICTION, BookGenres.HORROR))
+
+  private val books = listOf(book3, book1, book2)
+
+  private val userBooksWithLocation1 =
+      UserBooksWithLocation(user1.userUUID, user1.longitude, user1.latitude, listOf(book1, book2))
+
+  private val userBooksWithLocation2 =
+      UserBooksWithLocation(user2.userUUID, user2.longitude, user2.latitude, listOf(book3))
+
+  private val userBooksWithLocation = listOf(userBooksWithLocation2, userBooksWithLocation1)
+
+  private val filteredBooksWithLocation =
+      listOf(
+          userBooksWithLocation2,
+          UserBooksWithLocation(user1.userUUID, user1.longitude, user1.latitude, emptyList()))
+
+  private val geolocation1 = listOf(0.0, 0.0)
+  private val geolocation2 = listOf(100.0, 100.0)
+
+  private val sortingTest: (Double, Double, Double, Double) -> Double =
+      { startLatitude, _, endLatitude, _ ->
+        abs(endLatitude - startLatitude)
+      }
+
+  private val mockBookRepository: BooksFirestoreSource = mockk()
+  private val mockUsersRepository: UsersRepository = mockk()
+  private val mockGeolocation1: IGeolocation = mockk()
+  private val mockGeolocation2: IGeolocation = mockk()
+  private val mockBookFilter: BookFilter = mockk()
+  private val mockBookFilterEmpty: BookFilter = mockk()
+
+  @Before
+  fun setup() {
+    every { mockBookRepository.getBook(any()) } answers
+        {
+          firstArg<(Result<List<DataBook>>) -> Unit>().invoke(Result.success(books))
+        }
+    every { mockUsersRepository.getUsers(any()) } answers
+        {
+          firstArg<(Result<List<DataUser>>) -> Unit>().invoke(Result.success(users))
+        }
+
+    every { mockGeolocation1.longitude } answers { MutableStateFlow(geolocation1[0]) }
+    every { mockGeolocation1.latitude } answers { MutableStateFlow(geolocation1[1]) }
+
+    every { mockGeolocation2.longitude } answers { MutableStateFlow(geolocation2[0]) }
+    every { mockGeolocation2.latitude } answers { MutableStateFlow(geolocation2[1]) }
+
+    every { mockBookFilter.genresFilter } answers { MutableStateFlow(listOf(BookGenres.HORROR)) }
+    every { mockBookFilter.languagesFilter } answers
+        {
+          MutableStateFlow(listOf(BookLanguages.GERMAN))
+        }
+    every { mockBookFilter.filterBooks(any()) } answers { listOf(book3) }
+
+    every { mockBookFilterEmpty.genresFilter } answers { MutableStateFlow(emptyList()) }
+    every { mockBookFilterEmpty.languagesFilter } answers { MutableStateFlow(emptyList()) }
+    every { mockBookFilterEmpty.filterBooks(any()) } answers { firstArg() }
+  }
+
+  @Test
+  fun defaultCaseNoFilterOrSortingNecessary() = runTest {
+    val bookManagerViewModel =
+        BookManagerViewModel(
+            mockGeolocation1, mockBookRepository, mockUsersRepository, mockBookFilterEmpty) {
+                _,
+                _,
+                _,
+                _ ->
+              0.0
+            }
+    bookManagerViewModel.startUpdatingBooks()
+    bookManagerViewModel.filteredBooks.first { it != emptyList<DataBook>() }
+    bookManagerViewModel.filteredUsers.first { it != emptyList<UserBooksWithLocation>() }
+    assertEquals(books, bookManagerViewModel.filteredBooks.value)
+    assertEquals(userBooksWithLocation, bookManagerViewModel.filteredUsers.value)
+    bookManagerViewModel.stopUpdatingBooks()
+  }
+
+  @Test
+  fun returnFilteredListOfBooks() = runTest {
+    val bookManagerViewModel =
+        BookManagerViewModel(
+            mockGeolocation1, mockBookRepository, mockUsersRepository, mockBookFilter, sortingTest)
+    bookManagerViewModel.startUpdatingBooks()
+    bookManagerViewModel.filteredBooks.first { it != emptyList<DataBook>() }
+    bookManagerViewModel.filteredUsers.first { it != emptyList<UserBooksWithLocation>() }
+    assertEquals(listOf(book3), bookManagerViewModel.filteredBooks.value)
+    assertEquals(filteredBooksWithLocation, bookManagerViewModel.filteredUsers.value)
+    bookManagerViewModel.stopUpdatingBooks()
+  }
+
+  @Test
+  fun sortTheUsers() = runTest {
+    val bookManagerViewModel =
+        BookManagerViewModel(
+            mockGeolocation2,
+            mockBookRepository,
+            mockUsersRepository,
+            mockBookFilterEmpty,
+            sortingTest)
+    bookManagerViewModel.startUpdatingBooks()
+    bookManagerViewModel.filteredBooks.first { it != emptyList<DataBook>() }
+    bookManagerViewModel.filteredUsers.first { it != emptyList<UserBooksWithLocation>() }
+    assertEquals(listOf(book1, book2, book3), bookManagerViewModel.filteredBooks.value)
+    assertEquals(
+        listOf(userBooksWithLocation1, userBooksWithLocation2),
+        bookManagerViewModel.filteredUsers.value)
+    bookManagerViewModel.stopUpdatingBooks()
+  }
+}
Index: app/src/test/java/com/android/bookswap/data/source/network/PhotoFirestoreSourceTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/source/network/PhotoFirestoreSourceTest.kt b/app/src/test/java/com/android/bookswap/data/source/network/PhotoFirestoreSourceTest.kt
new file mode 100644
--- /dev/null	(date 1731615667858)
+++ b/app/src/test/java/com/android/bookswap/data/source/network/PhotoFirestoreSourceTest.kt	(date 1731615667858)
@@ -0,0 +1,142 @@
+package com.android.bookswap.data.source.network
+
+import android.content.Context
+import android.graphics.BitmapFactory
+import androidx.test.core.app.ApplicationProvider
+import com.android.bookswap.R
+import com.android.bookswap.data.DataPhoto
+import com.google.android.gms.tasks.Tasks
+import com.google.firebase.FirebaseApp
+import com.google.firebase.firestore.CollectionReference
+import com.google.firebase.firestore.DocumentReference
+import com.google.firebase.firestore.DocumentSnapshot
+import com.google.firebase.firestore.FirebaseFirestore
+import com.google.firebase.firestore.QuerySnapshot
+import java.util.UUID
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.ArgumentMatchers
+import org.mockito.Mock
+import org.mockito.Mockito.`when`
+import org.mockito.MockitoAnnotations
+import org.mockito.kotlin.doAnswer
+import org.mockito.kotlin.verify
+import org.robolectric.RobolectricTestRunner
+
+@RunWith(RobolectricTestRunner::class)
+class PhotoFirestoreSourceTest {
+  @Mock private lateinit var mockFirestore: FirebaseFirestore
+  @Mock private lateinit var mockCollectionReference: CollectionReference
+  @Mock private lateinit var mockDocumentReference: DocumentReference
+  @Mock private lateinit var mockDocumentSnapshot: DocumentSnapshot
+  @Mock private lateinit var mockQuerySnapshot: QuerySnapshot
+
+  private lateinit var PhotoFirestoreSource: PhotoFirestoreSource
+  private lateinit var testPhoto: DataPhoto
+
+  @Before
+  fun setUp() {
+    MockitoAnnotations.openMocks(this)
+
+    // Initialize Firebase if necessary
+    if (FirebaseApp.getApps(ApplicationProvider.getApplicationContext()).isEmpty()) {
+      FirebaseApp.initializeApp(ApplicationProvider.getApplicationContext())
+    }
+
+    PhotoFirestoreSource = PhotoFirestoreSource(mockFirestore)
+
+    `when`(mockFirestore.collection(ArgumentMatchers.anyString()))
+        .thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(ArgumentMatchers.anyString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
+
+    val context = ApplicationProvider.getApplicationContext<Context>()
+    val bitmap = BitmapFactory.decodeResource(context.resources, R.drawable.etranger_test)
+
+    testPhoto =
+        DataPhoto(
+            uuid = UUID.randomUUID(),
+            url = "", // Optional url field (don't know if it is really useful)
+            timestamp = System.currentTimeMillis(),
+            base64 = PhotoFirestoreSource.bitmapToBase64(bitmap))
+  }
+
+  @Test
+  fun getPhoto_callsFirestoreGet() {
+    // Arrange
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
+
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(testPhoto.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("url")).thenReturn(testPhoto.url)
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(testPhoto.timestamp)
+    `when`(mockDocumentSnapshot.getString("base64")).thenReturn(testPhoto.base64)
+
+    // Act
+    PhotoFirestoreSource.getPhoto(
+        testPhoto.uuid,
+        callback = { result ->
+          assert(result.isSuccess)
+          val photo = result.getOrThrow()
+          // Assert that the fetched photo matches the expected values
+          assert(photo.uuid == testPhoto.uuid)
+          assert(photo.url == testPhoto.url)
+          assert(photo.timestamp == testPhoto.timestamp)
+          assert(photo.base64 == testPhoto.base64)
+        })
+
+    // Verify Firestore collection was called
+    verify(mockCollectionReference).document(testPhoto.uuid.toString())
+  }
+
+  @Test
+  fun addPhoto_callsFirestoreSet_andOnSuccess() {
+    // Arrange
+    doAnswer { Tasks.forResult(null) }.`when`(mockDocumentReference).set(testPhoto)
+
+    // Act
+    PhotoFirestoreSource.addPhoto(
+        testPhoto,
+        callback = { result ->
+          // Assert success callback
+          assert(result.isSuccess)
+        })
+    // Verify Firestore set operation
+    verify(mockDocumentReference).set(testPhoto)
+  }
+
+  @Test
+  fun documentToPhoto_returnsDataPhoto_whenDocumentIsValid() {
+    // Arrange
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(testPhoto.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("url")).thenReturn(testPhoto.url)
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(testPhoto.timestamp)
+    `when`(mockDocumentSnapshot.getString("base64")).thenReturn(testPhoto.base64)
+
+    // Act
+    val result = PhotoFirestoreSource.documentToPhoto(mockDocumentSnapshot)
+
+    // Assert
+    assert(result != null)
+    assert(result?.uuid == testPhoto.uuid)
+    assert(result?.url == testPhoto.url)
+    assert(result?.timestamp == testPhoto.timestamp)
+    assert(result?.base64 == testPhoto.base64)
+  }
+
+  @Test
+  fun documentToPhoto_returnsNull_whenRequiredFieldIsMissing() {
+    // Arrange - Missing "base64" field
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(testPhoto.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("url")).thenReturn(testPhoto.url)
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(testPhoto.timestamp)
+    `when`(mockDocumentSnapshot.getString("base64")).thenReturn(null)
+
+    // Act
+    val result = PhotoFirestoreSource.documentToPhoto(mockDocumentSnapshot)
+
+    // Assert
+    assert(result == null) // Should return null due to missing "base64"
+  }
+}
Index: app/src/test/java/com/android/bookswap/data/source/network/ImageToDataSourceTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/source/network/ImageToDataSourceTest.kt b/app/src/test/java/com/android/bookswap/data/source/network/ImageToDataSourceTest.kt
new file mode 100644
--- /dev/null	(date 1731615667858)
+++ b/app/src/test/java/com/android/bookswap/data/source/network/ImageToDataSourceTest.kt	(date 1731615667858)
@@ -0,0 +1,130 @@
+package com.android.bookswap.data.source.network
+
+import com.android.bookswap.R
+import com.android.bookswap.data.source.api.ApiService
+import io.mockk.every
+import io.mockk.invoke
+import io.mockk.mockk
+import io.mockk.verify
+import junit.framework.TestCase.assertEquals
+import junit.framework.TestCase.fail
+import org.junit.Assert.assertTrue
+import org.junit.Before
+import org.junit.Test
+
+class ImageToDataSourceTest {
+  private lateinit var apiService: ApiService
+  private lateinit var imageToDataSource: ImageToDataSource
+  private val imageUrl = "https://example.com/book-cover.jpg"
+  private val expectedPrompt = "${R.string.prompt} $imageUrl"
+
+  @Before
+  fun setup() {
+    apiService = mockk()
+    imageToDataSource = ImageToDataSource(apiService)
+  }
+
+  @Test
+  fun `analyzeImage should return parsed data on success`() {
+
+    // Mock API response
+    val mockResponse =
+        """
+        {
+          "title": "Example Title",
+          "author": "Example Author",
+          "description": "An example description of the book.",
+          "language": "EN",
+          "isbn": "1234567890"
+        }
+    """
+            .trimIndent()
+
+    // Mock successful response
+    every {
+      apiService.sendChatRequest(
+          listOf(expectedPrompt), // This should now match the exact prompt
+          captureLambda(),
+          any())
+    } answers { lambda<(String) -> Unit>().invoke(mockResponse) }
+
+    // Test analyzeImage
+    imageToDataSource.analyzeImage(
+        imageUrl,
+        onSuccess = { result ->
+          assertEquals("Example Title", result["title"])
+          assertEquals("Example Author", result["author"])
+          assertEquals("An example description of the book.", result["description"])
+          assertEquals("EN", result["language"])
+          assertEquals("1234567890", result["isbn"])
+        },
+        onError = { fail("Expected success callback but got error: $it") })
+
+    // Verify that sendChatRequest was called with the exact prompt
+    verify { apiService.sendChatRequest(listOf(expectedPrompt), any(), any()) }
+  }
+
+  @Test
+  fun `analyzeImage should call onError when API fails`() {
+    val errorMessage = "Network error"
+    every { apiService.sendChatRequest(any(), any(), captureLambda()) } answers
+        {
+          lambda<(String) -> Unit>().invoke(errorMessage)
+        }
+
+    val imageUrl = "https://example.com/book-cover.jpg"
+
+    // Test analyzeImage
+    imageToDataSource.analyzeImage(
+        imageUrl,
+        onSuccess = { fail("Expected error callback but got success") },
+        onError = { error -> assertEquals("API Request Error: $errorMessage", error) })
+
+    // Verify that sendChatRequest was called
+    verify { apiService.sendChatRequest(any(), any(), any()) }
+  }
+
+  @Test
+  fun `analyzeImage should handle partial data in response`() {
+    val mockPartialResponse =
+        """
+        {
+          "title": "Partial Title",
+          "author": "Partial Author",
+          "language": "EN"
+        }
+    """
+            .trimIndent()
+
+    every { apiService.sendChatRequest(listOf(expectedPrompt), captureLambda(), any()) } answers
+        {
+          lambda<(String) -> Unit>().invoke(mockPartialResponse)
+        }
+
+    imageToDataSource.analyzeImage(
+        imageUrl,
+        onSuccess = { result ->
+          assertEquals("Partial Title", result["title"])
+          assertEquals("Partial Author", result["author"])
+          assertEquals("N/A", result["description"]) // Missing field should default to "N/A"
+          assertEquals("EN", result["language"])
+          assertEquals("N/A", result["isbn"]) // Missing field should default to "N/A"
+        },
+        onError = { fail("Expected success callback but got error: $it") })
+  }
+
+  @Test
+  fun `analyzeImage should handle non-JSON response from API`() {
+    val mockNonJsonResponse = "This is not JSON"
+
+    every { apiService.sendChatRequest(listOf(expectedPrompt), captureLambda(), any()) } answers
+        {
+          lambda<(String) -> Unit>().invoke(mockNonJsonResponse)
+        }
+
+    imageToDataSource.analyzeImage(
+        imageUrl,
+        onSuccess = { fail("Expected error callback but got success with data: $it") },
+        onError = { error -> assertTrue(error.contains("Parsing error")) })
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/authentication/LoginTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/authentication/LoginTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/authentication/LoginTest.kt
new file mode 100644
--- /dev/null	(date 1731617442888)
+++ b/app/src/androidTest/java/com/android/bookswap/ui/authentication/LoginTest.kt	(date 1731617442888)
@@ -0,0 +1,87 @@
+package com.android.bookswap.ui.authentication
+
+import androidx.compose.ui.test.assertHasClickAction
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.assertTextEquals
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.compose.ui.test.performClick
+import androidx.navigation.compose.rememberNavController
+import androidx.test.espresso.intent.Intents
+import androidx.test.espresso.intent.Intents.intended
+import androidx.test.espresso.intent.matcher.IntentMatchers.toPackage
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.android.bookswap.model.UserViewModel
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.navigation.Screen
+import com.kaspersky.kaspresso.testcases.api.testcase.TestCase
+import io.mockk.every
+import io.mockk.mockk
+import io.mockk.verify
+import kotlinx.coroutines.flow.MutableStateFlow
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+@RunWith(AndroidJUnit4::class)
+class LoginTest : TestCase() {
+  private lateinit var userVM: UserViewModel
+  private lateinit var mocknavi: NavigationActions
+
+  @get:Rule val composeTestRule = createComposeRule()
+  // The IntentsTestRule may not reliable.
+  @Before
+  fun setUp() {
+    Intents.init()
+    userVM = mockk(relaxed = true)
+    mocknavi = mockk(relaxed = true)
+  }
+
+  // Release Intents after each test
+  @After
+  fun tearDown() {
+    Intents.release()
+  }
+
+  @Test
+  fun titleAndButtonAreCorrectlyDisplayed() {
+    every { userVM.isStored } returns MutableStateFlow(null)
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      SignInScreen(navigationActions, userVM)
+    }
+    composeTestRule.onNodeWithTag("login_loginTitle1").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("login_loginTitle1").assertTextEquals("Welcome to")
+    composeTestRule.onNodeWithTag("login_loginTitle2").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("login_loginTitle2").assertTextEquals("BookSwap")
+
+    composeTestRule.onNodeWithTag("loginButton").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("loginButton").assertHasClickAction()
+  }
+
+  @Test
+  fun googleSignInReturnsValidActivityResult() {
+    every { userVM.isStored } returns MutableStateFlow(null)
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      SignInScreen(navigationActions, userVM)
+    }
+    composeTestRule.onNodeWithTag("loginButton").performClick()
+    composeTestRule.waitForIdle()
+    // assert that an Intent resolving to Google Mobile Services has been sent (for sign-in)
+    intended(toPackage("com.google.android.gms"))
+  }
+
+  @Test
+  fun navigateToNewUserScreenWhenUserIsNotStored() {
+    every { userVM.isStored } returns MutableStateFlow(false)
+    composeTestRule.setContent { SignInScreen(mocknavi, userVM) }
+    composeTestRule.onNodeWithTag("loginButton").performClick()
+    composeTestRule.waitForIdle()
+    verify { mocknavi.navigateTo(Screen.NEW_USER) }
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/navigation/BottomNavigationMenuTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/navigation/BottomNavigationMenuTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/navigation/BottomNavigationMenuTest.kt
new file mode 100644
--- /dev/null	(date 1730306755519)
+++ b/app/src/androidTest/java/com/android/bookswap/ui/navigation/BottomNavigationMenuTest.kt	(date 1730306755519)
@@ -0,0 +1,64 @@
+package com.android.bookswap.ui.navigation
+
+import androidx.compose.ui.test.*
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+@RunWith(AndroidJUnit4::class)
+class BottomNavigationMenuTest {
+
+  @get:Rule val composeTestRule = createComposeRule()
+
+  // Mocked Top Level Destinations from your updated structure
+  private val mockTabs =
+      listOf(TopLevelDestinations.CHAT, TopLevelDestinations.NEW_BOOK, TopLevelDestinations.MAP)
+
+  @Test
+  fun bottomNavigation_isDisplayed() {
+    composeTestRule.setContent {
+      BottomNavigationMenu(onTabSelect = {}, tabList = mockTabs, selectedItem = Route.CHAT)
+    }
+
+    // Check if the bottom navigation is displayed
+    composeTestRule.onNodeWithTag("bottomNavigationMenu").assertIsDisplayed()
+  }
+
+  @Test
+  fun bottomNavigation_hasCorrectNumberOfTabs() {
+    composeTestRule.setContent {
+      BottomNavigationMenu(onTabSelect = {}, tabList = mockTabs, selectedItem = Route.CHAT)
+    }
+
+    // Check if the correct number of tabs is displayed
+    mockTabs.forEach { tab -> composeTestRule.onNodeWithTag(tab.textId).assertExists() }
+  }
+
+  @Test
+  fun bottomNavigation_selectedItemIsHighlighted() {
+    composeTestRule.setContent {
+      BottomNavigationMenu(onTabSelect = {}, tabList = mockTabs, selectedItem = Route.MAP)
+    }
+
+    // Verify that the selected item is 'Map'
+    composeTestRule.onNodeWithTag("Map").assertIsSelected()
+  }
+
+  @Test
+  fun bottomNavigation_onTabClickInvokesCallback() {
+    var selectedTab: TopLevelDestination? = null
+
+    composeTestRule.setContent {
+      BottomNavigationMenu(
+          onTabSelect = { selectedTab = it }, tabList = mockTabs, selectedItem = Route.CHAT)
+    }
+
+    // Perform a click on the "New Book" tab
+    composeTestRule.onNodeWithTag("New Book").performClick()
+
+    // Check if the callback was triggered with the correct tab
+    assert(selectedTab?.route == Route.NEWBOOK)
+  }
+}
Index: app/src/main/java/com/android/bookswap/ui/authentication/SignIn.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/authentication/SignIn.kt b/app/src/main/java/com/android/bookswap/ui/authentication/SignIn.kt
new file mode 100644
--- /dev/null	(date 1731617442000)
+++ b/app/src/main/java/com/android/bookswap/ui/authentication/SignIn.kt	(date 1731617442000)
@@ -0,0 +1,223 @@
+package com.android.bookswap.ui.authentication
+
+// import com.android.bookswap.ui.navigation.NavigationActions
+// import com.android.bookswap.ui.navigation.TopLevelDestinations
+import android.content.Intent
+import android.util.Log
+import android.widget.Toast
+import androidx.activity.compose.ManagedActivityResultLauncher
+import androidx.activity.compose.rememberLauncherForActivityResult
+import androidx.activity.result.ActivityResult
+import androidx.activity.result.contract.ActivityResultContracts
+import androidx.compose.foundation.BorderStroke
+import androidx.compose.foundation.Image
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.shape.RoundedCornerShape
+import androidx.compose.material3.Button
+import androidx.compose.material3.ButtonDefaults
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.LaunchedEffect
+import androidx.compose.runtime.collectAsState
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.rememberCoroutineScope
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.platform.LocalContext
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.res.painterResource
+import androidx.compose.ui.res.stringResource
+import androidx.compose.ui.text.TextStyle
+import androidx.compose.ui.text.font.FontWeight
+import androidx.compose.ui.text.style.TextAlign
+import androidx.compose.ui.unit.dp
+import androidx.compose.ui.unit.sp
+import com.android.bookswap.R
+import com.android.bookswap.model.UserViewModel
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.navigation.Screen
+import com.android.bookswap.ui.navigation.TopLevelDestinations
+import com.android.bookswap.ui.theme.ColorVariable
+import com.google.android.gms.auth.api.signin.GoogleSignIn
+import com.google.android.gms.auth.api.signin.GoogleSignInOptions
+import com.google.android.gms.common.api.ApiException
+import com.google.firebase.Firebase
+import com.google.firebase.auth.AuthResult
+import com.google.firebase.auth.GoogleAuthProvider
+import com.google.firebase.auth.auth
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.tasks.await
+
+@Composable
+fun SignInScreen(
+    navigationActions: NavigationActions,
+    userVM: UserViewModel
+) { // Add this when navigation is
+  // implemented
+  val context = LocalContext.current
+  var googleUid = ""
+  // Check if user is already signed in
+  LaunchedEffect(Unit) {
+    if (Firebase.auth.currentUser != null) {
+      navigationActions.navigateTo(TopLevelDestinations.MAP)
+    }
+  }
+
+  val launcher =
+      rememberFirebaseAuthLauncher(
+          onAuthComplete = { result ->
+            val googleUserName = result.user?.displayName ?: ""
+            googleUid = result.user?.uid ?: ""
+            userVM.getUserByGoogleUid(googleUid)
+            Log.d("SignInScreen", "isStored: ${userVM.isStored}")
+            Log.d("SignInScreen", "User signed in: $googleUserName")
+            Toast.makeText(context, "Welcome $googleUserName!", Toast.LENGTH_LONG).show()
+          },
+          onAuthError = {
+            Log.e("SignInScreen", "Failed to sign in: ${it.statusCode}")
+            Toast.makeText(context, "Login Failed!", Toast.LENGTH_LONG).show()
+          })
+  val token = stringResource(R.string.default_web_client_id)
+
+  val isStored by userVM.isStored.collectAsState()
+
+  LaunchedEffect(isStored) {
+    when (isStored) {
+      true -> navigationActions.navigateTo(TopLevelDestinations.MAP)
+      false -> {
+        userVM.updateGoogleUid(googleUid)
+        navigationActions.navigateTo(Screen.NEW_USER)
+      }
+      null -> {} // Attendre que `isStored` soit défini
+    }
+  }
+
+  Scaffold(
+      modifier = Modifier.fillMaxSize().testTag("SignInScreen"),
+      containerColor = ColorVariable.BackGround, // Set the background color
+      content = { padding ->
+        Column(
+            modifier = Modifier.fillMaxSize().padding(padding),
+            horizontalAlignment = Alignment.CenterHorizontally,
+            verticalArrangement = Arrangement.Center,
+        ) {
+          // App Logo Image
+          Image(
+              painter = painterResource(id = R.drawable.logo5), // Bookswap logo
+              contentDescription = "App Logo",
+              modifier = Modifier.size(250.dp))
+
+          Spacer(modifier = Modifier.height(50.dp))
+
+          // First part of the title:
+          Text(
+              modifier = Modifier.testTag("login_loginTitle1"),
+              text = "Welcome to",
+              style =
+                  TextStyle(
+                      fontSize = 40.sp,
+                      lineHeight = 40.sp,
+                      // fontFamily = FontFamily(Font(R.font.roboto)),
+                      fontWeight = FontWeight(600),
+                      color = Color(108, 88, 76),
+                      letterSpacing = 0.4.sp,
+                      textAlign = TextAlign.Center))
+
+          Spacer(modifier = Modifier.height(5.dp))
+
+          // Second part of the logo:
+          Text(
+              modifier = Modifier.testTag("login_loginTitle2"),
+              text = "BookSwap",
+              style =
+                  TextStyle(
+                      fontSize = 60.sp,
+                      lineHeight = 40.sp,
+                      // fontFamily = FontFamily(Font(R.font.roboto)),
+                      fontWeight = FontWeight(800),
+                      color = Color(108, 88, 76),
+                      letterSpacing = 0.6.sp,
+                      textAlign = TextAlign.Center))
+
+          Spacer(modifier = Modifier.height(50.dp))
+
+          // Authenticate With Google Button
+          GoogleSignInButton(
+              onSignInClick = {
+                val gso =
+                    GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
+                        .requestIdToken(token)
+                        .requestEmail()
+                        .build()
+                val googleSignInClient = GoogleSignIn.getClient(context, gso)
+                launcher.launch(googleSignInClient.signInIntent)
+              })
+        }
+      })
+}
+
+@Composable
+fun GoogleSignInButton(onSignInClick: () -> Unit) {
+  Button(
+      onClick = onSignInClick,
+      colors =
+          ButtonDefaults.buttonColors(containerColor = ColorVariable.Secondary), // Button color
+      shape = RoundedCornerShape(50), // Circular edges for the button
+      border = BorderStroke(1.dp, ColorVariable.Primary), // Button's border color
+      modifier =
+          Modifier.padding(8.dp)
+              .height(48.dp) // Adjust height as needed
+              .testTag("loginButton")) {
+        Row(
+            verticalAlignment = Alignment.CenterVertically,
+            horizontalArrangement = Arrangement.Center,
+            modifier = Modifier.fillMaxWidth()) {
+              // Google logo
+              Image(
+                  painter = painterResource(id = R.drawable.google_logo), // Google logo
+                  contentDescription = "Google Logo",
+                  modifier =
+                      Modifier.size(30.dp) // Size of the Google logo
+                          .padding(end = 8.dp))
+
+              // Text for the button
+              Text(
+                  text = "Sign in with Google",
+                  color = ColorVariable.Accent, // Text color
+                  fontSize = 16.sp, // Font size
+                  fontWeight = FontWeight.Medium)
+            }
+      }
+}
+
+@Composable
+fun rememberFirebaseAuthLauncher(
+    onAuthComplete: (AuthResult) -> Unit,
+    onAuthError: (ApiException) -> Unit
+): ManagedActivityResultLauncher<Intent, ActivityResult> {
+  val scope = rememberCoroutineScope()
+  return rememberLauncherForActivityResult(ActivityResultContracts.StartActivityForResult()) {
+      result ->
+    val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)
+    try {
+      val account = task.getResult(ApiException::class.java)!!
+      val credential = GoogleAuthProvider.getCredential(account.idToken!!, null)
+      scope.launch {
+        val authResult = Firebase.auth.signInWithCredential(credential).await()
+        onAuthComplete(authResult)
+      }
+    } catch (e: ApiException) {
+      onAuthError(e)
+    }
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/chat/ChatScreenTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/chat/ChatScreenTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/chat/ChatScreenTest.kt
new file mode 100644
--- /dev/null	(date 1731617426000)
+++ b/app/src/androidTest/java/com/android/bookswap/ui/chat/ChatScreenTest.kt	(date 1731617426000)
@@ -0,0 +1,519 @@
+package com.android.bookswap.ui.chat
+
+import android.content.Context
+import androidx.compose.ui.semantics.SemanticsActions
+import androidx.compose.ui.semantics.SemanticsProperties
+import androidx.compose.ui.semantics.getOrNull
+import androidx.compose.ui.test.assertHasClickAction
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.assertTextEquals
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onAllNodesWithTag
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.compose.ui.test.performClick
+import androidx.compose.ui.test.performScrollToIndex
+import androidx.compose.ui.test.performSemanticsAction
+import androidx.compose.ui.test.performTextClearance
+import androidx.compose.ui.test.performTextInput
+import com.android.bookswap.data.DataMessage
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.MessageType
+import com.android.bookswap.data.repository.MessageRepository
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.theme.ColorVariable
+import com.google.firebase.firestore.ListenerRegistration
+import io.mockk.mockk
+import java.text.SimpleDateFormat
+import java.util.Date
+import java.util.Locale
+import java.util.UUID
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+class ChatScreenTest {
+  @get:Rule val composeTestRule = createComposeRule()
+  private lateinit var placeHolderData: List<DataMessage>
+  private lateinit var mockMessageRepository: MessageRepository
+  private val currentUserUUID = UUID.randomUUID()
+  private val otherUserUUID = UUID.randomUUID()
+  private lateinit var mockNavigationActions: NavigationActions
+  private val currentUser =
+      DataUser(
+          currentUserUUID, "Hello", "Jaime", "Oliver Pastor", "", "", 0.0, 0.0, "", emptyList(), "")
+  private val otherUser =
+      DataUser(otherUserUUID, "Hey", "Matias", "Salvade", "", "", 0.0, 0.0, "", emptyList(), "")
+
+  @Before
+  fun setUp() {
+    mockNavigationActions = mockk()
+
+    placeHolderData =
+        List(6) {
+              DataMessage(
+                  messageType = MessageType.TEXT,
+                  uuid = UUID.randomUUID(),
+                  senderUUID = currentUserUUID,
+                  receiverUUID = otherUserUUID,
+                  text = "Test message $it",
+                  timestamp = it.toLong())
+            }
+            .toMutableList()
+    (placeHolderData as MutableList<DataMessage>).add(
+        DataMessage(
+            messageType = MessageType.IMAGE,
+            uuid = imageTestMessageUUID,
+            senderUUID = currentUserUUID,
+            receiverUUID = otherUserUUID,
+            text = "Test message 101",
+            timestamp = 101L))
+    mockMessageRepository =
+        MockMessageFirestoreSource().apply {
+          messages = placeHolderData as MutableList<DataMessage>
+        }
+  }
+
+  private val palette =
+      listOf(
+          ColorVariable.Primary,
+          ColorVariable.Secondary,
+          ColorVariable.Accent,
+          ColorVariable.AccentSecondary,
+          ColorVariable.BackGround)
+
+  @Test
+  fun testFormatTimeStamps() {
+    val timestamp = System.currentTimeMillis()
+    val formattedTimestamp = formatTimestamp(timestamp)
+    val expectedTimestamp = SimpleDateFormat("HH:mm", Locale.getDefault()).format(Date(timestamp))
+    assert(formattedTimestamp == expectedTimestamp)
+  }
+
+  @Test
+  fun hasRequiredComponentsWithoutMessage() {
+    composeTestRule.setContent {
+      ChatScreen(
+          messageRepository = mockMessageRepository,
+          currentUser = currentUser,
+          otherUser = otherUser,
+          mockNavigationActions)
+    }
+    composeTestRule.onNodeWithTag("message_input_field").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("send_button").assertIsDisplayed()
+  }
+
+  @Test
+  fun hasRequiredComponentsAndShowsMessages() {
+    val mockMessageRepository =
+        MockMessageFirestoreSource().apply { messages = placeHolderData.toMutableList() }
+
+    composeTestRule.setContent {
+      ChatScreen(
+          messageRepository = mockMessageRepository,
+          currentUser = currentUser,
+          otherUser = otherUser,
+          mockNavigationActions)
+    }
+    composeTestRule.onNodeWithTag("message_input_field").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("send_button").assertIsDisplayed()
+    placeHolderData.forEach { message ->
+      if (message.uuid != imageTestMessageUUID) {
+        composeTestRule.waitUntil {
+          composeTestRule
+              .onAllNodesWithTag("message_item ${message.uuid}", useUnmergedTree = true)
+              .fetchSemanticsNodes()
+              .isNotEmpty()
+        }
+        composeTestRule
+            .onNodeWithTag("message_item ${message.uuid}", useUnmergedTree = true)
+            .assertIsDisplayed()
+        composeTestRule
+            .onNodeWithTag("message_text ${message.uuid}", useUnmergedTree = true)
+            .assertIsDisplayed()
+        composeTestRule
+            .onNodeWithTag("message_text ${message.uuid}", useUnmergedTree = true)
+            .assertTextEquals(message.text)
+        composeTestRule
+            .onNodeWithTag("message_timestamp ${message.uuid}", useUnmergedTree = true)
+            .assertIsDisplayed()
+        composeTestRule
+            .onNodeWithTag("message_timestamp ${message.uuid}", useUnmergedTree = true)
+            .assertTextEquals(formatTimestamp(message.timestamp))
+      }
+    }
+  }
+
+  @Test
+  fun checkLastMessageIsImage() {
+    val mockMessageRepository =
+        MockMessageFirestoreSource().apply { messages = placeHolderData.toMutableList() }
+
+    composeTestRule.setContent {
+      ChatScreen(
+          messageRepository = mockMessageRepository,
+          currentUser = currentUser,
+          otherUser = otherUser,
+          mockNavigationActions)
+    }
+
+    composeTestRule
+        .onNodeWithTag("column", useUnmergedTree = true)
+        .performScrollToIndex(mockMessageRepository.messages.size - 1)
+
+    composeTestRule
+        .onNodeWithTag("hobbit", useUnmergedTree = true)
+        .assertExists("The last message should be an image with the test tag 'hobbit'")
+  }
+
+  @Test
+  fun hasClickableButton() {
+    composeTestRule.setContent {
+      ChatScreen(
+          messageRepository = mockMessageRepository,
+          currentUser = currentUser,
+          otherUser = otherUser,
+          mockNavigationActions)
+    }
+    composeTestRule.onNodeWithTag("send_button").assertHasClickAction()
+  }
+
+  @Test
+  fun hasCompletableTextField() {
+    composeTestRule.setContent {
+      ChatScreen(
+          messageRepository = mockMessageRepository,
+          currentUser = currentUser,
+          otherUser = otherUser,
+          mockNavigationActions)
+    }
+    val testInput = "Hello, World!"
+    composeTestRule.onNodeWithTag("message_input_field").performTextInput(testInput)
+    composeTestRule.onNodeWithTag("message_input_field").assertTextEquals(testInput)
+  }
+
+  @Test
+  fun testSendMessage() {
+    val testMessageId = UUID.randomUUID()
+    val mockMessageRepository = MockMessageFirestoreSource().apply { mockNewUUID = testMessageId }
+
+    composeTestRule.setContent {
+      ChatScreen(
+          messageRepository = mockMessageRepository,
+          currentUser = currentUser,
+          otherUser = otherUser,
+          mockNavigationActions)
+    }
+
+    val testInput = "Hello, World!"
+
+    composeTestRule.onNodeWithTag("message_input_field").performTextInput(testInput)
+    composeTestRule.onNodeWithTag("send_button").performClick()
+
+    // Verify that the message was sent
+    val sentMessage = mockMessageRepository.messages.find { it.uuid == testMessageId }
+    assert(sentMessage != null) { "Message was not sent" }
+    assert(sentMessage?.text == testInput) { "Message text does not match" }
+    assert(sentMessage?.senderUUID == currentUserUUID) { "Sender UUID does not match" }
+    assert(sentMessage?.receiverUUID == otherUserUUID) { "Receiver UUID does not match" }
+  }
+
+  @Test
+  fun testTopAppBar() {
+    composeTestRule.setContent {
+      ChatScreen(
+          messageRepository = mockMessageRepository,
+          currentUser = currentUser,
+          otherUser = otherUser,
+          mockNavigationActions)
+    }
+
+    composeTestRule.onNodeWithTag("chatTopAppBar").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("chatName").assertIsDisplayed()
+    composeTestRule
+        .onNodeWithTag("chatName")
+        .assertTextEquals(otherUser.firstName + " " + otherUser.lastName)
+    composeTestRule.onNodeWithTag("profileIcon", useUnmergedTree = true).assertIsDisplayed()
+  }
+
+  @Test
+  fun testPopUpExists() {
+    composeTestRule.setContent {
+      ChatScreen(
+          messageRepository = mockMessageRepository,
+          currentUser = currentUser,
+          otherUser = otherUser,
+          navController = mockNavigationActions)
+    }
+
+    composeTestRule.waitForIdle()
+
+    val messageNode =
+        composeTestRule.onNodeWithTag(
+            "message_item ${placeHolderData.first().uuid}", useUnmergedTree = true)
+    messageNode.assertExists("Message item not found")
+
+    messageNode.performSemanticsAction(SemanticsActions.OnLongClick)
+
+    composeTestRule.waitUntil(timeoutMillis = 5000) {
+      composeTestRule
+          .onAllNodesWithTag("editButton", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isNotEmpty() &&
+          composeTestRule
+              .onAllNodesWithTag("deleteButton", useUnmergedTree = true)
+              .fetchSemanticsNodes()
+              .isNotEmpty()
+    }
+
+    composeTestRule.onNodeWithTag("editButton", useUnmergedTree = true).assertIsDisplayed()
+    composeTestRule.onNodeWithTag("deleteButton", useUnmergedTree = true).assertIsDisplayed()
+
+    composeTestRule.onNodeWithTag("editButton", useUnmergedTree = true).assertHasClickAction()
+    composeTestRule.onNodeWithTag("deleteButton", useUnmergedTree = true).assertHasClickAction()
+  }
+
+  @Test
+  fun testDelete() {
+    val mockMessageRepository =
+        MockMessageFirestoreSource().apply { messages = placeHolderData.toMutableList() }
+
+    composeTestRule.setContent {
+      ChatScreen(
+          messageRepository = mockMessageRepository,
+          currentUser = currentUser,
+          otherUser = otherUser,
+          mockNavigationActions)
+    }
+
+    val message = placeHolderData.first()
+    val messageNode =
+        composeTestRule.onNodeWithTag("message_item ${message.uuid}", useUnmergedTree = true)
+    messageNode.assertExists("Message item not found")
+
+    messageNode.performSemanticsAction(SemanticsActions.OnLongClick)
+
+    composeTestRule.waitUntil(timeoutMillis = 5000) {
+      composeTestRule
+          .onAllNodesWithTag("deleteButton", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isNotEmpty()
+    }
+
+    composeTestRule.onNodeWithTag("deleteButton", useUnmergedTree = true).performClick()
+
+    val deletedMessage = mockMessageRepository.messages.find { it.uuid == message.uuid }
+    assert(deletedMessage == null) { "Message was not deleted" }
+
+    composeTestRule.waitUntil(timeoutMillis = 5000) {
+      composeTestRule
+          .onAllNodesWithTag("message_item ${message.uuid}", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isEmpty()
+    }
+
+    composeTestRule
+        .onNodeWithTag("message_item ${message.uuid}", useUnmergedTree = true)
+        .assertDoesNotExist()
+  }
+
+  @Test
+  fun testEdit() {
+    val mockMessageRepository =
+        MockMessageFirestoreSource().apply { messages = placeHolderData.toMutableList() }
+
+    composeTestRule.setContent {
+      ChatScreen(
+          messageRepository = mockMessageRepository,
+          currentUser = currentUser,
+          otherUser = otherUser,
+          navController = mockNavigationActions)
+    }
+
+    val message = placeHolderData.first()
+    val newText = "Updated message text"
+
+    val messageNode =
+        composeTestRule.onNodeWithTag("message_item ${message.uuid}", useUnmergedTree = true)
+    messageNode.assertExists("Message item not found")
+
+    messageNode.performSemanticsAction(SemanticsActions.OnLongClick)
+
+    composeTestRule.waitUntil(timeoutMillis = 5000) {
+      composeTestRule
+          .onAllNodesWithTag("editButton", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isNotEmpty()
+    }
+
+    composeTestRule.onNodeWithTag("editButton", useUnmergedTree = true).performClick()
+
+    composeTestRule
+        .onNodeWithTag("message_input_field", useUnmergedTree = true)
+        .assertTextEquals(message.text)
+
+    composeTestRule
+        .onNodeWithTag("message_input_field", useUnmergedTree = true)
+        .performTextClearance()
+    composeTestRule
+        .onNodeWithTag("message_input_field", useUnmergedTree = true)
+        .performTextInput(newText)
+    composeTestRule.onNodeWithTag("send_button", useUnmergedTree = true).performClick()
+
+    composeTestRule.waitUntil(timeoutMillis = 5000) {
+      mockMessageRepository.messages.find { it.uuid == message.uuid }?.text == newText
+    }
+
+    val updatedMessage = mockMessageRepository.messages.find { it.uuid == message.uuid }
+    assert(updatedMessage != null && updatedMessage.text == newText) {
+      "Message was not updated correctly"
+    }
+
+    composeTestRule.waitUntil(timeoutMillis = 5000) {
+      composeTestRule
+          .onNodeWithTag("message_text ${message.uuid}", useUnmergedTree = true)
+          .fetchSemanticsNode()
+          .config
+          .getOrNull(SemanticsProperties.Text)
+          ?.joinToString() == newText
+    }
+
+    composeTestRule
+        .onNodeWithTag("message_text ${message.uuid}", useUnmergedTree = true)
+        .assertTextEquals(newText)
+
+    composeTestRule
+        .onNodeWithTag("message_input_field", useUnmergedTree = true)
+        .assertTextEquals("")
+  }
+
+  @Test
+  fun scrollToBottomClickImageAndCheckPopup() {
+    val mockMessageRepository =
+        MockMessageFirestoreSource().apply { messages = placeHolderData.toMutableList() }
+
+    composeTestRule.setContent {
+      ChatScreen(
+          messageRepository = mockMessageRepository,
+          currentUser = currentUser,
+          otherUser = otherUser,
+          mockNavigationActions)
+    }
+
+    composeTestRule
+        .onNodeWithTag("column", useUnmergedTree = true)
+        .performScrollToIndex(mockMessageRepository.messages.size - 1)
+
+    composeTestRule
+        .onNodeWithTag("message_item_column $imageTestMessageUUID", useUnmergedTree = true)
+        .performClick()
+
+    composeTestRule.waitUntil(timeoutMillis = 5000) {
+      composeTestRule
+          .onAllNodesWithTag("popupImage", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isNotEmpty()
+    }
+    composeTestRule.onNodeWithTag("popupImage", useUnmergedTree = true).assertIsDisplayed()
+
+    composeTestRule.onNodeWithTag("popupImage", useUnmergedTree = true).performClick()
+
+    composeTestRule.waitUntil(timeoutMillis = 5000) {
+      composeTestRule
+          .onAllNodesWithTag("popupImage", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isEmpty()
+    }
+    composeTestRule.onNodeWithTag("popupImage", useUnmergedTree = true).assertDoesNotExist()
+  }
+
+  @Test
+  fun testAllColorsBelongToPalette() {
+    composeTestRule.setContent {
+      ChatScreen(
+          messageRepository = mockMessageRepository,
+          currentUser = currentUser,
+          otherUser = otherUser,
+          mockNavigationActions)
+    }
+
+    val uiColors =
+        listOf(
+            ColorVariable.Primary,
+            ColorVariable.Secondary,
+            ColorVariable.Accent,
+            ColorVariable.AccentSecondary,
+            ColorVariable.BackGround)
+
+    uiColors.forEach { color ->
+      assert(palette.contains(color)) { "Color $color does not belong to the palette" }
+    }
+  }
+
+  class MockMessageFirestoreSource : MessageRepository {
+    var mockNewUUID: UUID = UUID.randomUUID()
+    var messages: MutableList<DataMessage> = mutableListOf()
+    private var sendMessageResult: Result<Unit> = Result.success(Unit)
+
+    override fun init(callback: (Result<Unit>) -> Unit) {
+      callback(Result.success(Unit))
+    }
+
+    override fun getNewUUID(): UUID {
+      return mockNewUUID
+    }
+
+    override fun getMessages(callback: (Result<List<DataMessage>>) -> Unit) {
+      callback(Result.success(messages))
+    }
+
+    override fun sendMessage(message: DataMessage, callback: (Result<Unit>) -> Unit) {
+      messages.add(message)
+      callback(sendMessageResult)
+    }
+
+    override fun deleteMessage(
+        messageUUID: UUID,
+        callback: (Result<Unit>) -> Unit,
+        context: Context
+    ) {
+      messages.removeIf { it.uuid == messageUUID }
+      callback(Result.success(Unit))
+    }
+
+    override fun deleteAllMessages(
+        user1UUID: UUID,
+        user2UUID: UUID,
+        callback: (Result<Unit>) -> Unit
+    ) {
+      messages.removeIf { it.senderUUID == user1UUID && it.receiverUUID == user2UUID }
+      messages.removeIf { it.senderUUID == user2UUID && it.receiverUUID == user1UUID }
+      callback(Result.success(Unit))
+    }
+
+    override fun updateMessage(
+        message: DataMessage,
+        callback: (Result<Unit>) -> Unit,
+        context: Context
+    ) {
+      val index = messages.indexOfFirst { it.uuid == message.uuid }
+      if (index != -1) {
+        messages[index] = message.copy(text = message.text) // Update the message text
+        callback(Result.success(Unit)) // Simulate success
+      } else {
+        callback(Result.failure(Exception("Message not found")))
+      }
+    }
+
+    override fun addMessagesListener(
+        otherUserUUID: UUID,
+        currentUserUUID: UUID,
+        callback: (Result<List<DataMessage>>) -> Unit
+    ): ListenerRegistration {
+      requireNotNull(otherUserUUID) { "otherUserId must not be null" }
+      requireNotNull(currentUserUUID) { "currentUserId must not be null" }
+
+      callback(Result.success(messages)) // Or whatever logic you'd like to simulate
+      return mockk()
+    }
+  }
+}
Index: app/src/main/java/com/android/bookswap/ui/map/FilterMap.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/map/FilterMap.kt b/app/src/main/java/com/android/bookswap/ui/map/FilterMap.kt
new file mode 100644
--- /dev/null	(date 1730385753960)
+++ b/app/src/main/java/com/android/bookswap/ui/map/FilterMap.kt	(date 1730385753960)
@@ -0,0 +1,212 @@
+package com.android.bookswap.ui.map
+
+import android.widget.Toast
+import androidx.compose.foundation.border
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.ExperimentalLayoutApi
+import androidx.compose.foundation.layout.FlowRow
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.width
+import androidx.compose.foundation.layout.wrapContentSize
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.foundation.shape.RoundedCornerShape
+import androidx.compose.material3.BottomAppBar
+import androidx.compose.material3.Button
+import androidx.compose.material3.ButtonDefaults
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.Text
+import androidx.compose.material3.TopAppBar
+import androidx.compose.material3.TopAppBarDefaults
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.collectAsState
+import androidx.compose.runtime.getValue
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.platform.LocalContext
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.text.TextStyle
+import androidx.compose.ui.text.font.FontWeight
+import androidx.compose.ui.text.style.TextAlign
+import androidx.compose.ui.unit.dp
+import androidx.compose.ui.unit.sp
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.model.map.BookFilter
+import com.android.bookswap.ui.components.BackButtonComponent
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.theme.ColorVariable
+
+/** Constants */
+private const val TOP_BAR_TITLE_WIDTH_RATIO = 3 / 4f
+private val BUTTON_WIDTH = 173.dp
+private val BUTTON_HEIGHT = 43.24.dp
+private val TOP_BAR_TITLE_FONT_SIZE = 30.sp
+private val TOP_BAR_TITLE_LINE_HEIGHT = 20.sp
+private val TOP_BAR_TITLE_LETTER_SPACING = 0.3.sp
+private val TOP_BAR_TITLE_FONT_WEIGHT = FontWeight(700)
+
+/**
+ * This is the main screen for the filter feature. It displays the filters for the user to select
+ *
+ * @param navigationActions The navigation actions to navigate between screens
+ * @param bookFilter The filter object that contains the selected filters
+ */
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun FilterMapScreen(navigationActions: NavigationActions, bookFilter: BookFilter) {
+
+  val selectedFiltersGenres by bookFilter.genresFilter.collectAsState() // genre filter
+  val selectedFiltersLanguages by bookFilter.languagesFilter.collectAsState() // language filter
+  val context = LocalContext.current
+
+  Scaffold(
+      containerColor = ColorVariable.BackGround,
+      topBar = {
+        TopAppBar(
+            colors =
+                TopAppBarDefaults.smallTopAppBarColors(containerColor = ColorVariable.BackGround),
+            title = {
+              Text(
+                  text = "Filters", // Hard coded string that should be extracted to a strings.xml
+                  modifier =
+                      Modifier.fillMaxWidth(TOP_BAR_TITLE_WIDTH_RATIO)
+                          .testTag("filter_filterScreenTitle"),
+                  textAlign = TextAlign.Center,
+                  style =
+                      TextStyle(
+                          fontSize =
+                              TOP_BAR_TITLE_FONT_SIZE, // Hard coded style that should be extracted
+                          // to a theme
+                          lineHeight = TOP_BAR_TITLE_LINE_HEIGHT,
+                          fontWeight = TOP_BAR_TITLE_FONT_WEIGHT,
+                          color = ColorVariable.Accent,
+                          letterSpacing = TOP_BAR_TITLE_LETTER_SPACING,
+                      ))
+            },
+            navigationIcon = { BackButtonComponent(navigationActions) })
+      },
+      content = { paddingValues ->
+        LazyColumn(contentPadding = paddingValues, modifier = Modifier.fillMaxSize()) {
+          item {
+            ButtonBlock(
+                BookGenres.values().map { it.Genre }, selectedFiltersGenres.map { it.Genre }) {
+                    newSelection ->
+                  bookFilter.setGenres(newSelection) // Actualize the selected genres as OnClick
+            }
+          }
+          item {
+            ButtonBlock(
+                buttonTexts =
+                    BookLanguages.values().map {
+                      it.toString().lowercase().replaceFirstChar { c -> c.uppercase() }
+                    },
+                selectedFiltersLanguages.map {
+                  it.name.lowercase().replaceFirstChar { c -> c.uppercase() }
+                }) { newSelection ->
+                  bookFilter.setLanguages(
+                      newSelection) // Actualize the selected languages as OnClick
+            }
+          }
+        }
+      },
+      bottomBar = {
+        BottomAppBar(containerColor = ColorVariable.BackGround) {
+          Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
+            Button(
+                onClick = {
+                  bookFilter.setGenres(selectedFiltersGenres.map { it.name })
+                  bookFilter.setLanguages(selectedFiltersLanguages.map { it.name })
+                  Toast.makeText(context, "Filters applied", Toast.LENGTH_SHORT).show()
+                  navigationActions.goBack()
+                },
+                colors = ButtonDefaults.buttonColors(ColorVariable.Primary),
+                modifier =
+                    Modifier.width(BUTTON_WIDTH)
+                        .height(BUTTON_HEIGHT)
+                        .testTag("filter_applyButton")) {
+                  Text(
+                      text = "Apply",
+                      textAlign = TextAlign.Center,
+                      style =
+                          TextStyle(
+                              color = ColorVariable.BackGround,
+                          ))
+                }
+          }
+        }
+      })
+}
+
+/** Constants */
+private val BUTTON_HEIGHT_BB = 35.dp
+private val BORDER_WIDTH_BB = 3.dp
+private val BUTTON_PADDING_BB = 1.dp
+private val BUTTON_SHAPE_BB = RoundedCornerShape(25.dp)
+private val HORIZONTAL_PADDING_BB = 37.dp
+private val VERTICAL_PADDING_BB = 20.dp
+private const val MAX_ITEMS_PER_ROW_BB = 3
+
+/**
+ * This is a composable that displays a row of buttons
+ *
+ * @param buttonTexts The list of strings to display on the buttons
+ * @param selectedFilters The list of strings that are currently selected
+ * @param onSelectionChange The function to call when the selection changes
+ */
+@OptIn(ExperimentalLayoutApi::class)
+@Composable
+fun ButtonBlock(
+    buttonTexts: List<String>,
+    selectedFilters: List<String>,
+    onSelectionChange: (List<String>) -> Unit
+) {
+  FlowRow(
+      modifier =
+          Modifier.fillMaxWidth()
+              .padding(
+                  top = VERTICAL_PADDING_BB,
+                  start = HORIZONTAL_PADDING_BB,
+                  end = HORIZONTAL_PADDING_BB,
+                  bottom = VERTICAL_PADDING_BB),
+      maxItemsInEachRow = MAX_ITEMS_PER_ROW_BB,
+      horizontalArrangement = Arrangement.Center) {
+        buttonTexts.forEach { text ->
+          val isSelected = selectedFilters.contains(text)
+
+          Button(
+              onClick = {
+                val newSelection =
+                    if (isSelected) {
+                      selectedFilters - text
+                    } else {
+                      selectedFilters + text
+                    }
+                onSelectionChange(newSelection)
+              },
+              modifier =
+                  Modifier.wrapContentSize()
+                      .padding(BUTTON_PADDING_BB)
+                      .border(
+                          BORDER_WIDTH_BB, color = ColorVariable.Accent, shape = BUTTON_SHAPE_BB)
+                      .height(BUTTON_HEIGHT_BB)
+                      .testTag("filter_buttonFilter_${text}"),
+              colors =
+                  ButtonDefaults.buttonColors(
+                      containerColor =
+                          if (isSelected) ColorVariable.Accent else ColorVariable.BackGround),
+              shape = BUTTON_SHAPE_BB) {
+                Text(
+                    text = text,
+                    style =
+                        TextStyle(
+                            color =
+                                if (isSelected) ColorVariable.BackGround else ColorVariable.Accent))
+              }
+        }
+      }
+}
Index: app/src/test/java/com/android/bookswap/model/chat/PermissionHandlerTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/model/chat/PermissionHandlerTest.kt b/app/src/test/java/com/android/bookswap/model/chat/PermissionHandlerTest.kt
new file mode 100644
--- /dev/null	(date 1730451037652)
+++ b/app/src/test/java/com/android/bookswap/model/chat/PermissionHandlerTest.kt	(date 1730451037652)
@@ -0,0 +1,112 @@
+package com.android.bookswap.model.chat
+
+import android.Manifest
+import android.content.Context
+import android.content.pm.PackageManager
+import android.os.Build
+import android.widget.Toast
+import androidx.activity.ComponentActivity
+import androidx.core.content.ContextCompat
+import androidx.test.core.app.ApplicationProvider
+import com.google.firebase.FirebaseApp
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mock
+import org.mockito.Mockito.*
+import org.mockito.MockitoAnnotations
+import org.robolectric.Robolectric
+import org.robolectric.RobolectricTestRunner
+import org.robolectric.annotation.Config
+
+@RunWith(RobolectricTestRunner::class)
+@Config(sdk = [Build.VERSION_CODES.TIRAMISU], application = TestApplicationChat::class)
+class PermissionHandlerTest {
+
+  @Mock private lateinit var mockActivity: ComponentActivity
+
+  private lateinit var permissionHandler: PermissionHandler
+
+  @Before
+  fun setUp() {
+    MockitoAnnotations.openMocks(this)
+    mockActivity = spy(Robolectric.buildActivity(ComponentActivity::class.java).get())
+    permissionHandler = PermissionHandler(mockActivity)
+    FirebaseApp.initializeApp(ApplicationProvider.getApplicationContext<Context>())
+  }
+
+  @Test
+  fun `test askNotificationPermission when permission is granted`() {
+    // Arrange
+    mockStatic(ContextCompat::class.java).use { mockedContextCompat ->
+      mockedContextCompat
+          .`when`<Int> {
+            ContextCompat.checkSelfPermission(mockActivity, Manifest.permission.POST_NOTIFICATIONS)
+          }
+          .thenReturn(PackageManager.PERMISSION_GRANTED)
+
+      // Act
+      permissionHandler.askNotificationPermission()
+
+      // Assert
+      verify(mockActivity, never())
+          .shouldShowRequestPermissionRationale(Manifest.permission.POST_NOTIFICATIONS)
+    }
+  }
+
+  @Test
+  fun `test askNotificationPermission when permission is not granted and rationale should not be shown`() {
+    // Arrange
+    reset(mockActivity)
+    mockStatic(ContextCompat::class.java).use { mockedContextCompat ->
+      `when`(
+              ContextCompat.checkSelfPermission(
+                  any(Context::class.java), eq(Manifest.permission.POST_NOTIFICATIONS)))
+          .thenReturn(PackageManager.PERMISSION_DENIED)
+
+      `when`(
+              mockActivity.shouldShowRequestPermissionRationale(
+                  Manifest.permission.POST_NOTIFICATIONS))
+          .thenReturn(false)
+
+      // Act
+      permissionHandler.askNotificationPermission()
+
+      // Assert
+      verify(mockActivity, times(1))
+          .shouldShowRequestPermissionRationale(Manifest.permission.POST_NOTIFICATIONS)
+
+      // Ensure no other interactions are made with this method
+      verifyNoMoreInteractions(mockActivity)
+    }
+  }
+
+  @Test
+  fun `test enableNotifications shows toast`() {
+    // Arrange
+    val toast = mock(Toast::class.java)
+    mockStatic(Toast::class.java).use { mockedToast ->
+      `when`(Toast.makeText(any(Context::class.java), anyString(), anyInt())).thenReturn(toast)
+
+      // Act
+      permissionHandler.enableNotifications()
+
+      // Assert
+      verify(toast, times(1)).show()
+    }
+  }
+
+  @Test
+  fun `test informUserNotificationsDisabled shows toast`() {
+    // Arrange
+    val toast = mock(Toast::class.java)
+    mockStatic(Toast::class.java).use { mockedToast ->
+      `when`(Toast.makeText(any(Context::class.java), anyString(), anyInt())).thenReturn(toast)
+      // Act
+      permissionHandler.informUserNotificationsDisabled()
+
+      // Assert
+      verify(toast, times(1)).show()
+    }
+  }
+}
Index: app/src/test/java/com/android/bookswap/model/chat/MyFirestoreMessagingServiceTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/model/chat/MyFirestoreMessagingServiceTest.kt b/app/src/test/java/com/android/bookswap/model/chat/MyFirestoreMessagingServiceTest.kt
new file mode 100644
--- /dev/null	(date 1730451037652)
+++ b/app/src/test/java/com/android/bookswap/model/chat/MyFirestoreMessagingServiceTest.kt	(date 1730451037652)
@@ -0,0 +1,58 @@
+package com.android.bookswap.model.chat
+
+import android.app.NotificationManager
+import android.content.Context
+import com.google.firebase.messaging.RemoteMessage
+import junit.framework.TestCase.assertNotNull
+import junit.framework.TestCase.assertTrue
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.Robolectric
+import org.robolectric.RobolectricTestRunner
+import org.robolectric.Shadows
+
+@RunWith(RobolectricTestRunner::class)
+class MyFirebaseMessagingServiceTest {
+
+  private lateinit var service: MyFirebaseMessagingService
+
+  @Before
+  fun setup() {
+    // Initialize the service with Robolectric
+    service = Robolectric.setupService(MyFirebaseMessagingService::class.java)
+  }
+
+  @Test
+  fun testSendNotification_createsNotification() {
+    // Mock RemoteMessage to pass to the service
+    val remoteMessage = RemoteMessage.Builder("testSender").setMessageId("testMessageId").build()
+
+    // Trigger the notification
+    service.onMessageReceived(remoteMessage)
+
+    // Use ShadowNotificationManager to get the notification manager
+    val notificationManager =
+        Shadows.shadowOf(
+            service.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager)
+
+    // Assert that a notification was posted
+    val postedNotifications = notificationManager.allNotifications
+    assertNotNull("Notification should have been posted", postedNotifications)
+    assertTrue("Notification list should not be empty", postedNotifications.isNotEmpty())
+  }
+
+  @Test
+  fun testOnMessageReceived_withNotificationPayload() {
+    // Mock RemoteMessage with notification payload
+    val remoteMessage = RemoteMessage.Builder("testSender").setMessageId("testMessageId").build()
+
+    // Trigger the notification
+    service.onMessageReceived(remoteMessage)
+
+    // Use ShadowNotificationManager to get the notification manager
+    val notificationManager =
+        Shadows.shadowOf(
+            service.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager)
+  }
+}
Index: app/src/main/java/com/android/bookswap/data/source/network/UserFirestoreSource.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/source/network/UserFirestoreSource.kt b/app/src/main/java/com/android/bookswap/data/source/network/UserFirestoreSource.kt
new file mode 100644
--- /dev/null	(date 1731617442000)
+++ b/app/src/main/java/com/android/bookswap/data/source/network/UserFirestoreSource.kt	(date 1731617442000)
@@ -0,0 +1,171 @@
+package com.android.bookswap.data.source.network
+
+import android.util.Log
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.repository.UsersRepository
+import com.google.android.gms.tasks.Task
+import com.google.firebase.firestore.DocumentSnapshot
+import com.google.firebase.firestore.FirebaseFirestore
+import java.util.UUID
+
+/** Name of the Firestore collection that stores users */
+private const val COLLECTION_NAME = "Users"
+
+/** Implement [UsersRepository] interface using Firebase's Firestore as the data source */
+class UserFirestoreSource(private val db: FirebaseFirestore) : UsersRepository {
+  /**
+   * Fetches the list of users from the Firestore collection If the task is successful, maps the
+   * Firestore documents to DataUser objects Calls OnSuccess with the list of users, or onFailure if
+   * the task fails
+   */
+  override fun getUsers(callback: (Result<List<DataUser>>) -> Unit) {
+    db.collection(COLLECTION_NAME).get().addOnCompleteListener { task ->
+      if (task.isSuccessful) {
+        // Maps Firestore documents to DataUser objects or returns an empty list
+        callback(
+            Result.success(
+                task.result?.mapNotNull { documentToUser(it).getOrNull() } ?: emptyList()))
+      } else {
+        callback(Result.failure(task.exception!!))
+      }
+    }
+  }
+  /**
+   * Fetches the list of users from the Firestore collection If the task is successful, maps the
+   * Firestore documents to DataUser objects Calls OnSuccess with the list of users, or onFailure if
+   * the task fails
+   */
+  override fun getUser(uuid: UUID, callback: (Result<DataUser>) -> Unit) {
+
+    db.collection(COLLECTION_NAME).whereEqualTo("UUID", uuid).get().addOnCompleteListener { task ->
+      if (task.isSuccessful) {
+        // Maps Firestore documents to DataUser objects or returns an empty list
+        callback(
+            Result.success(
+                task.result?.firstNotNullOfOrNull { documentToUser(it).getOrNull() } ?: DataUser()))
+      } else {
+        callback(Result.failure(task.exception!!))
+      }
+    }
+  }
+  /**
+   * Fetches the list of users from the Firestore collection If the task is successful, maps the
+   * Firestore documents to DataUser objects Calls OnSuccess with the list of users, or onFailure if
+   * the task fails
+   */
+  override fun getUser(googleUid: String, callback: (Result<DataUser>) -> Unit) {
+    db.collection(COLLECTION_NAME)
+        .whereEqualTo("googleUid", googleUid)
+        .get()
+        .addOnCompleteListener { task ->
+          if (task.isSuccessful) {
+            Log.d("TAG_USR_GET_BY_GUID", "usr count: ${task.result?.size()}")
+            val user = task.result?.firstNotNullOfOrNull { documentToUser(it).getOrNull() }
+            if (user != null) {
+              callback(Result.success(user))
+            } else {
+              callback(
+                  Result.failure(
+                      NoSuchElementException("No user found with googleUID: $googleUid")))
+            }
+          } else {
+            callback(Result.failure(task.exception ?: Exception("Unknown error occurred")))
+          }
+        }
+  }
+
+  /** Adds a new user to the Firestore collection */
+  override fun addUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit) {
+    performFirestoreOperation(
+        db.collection(COLLECTION_NAME).document(dataUser.userUUID.toString()).set(dataUser),
+        callback,
+    )
+  }
+  /**
+   * Updates an existing user in Firestore by replacing the document with the same title Uses
+   * performFirestoreOperation to handle success and failure
+   */
+  override fun updateUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit) {
+    performFirestoreOperation(
+        db.collection(COLLECTION_NAME).document(dataUser.userUUID.toString()).set(dataUser),
+        callback)
+  }
+
+  /**
+   * Deletes a user from Firestore by its title Uses performFirestoreOperation to handle success and
+   * failure
+   */
+  override fun deleteUser(uuid: UUID, callback: (Result<Unit>) -> Unit) {
+    performFirestoreOperation(
+        db.collection(COLLECTION_NAME).document(uuid.toString()).delete(), callback)
+  }
+  /**
+   * Maps a Firestore document to a DataUser object If any required field is missing, returns null
+   * to avoid incomplete objects
+   *
+   * @return DataUser on success, otherwise error
+   */
+  fun documentToUser(document: DocumentSnapshot): Result<DataUser> {
+
+    return try {
+      val mostSignificantBits = document.getLong("userUUID.mostSignificantBits")!!
+      val leastSignificantBits = document.getLong("userUUID.leastSignificantBits")!!
+      val greeting = document.getString("greeting")!!
+      val firstname = document.getString("firstName")!!
+      val lastname = document.getString("lastName")!!
+      val email = document.getString("email")!!
+      val phoneNumber = document.getString("phoneNumber")!!
+      val latitude = document.getDouble("latitude")!!
+      val longitude = document.getDouble("longitude")!!
+      val profilePicture = document.getString("profilePictureUrl")!!
+      val googleUid = document.getString("googleUid")!!
+      Log.d("TAG_DOC2USR", "GUID: $googleUid")
+      val bookList =
+          (document.get("bookList") as List<Map<String, Long>>).map { bookMap ->
+            val mostSigBits = bookMap["mostSignificantBits"]
+            val leastSigBits = bookMap["leastSignificantBits"]
+            if (mostSigBits != null && leastSigBits != null) {
+              UUID(mostSigBits, leastSigBits)
+            } else {
+              null
+            }
+          }
+      if (bookList.any { it == null }) {
+        throw IllegalArgumentException("Book list contains null UUIDs")
+      }
+
+      Result.success(
+          DataUser(
+              UUID(mostSignificantBits, leastSignificantBits),
+              greeting,
+              firstname,
+              lastname,
+              email,
+              phoneNumber,
+              latitude,
+              longitude,
+              profilePicture,
+              bookList.filterNotNull(),
+              googleUid))
+    } catch (e: Exception) {
+      Log.e("FirestoreSource", "Error converting document to User: ${e.message}")
+      Result.failure(e)
+    }
+  }
+  /**
+   * Helper function to perform Firestore operations (add, update, delete) Executes the provided
+   * Firestore task and triggers success or failure callbacks
+   *
+   * @param callback callback function that receives Result.success() when operation succeed of
+   *   Result.failure(exception) if error
+   */
+  private fun performFirestoreOperation(task: Task<Void>, callback: (Result<Unit>) -> Unit) {
+    task.addOnCompleteListener { result ->
+      if (result.isSuccessful) {
+        callback(Result.success(Unit))
+      } else {
+        result.exception?.let { e -> callback(Result.failure(e)) }
+      }
+    }
+  }
+}
Index: app/src/main/java/com/android/bookswap/data/repository/UserRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/repository/UserRepository.kt b/app/src/main/java/com/android/bookswap/data/repository/UserRepository.kt
new file mode 100644
--- /dev/null	(date 1731617442889)
+++ b/app/src/main/java/com/android/bookswap/data/repository/UserRepository.kt	(date 1731617442889)
@@ -0,0 +1,64 @@
+package com.android.bookswap.data.repository
+
+import com.android.bookswap.data.DataUser
+import java.util.UUID
+
+/** Interface defining a contract for managing user-related operations in a repository. */
+interface UsersRepository {
+  /**
+   * Function to fetch a list of users from the repository.
+   *
+   * @param callback callback function that receives list of user if success
+   */
+  fun getUsers(
+      callback: (Result<List<DataUser>>) -> Unit,
+  )
+
+  /**
+   * Function to fetch a list of users from the repository.
+   *
+   * @param callback callback function that receives list of user if success
+   */
+  fun getUser(
+      uuid: UUID,
+      callback: (Result<DataUser>) -> Unit,
+  )
+
+  /**
+   * Function to fetch a list of users from the repository.
+   *
+   * @param googleUid The unique identifier of the user
+   * @param callback callback function that receives the DataUser if success
+   */
+  fun getUser(
+      googleUid: String,
+      callback: (Result<DataUser>) -> Unit,
+  )
+
+  /**
+   * Function to add a new user to the repository.
+   *
+   * @param dataUser The user data to be added.
+   * @param callback callback function that receives Result.success() when operation succeed of
+   *   Result.failure(exception) if error
+   */
+  fun addUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit)
+
+  /**
+   * Function to update an existing user in the repository.
+   *
+   * @param dataUser The user data to be updated.
+   * @param callback callback function that receives Result.success() when operation succeed of
+   *   Result.failure(exception) if error
+   */
+  fun updateUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit)
+
+  /**
+   * Function to delete a user from the repository.
+   *
+   * @param uuid The unique identifier of the user to be deleted.
+   * @param callback callback function that receives Result.success() when operation succeed of
+   *   Result.failure(exception) if error
+   */
+  fun deleteUser(uuid: UUID, callback: (Result<Unit>) -> Unit)
+}
Index: app/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker b/app/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
new file mode 100644
--- /dev/null	(date 1730385753963)
+++ b/app/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker	(date 1730385753963)
@@ -0,0 +1,1 @@
+mock-maker-inline
\ No newline at end of file
Index: app/src/test/java/com/android/bookswap/model/chat/TestApplicationChat.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/model/chat/TestApplicationChat.kt b/app/src/test/java/com/android/bookswap/model/chat/TestApplicationChat.kt
new file mode 100644
--- /dev/null	(date 1730451037652)
+++ b/app/src/test/java/com/android/bookswap/model/chat/TestApplicationChat.kt	(date 1730451037652)
@@ -0,0 +1,11 @@
+package com.android.bookswap.model.chat
+
+import android.app.Application
+import androidx.appcompat.app.AppCompatDelegate
+
+class TestApplicationChat : Application() {
+  override fun onCreate() {
+    super.onCreate()
+    AppCompatDelegate.setCompatVectorFromResourcesEnabled(true)
+  }
+}
Index: app/src/test/java/com/android/bookswap/data/source/network/UserFirestoreSourceTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/source/network/UserFirestoreSourceTest.kt b/app/src/test/java/com/android/bookswap/data/source/network/UserFirestoreSourceTest.kt
new file mode 100644
--- /dev/null	(date 1731617426000)
+++ b/app/src/test/java/com/android/bookswap/data/source/network/UserFirestoreSourceTest.kt	(date 1731617426000)
@@ -0,0 +1,193 @@
+package com.android.bookswap.data.source.network
+
+import android.util.Log
+import androidx.test.core.app.ApplicationProvider
+import com.android.bookswap.data.DataUser
+import com.google.android.gms.tasks.Tasks
+import com.google.firebase.FirebaseApp
+import com.google.firebase.firestore.CollectionReference
+import com.google.firebase.firestore.DocumentReference
+import com.google.firebase.firestore.DocumentSnapshot
+import com.google.firebase.firestore.FirebaseFirestore
+import com.google.firebase.firestore.Query
+import com.google.firebase.firestore.QuerySnapshot
+import com.google.firebase.firestore.util.Assert.fail
+import java.util.UUID
+import org.junit.After
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.ArgumentMatchers
+import org.mockito.Mock
+import org.mockito.Mockito.`when`
+import org.mockito.MockitoAnnotations
+import org.mockito.kotlin.any
+import org.mockito.kotlin.doAnswer
+import org.mockito.kotlin.eq
+import org.mockito.kotlin.verify
+import org.robolectric.RobolectricTestRunner
+
+@RunWith(RobolectricTestRunner::class)
+class UserFirestoreSourceTest {
+
+  @Mock private lateinit var mockFirestore: FirebaseFirestore
+  @Mock private lateinit var mockCollectionReference: CollectionReference
+  @Mock private lateinit var mockDocumentReference: DocumentReference
+  @Mock private lateinit var mockDocumentSnapshot: DocumentSnapshot
+  @Mock private lateinit var mockQuerySnapshot: QuerySnapshot
+  @Mock private lateinit var mockQuery: Query
+
+  private lateinit var userFirestoreSource: UserFirestoreSource
+
+  private val testUser =
+      DataUser(
+          UUID.randomUUID(),
+          "M.",
+          "John",
+          "Doe",
+          "John.Doe@example.com",
+          "+41223456789",
+          0.0,
+          0.0,
+          "dummyPic.png")
+
+  @Before
+  fun setUp() {
+    MockitoAnnotations.openMocks(this)
+
+    // Initialize Firebase if necessary
+    if (FirebaseApp.getApps(ApplicationProvider.getApplicationContext()).isEmpty()) {
+      FirebaseApp.initializeApp(ApplicationProvider.getApplicationContext())
+    }
+
+    userFirestoreSource = UserFirestoreSource(mockFirestore)
+
+    `when`(mockFirestore.collection(ArgumentMatchers.any())).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(ArgumentMatchers.any()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
+
+    `when`(mockQuerySnapshot.documents).thenReturn(listOf(mockDocumentSnapshot))
+    `when`(mockDocumentSnapshot.getLong("userUUID.mostSignificantBits"))
+        .thenReturn(testUser.userUUID.mostSignificantBits)!!
+    `when`(mockDocumentSnapshot.getLong("userUUID.leastSignificantBits"))
+        .thenReturn(testUser.userUUID.leastSignificantBits)!!
+    `when`(mockDocumentSnapshot.getString("greeting")).thenReturn(testUser.greeting)
+    `when`(mockDocumentSnapshot.getString("firstName")).thenReturn(testUser.firstName)
+    `when`(mockDocumentSnapshot.getString("lastName")).thenReturn(testUser.lastName)
+    `when`(mockDocumentSnapshot.getString("email")).thenReturn(testUser.email)
+    `when`(mockDocumentSnapshot.getString("phoneNumber")).thenReturn(testUser.phoneNumber)
+    `when`(mockDocumentSnapshot.getDouble("latitude")).thenReturn(testUser.latitude)
+    `when`(mockDocumentSnapshot.getDouble("longitude")).thenReturn(testUser.longitude)
+    `when`(mockDocumentSnapshot.getString("profilePictureUrl"))
+        .thenReturn(testUser.profilePictureUrl)
+    `when`(mockDocumentSnapshot.get("bookList")).thenReturn(testUser.bookList)
+    `when`(mockDocumentSnapshot.getString("googleUid")).thenReturn(testUser.googleUid)
+  }
+
+  @After fun tearDown() {}
+
+  @Test fun init() {}
+
+  @Test
+  fun getUsers() {
+    // Act
+    userFirestoreSource.getUsers { result ->
+      result.fold(
+          {
+            // Assert proper data transfert
+            assert(it.isNotEmpty())
+            assert(it.first().printFullname() == testUser.printFullname())
+          },
+          { fail("Should not fail!") })
+    }
+
+    // Verify Firestore collection was accessed
+    verify(mockCollectionReference).get()
+  }
+
+  @Test
+  fun getUser() {
+    // Arrange
+    `when`(mockCollectionReference.whereEqualTo(eq("UUID"), ArgumentMatchers.any()))
+        .thenReturn(mockQuery)
+    `when`(mockQuery.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
+
+    // Act
+    userFirestoreSource.getUser(testUser.userUUID) { result ->
+      result.fold(
+          {
+            // Assert proper data transfer
+            assert(it.printFullname() == testUser.printFullname())
+          },
+          { fail("Should not fail!") })
+    }
+
+    // Verify Firestore collection was accessed
+    verify(mockCollectionReference).whereEqualTo(eq("UUID"), any())
+  }
+
+  @Test
+  fun addUser() {
+    // Arrange
+    doAnswer { Tasks.forResult(null) }.`when`(mockDocumentReference).set(testUser)
+
+    // Act
+    userFirestoreSource.addUser(testUser) { result ->
+      result.fold({ assert(true) }, { fail("Should not fail!") })
+    }
+
+    // Verify Firestore collection was accessed
+    verify(mockDocumentReference).set(testUser)
+  }
+
+  @Test
+  fun updateUser() {
+    // Arrange
+    doAnswer { Tasks.forResult(null) }.`when`(mockDocumentReference).set(testUser)
+
+    // Act
+    userFirestoreSource.updateUser(testUser) { result ->
+      result.fold({ assert(true) }, { fail("Should not fail!") })
+    }
+
+    // Verify Firestore collection was accessed
+    verify(mockDocumentReference).set(testUser)
+  }
+
+  @Test
+  fun deleteUser() {
+    // Arrange
+    doAnswer { Tasks.forResult(null) }.`when`(mockDocumentReference).delete()
+
+    // Act
+    userFirestoreSource.deleteUser(testUser.userUUID) { result ->
+      result.fold({ assert(true) }, { fail("Should not fail!") })
+    }
+
+    // Verify Firestore collection was accessed
+    verify(mockDocumentReference).delete()
+  }
+
+  @Test
+  fun documentToUser_validDoc() {
+    // Act
+    val result = userFirestoreSource.documentToUser(mockDocumentSnapshot)
+
+    // Assert
+    assert(result.getOrNull() != null)
+    result.onSuccess { assert(it.printFullname() == testUser.printFullname()) }
+  }
+
+  @Test
+  fun documentToUser_invalidDoc() {
+    `when`(mockDocumentSnapshot.getString("greeting")).thenReturn(null)
+
+    // Act
+    val result = userFirestoreSource.documentToUser(mockDocumentSnapshot)
+
+    // Assert
+    assert(result.getOrNull() == null)
+    result.onFailure { Log.d("UserFirestoreSourceTest", "failure with message: ${it.message}") }
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/map/FilterMapScreenTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/map/FilterMapScreenTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/map/FilterMapScreenTest.kt
new file mode 100644
--- /dev/null	(date 1730385753954)
+++ b/app/src/androidTest/java/com/android/bookswap/ui/map/FilterMapScreenTest.kt	(date 1730385753954)
@@ -0,0 +1,67 @@
+package com.android.bookswap.ui.map
+
+import androidx.compose.ui.test.assertHasClickAction
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.assertTextEquals
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.compose.ui.test.performClick
+import androidx.navigation.compose.rememberNavController
+import com.android.bookswap.model.map.BookFilter
+import com.android.bookswap.ui.navigation.NavigationActions
+import org.junit.Rule
+import org.junit.Test
+
+class FilterMapScreenTest {
+  @get:Rule val composeTestRule = createComposeRule()
+
+  @Test
+  fun hasRequiredComponentsScreen() {
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      FilterMapScreen(navigationActions, BookFilter())
+    }
+    composeTestRule.onNodeWithTag("filter_filterScreenTitle").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("filter_filterScreenTitle").assertTextEquals("Filters")
+
+    composeTestRule.onNodeWithTag("filter_applyButton").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("filter_applyButton").assertHasClickAction()
+    composeTestRule.onNodeWithTag("filter_applyButton").assertTextEquals("Apply")
+  }
+
+  @Test
+  fun testButtonBlock() {
+    composeTestRule.setContent { ButtonBlock(listOf("test"), listOf()) {} }
+    composeTestRule.onNodeWithTag("filter_buttonFilter_test").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("filter_buttonFilter_test").assertHasClickAction()
+    composeTestRule.onNodeWithTag("filter_buttonFilter_test").assertTextEquals("test")
+  }
+
+  @Test
+  fun testButtonBlockWithSelected() {
+    val selected = mutableListOf("test1")
+
+    composeTestRule.setContent {
+      ButtonBlock(listOf("test1", "test2", "test3", "test4"), selected) { newSelection ->
+        selected.clear()
+        selected.addAll(newSelection)
+      }
+    }
+
+    composeTestRule
+        .onNodeWithTag("filter_buttonFilter_test1")
+        .assertIsDisplayed()
+        .assertHasClickAction()
+        .performClick()
+
+    assert(!selected.contains("test1"))
+
+    composeTestRule
+        .onNodeWithTag("filter_buttonFilter_test2")
+        .assertIsDisplayed()
+        .assertHasClickAction()
+        .performClick()
+    assert(selected.contains("test2"))
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/books/add/ISBNAddTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/books/add/ISBNAddTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/books/add/ISBNAddTest.kt
new file mode 100644
--- /dev/null	(date 1731617426000)
+++ b/app/src/androidTest/java/com/android/bookswap/ui/books/add/ISBNAddTest.kt	(date 1731617426000)
@@ -0,0 +1,206 @@
+package com.android.bookswap.ui.books.add
+
+import android.widget.Toast
+import androidx.compose.ui.semantics.SemanticsProperties
+import androidx.compose.ui.test.assertHasClickAction
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.compose.ui.test.performClick
+import androidx.compose.ui.test.performTextClearance
+import androidx.compose.ui.test.performTextInput
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.repository.BooksRepository
+import com.android.bookswap.data.source.api.GoogleBookDataSource
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.navigation.TopLevelDestination
+import com.android.bookswap.utils.matchDataBook
+import com.kaspersky.kaspresso.testcases.api.testcase.TestCase
+import io.mockk.Runs
+import io.mockk.andThenJust
+import io.mockk.every
+import io.mockk.just
+import io.mockk.mockk
+import io.mockk.mockkConstructor
+import io.mockk.mockkStatic
+import io.mockk.verify
+import java.util.UUID
+import org.junit.Assert
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+@RunWith(AndroidJUnit4::class)
+class ISBNAddTest : TestCase() {
+  @get:Rule val composeTestRule = createComposeRule()
+  private lateinit var toastMock: Toast
+
+  @Before
+  fun init() {
+    mockkStatic(Toast::class)
+    toastMock = mockk<Toast>()
+    every { toastMock.show() } returns Unit
+    every { Toast.makeText(any(), any<String>(), any()) } returns toastMock
+  }
+
+  @Test
+  fun elementsAreDisplayed() {
+    composeTestRule.setContent {
+      val mockNavigationActions: NavigationActions = mockk()
+      val mockBooksRepository: BooksRepository = mockk()
+
+      AddISBNScreen(mockNavigationActions, mockBooksRepository)
+    }
+
+    val isbnField = composeTestRule.onNodeWithTag("isbn_field")
+    isbnField.assertIsDisplayed()
+    Assert.assertEquals(
+        "ISBN*", isbnField.fetchSemanticsNode().config[SemanticsProperties.Text][0].text)
+
+    composeTestRule.onNodeWithTag("isbn_searchButton").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("isbn_searchButton").assertHasClickAction()
+  }
+
+  @Suppress("TestFunctionName")
+  @Test
+  fun ISBNFieldWork() {
+    composeTestRule.setContent {
+      val mockNavigationActions: NavigationActions = mockk()
+      val mockBooksRepository: BooksRepository = mockk()
+      AddISBNScreen(mockNavigationActions, mockBooksRepository)
+    }
+    val isbnField = composeTestRule.onNodeWithTag("isbn_field")
+
+    isbnField.performTextInput("testEmpty")
+    Assert.assertEquals(
+        "", isbnField.fetchSemanticsNode().config[SemanticsProperties.EditableText].text)
+
+    isbnField.performTextClearance()
+    isbnField.performTextInput("12845")
+    Assert.assertEquals(
+        "12845", isbnField.fetchSemanticsNode().config[SemanticsProperties.EditableText].text)
+  }
+
+  @Suppress("TestFunctionName")
+  @Test
+  fun ISBNRequestSucceeded() {
+    val dataBook =
+        DataBook(
+            uuid = UUID.randomUUID(),
+            title = "Flowers for Algernon",
+            author = null,
+            description = null,
+            rating = null,
+            photo = null,
+            language = BookLanguages.OTHER,
+            isbn = "9780435123437")
+
+    // Mock call to api
+    mockkConstructor(GoogleBookDataSource::class)
+    every { anyConstructed<GoogleBookDataSource>().getBookFromISBN(dataBook.isbn!!, any()) } answers
+        {
+          secondArg<(Result<DataBook>) -> Unit>()(Result.success(dataBook))
+        } andThenJust
+        Runs
+
+    // Mock call to repository
+    val mockBooksRepository: BooksRepository = mockk()
+    every { mockBooksRepository.addBook(matchDataBook(dataBook), any()) } answers
+        {
+          secondArg<(Result<Unit>) -> Unit>()(Result.success(Unit))
+        } andThenJust
+        Runs
+
+    // Mock the navigation
+    val mockNavigationActions: NavigationActions = mockk()
+    every { mockNavigationActions.navigateTo(any(TopLevelDestination::class)) } just Runs
+
+    composeTestRule.setContent { AddISBNScreen(mockNavigationActions, mockBooksRepository) }
+
+    composeTestRule.onNodeWithTag("isbn_field").performTextInput(dataBook.isbn!!)
+    composeTestRule.onNodeWithTag("isbn_searchButton").performClick()
+
+    verify {
+      anyConstructed<GoogleBookDataSource>().getBookFromISBN(dataBook.isbn!!, any())
+    } // Api is called
+    verify { mockBooksRepository.addBook(matchDataBook(dataBook), any()) } // Book is added
+    verify {
+      mockNavigationActions.navigateTo(any(TopLevelDestination::class))
+    } // Navigation is called when book is added
+  }
+
+  @Suppress("TestFunctionName")
+  @Test
+  fun ISBNAPIRequestFailed() {
+    // Mock bad call to api
+    mockkConstructor(GoogleBookDataSource::class)
+    every { anyConstructed<GoogleBookDataSource>().getBookFromISBN(any(), any()) } answers
+        {
+          secondArg<(Result<DataBook>) -> Unit>()(Result.failure(IllegalArgumentException()))
+        } andThenJust
+        Runs
+
+    // Mock the navigation
+    val mockNavigationActions: NavigationActions = mockk()
+    // Mock call to repository
+    val mockBooksRepository: BooksRepository = mockk()
+
+    composeTestRule.setContent { AddISBNScreen(mockNavigationActions, mockBooksRepository) }
+
+    composeTestRule.onNodeWithTag("isbn_field").performTextInput("BAD_ISBN")
+    composeTestRule.onNodeWithTag("isbn_searchButton").performClick()
+
+    verify { anyConstructed<GoogleBookDataSource>().getBookFromISBN(any(), any()) } // Api is called
+    verify { toastMock.show() }
+  }
+
+  @Suppress("TestFunctionName")
+  @Test
+  fun ISBNRepositoryCallFailed() {
+    val dataBook =
+        DataBook(
+            uuid = UUID.randomUUID(),
+            title = "Flowers for Algernon",
+            author = null,
+            description = null,
+            rating = null,
+            photo = null,
+            language = BookLanguages.OTHER,
+            isbn = "9780435123437")
+
+    // Mock call to api
+    mockkConstructor(GoogleBookDataSource::class)
+    every { anyConstructed<GoogleBookDataSource>().getBookFromISBN(dataBook.isbn!!, any()) } answers
+        {
+          secondArg<(Result<DataBook>) -> Unit>()(Result.success(dataBook))
+        } andThenJust
+        Runs
+
+    // Mock failed call to repository
+    val mockBooksRepository: BooksRepository = mockk()
+    every { mockBooksRepository.addBook(matchDataBook(dataBook), any()) } answers
+        {
+          secondArg<(Result<Unit>) -> Unit>()(Result.failure(Exception("Error message")))
+        } andThenJust
+        Runs
+
+    // Mock the navigation
+    val mockNavigationActions: NavigationActions = mockk()
+
+    composeTestRule.setContent { AddISBNScreen(mockNavigationActions, mockBooksRepository) }
+
+    composeTestRule.onNodeWithTag("isbn_field").performTextInput(dataBook.isbn!!)
+    composeTestRule.onNodeWithTag("isbn_searchButton").performClick()
+
+    verify {
+      anyConstructed<GoogleBookDataSource>().getBookFromISBN(dataBook.isbn!!, any())
+    } // Api is called
+    verify {
+      mockBooksRepository.addBook(matchDataBook(dataBook), any())
+    } // Book repository is called
+    verify { toastMock.show() } // Error is displayed
+  }
+}
Index: app/src/main/java/com/android/bookswap/ui/books/BookProfile.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/books/BookProfile.kt b/app/src/main/java/com/android/bookswap/ui/books/BookProfile.kt
new file mode 100644
--- /dev/null	(date 1731617426000)
+++ b/app/src/main/java/com/android/bookswap/ui/books/BookProfile.kt	(date 1731617426000)
@@ -0,0 +1,204 @@
+package com.android.bookswap.ui.books
+
+import androidx.compose.foundation.Image
+import androidx.compose.foundation.background
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.automirrored.filled.ArrowBack
+import androidx.compose.material.icons.automirrored.filled.ArrowForward
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.Icon
+import androidx.compose.material3.IconButton
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.Text
+import androidx.compose.material3.VerticalDivider
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableIntStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.setValue
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.platform.LocalConfiguration
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.res.painterResource
+import androidx.compose.ui.text.style.TextAlign
+import androidx.compose.ui.unit.dp
+import com.android.bookswap.R
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.ui.theme.ColorVariable
+
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun BookProfileScreen(
+    DataBook: DataBook,
+    topAppBar: @Composable () -> Unit = {},
+    bottomAppBar: @Composable () -> Unit = {},
+) {
+  val columnPadding = 8.dp
+  val pictureWidth = (LocalConfiguration.current.screenWidthDp.dp * (0.60f))
+  val pictureHeight = pictureWidth * 1.41f
+  val buttonsHeight = pictureHeight / 12.0f
+  val images = listOf(R.drawable.isabellacatolica, R.drawable.felipeii)
+  val imagesDescription = listOf("Isabel La Catolica", "Felipe II")
+  var currentImageIndex by remember { mutableIntStateOf(0) }
+  Scaffold(
+      modifier = Modifier.testTag("bookProfileScreen"),
+      topBar = topAppBar,
+      bottomBar = bottomAppBar) { innerPadding ->
+        LazyColumn(
+            modifier =
+                Modifier.fillMaxSize()
+                    .padding(innerPadding)
+                    .background(ColorVariable.BackGround)
+                    .testTag("bookProfileScroll"),
+            verticalArrangement = Arrangement.spacedBy(columnPadding),
+            horizontalAlignment = Alignment.CenterHorizontally) {
+              item {
+                Text(
+                    text = DataBook.title,
+                    modifier = Modifier.testTag("bookTitle").padding(columnPadding),
+                    color = ColorVariable.Accent,
+                    style = MaterialTheme.typography.titleLarge)
+              }
+              item {
+                Text(
+                    text = DataBook.author ?: "Author Unknown",
+                    modifier = Modifier.testTag("bookAuthor"),
+                    color = ColorVariable.AccentSecondary,
+                    style = MaterialTheme.typography.titleMedium)
+              }
+              item { Spacer(modifier = Modifier.height(columnPadding)) }
+              item {
+                Box(
+                    modifier =
+                        Modifier.size(pictureWidth, pictureHeight)
+                            .background(ColorVariable.BackGround)) {
+                      Image(
+                          painter = painterResource(id = images[currentImageIndex]),
+                          contentDescription = imagesDescription[currentImageIndex],
+                          modifier =
+                              Modifier.height(pictureHeight)
+                                  .fillMaxWidth()
+                                  .testTag(
+                                      "bookProfileImage ${imagesDescription[currentImageIndex]}"))
+                    }
+              }
+              item {
+                Row(
+                    modifier = Modifier.fillMaxWidth().padding(horizontal = 16.dp),
+                    verticalAlignment = Alignment.CenterVertically,
+                    horizontalArrangement = Arrangement.SpaceBetween) {
+                      IconButton(
+                          onClick = {
+                            currentImageIndex = (currentImageIndex - 1 + images.size) % images.size
+                          },
+                          modifier =
+                              Modifier.height(buttonsHeight).testTag("bookProfileImageLeft")) {
+                            Icon(
+                                imageVector = Icons.AutoMirrored.Filled.ArrowBack,
+                                contentDescription = "Previous Image",
+                                tint = ColorVariable.Accent)
+                          }
+                      Text(
+                          text = imagesDescription[currentImageIndex],
+                          color = ColorVariable.AccentSecondary,
+                          modifier = Modifier.padding(horizontal = 8.dp))
+                      IconButton(
+                          onClick = { currentImageIndex = (currentImageIndex + 1) % images.size },
+                          modifier =
+                              Modifier.height(buttonsHeight).testTag("bookProfileImageRight")) {
+                            Icon(
+                                imageVector = Icons.AutoMirrored.Filled.ArrowForward,
+                                contentDescription = "Next Image",
+                                tint = ColorVariable.Accent)
+                          }
+                    }
+              }
+              item { Spacer(modifier = Modifier.height(columnPadding)) }
+              item {
+                DataBook.rating?.let {
+                  Text(
+                      text = "Rating: $it/10",
+                      color = ColorVariable.Accent,
+                      style = MaterialTheme.typography.bodyMedium,
+                      modifier = Modifier.padding(vertical = 8.dp).testTag("bookProfileRating"))
+                }
+              }
+              item { Spacer(modifier = Modifier.height(columnPadding)) }
+              item {
+                Text(
+                    text = "Synopsis",
+                    color = ColorVariable.Accent,
+                    style = MaterialTheme.typography.titleSmall,
+                    modifier =
+                        Modifier.padding(vertical = 8.dp).testTag("bookProfileSynopsisTitle"))
+              }
+              item {
+                Text(
+                    text = DataBook.description ?: "No description available",
+                    color = ColorVariable.Accent,
+                    style = MaterialTheme.typography.bodyMedium,
+                    modifier = Modifier.padding(vertical = 8.dp).testTag("bookProfileSynopsis"),
+                    textAlign = TextAlign.Center)
+              }
+              item { Spacer(modifier = Modifier.height(columnPadding)) }
+              item {
+                Row(modifier = Modifier.fillMaxWidth().padding(horizontal = 16.dp)) {
+                  Column(modifier = Modifier.weight(1f)) {
+                    ProfileText(
+                        text = "Language: ${DataBook.language.languageCode}",
+                        testTag = "bookProfileLanguage")
+                    ProfileText(text = "Genres:", testTag = "bookProfileGenresTitle")
+                    DataBook.genres.forEach { genre ->
+                      Text(
+                          text = "- ${genre.Genre}",
+                          color = ColorVariable.AccentSecondary,
+                          style = MaterialTheme.typography.bodyMedium,
+                          modifier =
+                              Modifier.padding(top = 2.dp, start = 16.dp)
+                                  .testTag("bookProfileGenre${genre.Genre}"))
+                    }
+                    ProfileText(
+                        text = "ISBN: ${DataBook.isbn ?: "ISBN doesn't exist or is not available"}",
+                        testTag = "bookProfileISBN")
+                  }
+
+                  VerticalDivider(color = ColorVariable.Accent, thickness = 1.dp)
+
+                  Column(modifier = Modifier.weight(1f)) {
+                    ProfileText(
+                        text = "Date of Publication: [Temporary Date]", testTag = "bookProfileDate")
+                    ProfileText(text = "Volume: [Temporary Volume]", testTag = "bookProfileVolume")
+                    ProfileText(text = "Issue: [Temporary Issue]", testTag = "bookProfileIssue")
+                    ProfileText(
+                        text = "Editorial: [Temporary Editorial]", testTag = "bookProfileEditorial")
+                    ProfileText(
+                        text = "Place of Edition: [Temporary Place]",
+                        testTag = "bookProfileEditionPlace")
+                  }
+                }
+              }
+            }
+      }
+}
+
+@Composable
+fun ProfileText(text: String, testTag: String) {
+  Text(
+      text = text,
+      color = ColorVariable.Accent,
+      style = MaterialTheme.typography.bodyMedium,
+      modifier = Modifier.padding(vertical = 8.dp).testTag(testTag))
+}
Index: app/src/main/java/com/android/bookswap/model/userViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/userViewModel.kt b/app/src/main/java/com/android/bookswap/model/userViewModel.kt
new file mode 100644
--- /dev/null	(date 1731634508318)
+++ b/app/src/main/java/com/android/bookswap/model/userViewModel.kt	(date 1731634508318)
@@ -0,0 +1,135 @@
+package com.android.bookswap.model
+
+
+import android.util.Log
+import androidx.lifecycle.ViewModel
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.repository.UsersRepository
+import com.android.bookswap.data.source.network.BooksFirestoreSource
+import com.android.bookswap.data.source.network.UserFirestoreSource
+import com.google.firebase.firestore.FirebaseFirestore
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
+import java.util.UUID
+
+/**
+ * ViewModel for the user data of the application.
+ *
+ * @param uuid UUID of the user
+ * @param repository Repository to fetch user data
+ */
+open class UserViewModel(
+    var uuid: UUID,
+   firebase: FirebaseFirestore,
+
+) : ViewModel() {
+    private var dataUser = DataUser(uuid)
+    private var isLoaded = false
+    private val _isStored = MutableStateFlow<Boolean?>(null)
+    val isStored: StateFlow<Boolean?> = _isStored
+    private val userRepository: UsersRepository = UserFirestoreSource(firebase)
+    private val booksFirestoreSource: BooksFirestoreSource = BooksFirestoreSource(firebase)
+    open fun getUser(force: Boolean = false): DataUser {
+        if (!isLoaded || force) {
+            fetchUser()
+        }
+        return dataUser
+    }
+
+    private fun fetchUser() {
+        userRepository.getUser(uuid) { result ->
+            result.onSuccess {
+                dataUser = it
+                isLoaded = true
+                _isStored.value = true
+            }
+        }
+    }
+
+    /**
+     * Update the user data with the given parameters. If no parameter is given, the data will not be
+     * updated.
+     */
+    fun updateUser(
+        greeting: String = dataUser.greeting,
+        firstName: String = dataUser.firstName,
+        lastName: String = dataUser.lastName,
+        email: String = dataUser.email,
+        phone: String = dataUser.phoneNumber,
+        latitude: Double = dataUser.latitude,
+        longitude: Double = dataUser.longitude,
+        picURL: String = dataUser.profilePictureUrl,
+        bookList: List<UUID> = dataUser.bookList,
+        googleUid: String = dataUser.googleUid
+    ) {
+        updateUser(
+            DataUser(
+                uuid,
+                greeting,
+                firstName,
+                lastName,
+                email,
+                phone,
+                latitude,
+                longitude,
+                picURL,
+                bookList,
+                googleUid
+            )
+        )
+    }
+
+    /**
+     * Update the user data with the given DataUser object.
+     *
+     * @param newDataUser New user data
+     */
+    fun updateUser(newDataUser: DataUser) {
+        this.dataUser = newDataUser
+        this.uuid = newDataUser.userUUID
+        isLoaded = true
+        userRepository.updateUser(dataUser) { result ->
+            result.fold({ _isStored.value = true }, { _isStored.value = false })
+        }
+    }
+
+    /*
+   * Get the user by the googleUid
+   */
+    fun getUserByGoogleUid(googleUid: String) {
+        userRepository.getUser(googleUid) { result ->
+            // If the user is found, update the dataUser and set isLoaded to true
+            result.onSuccess {
+                dataUser = it
+                isLoaded = true
+                _isStored.value = true
+                Log.e(
+                    "UserViewModel",
+                    "User found {${dataUser.firstName}}{${dataUser.lastName}}{${dataUser.userUUID}}"
+                )
+            }
+            // If the user is not found, set isLoaded to false
+            result.onFailure {
+                Log.e("UserViewModel", "User not found")
+                isLoaded = false
+                _isStored.value = false
+            }
+        }
+    }
+
+    /**
+     * Update the googleUid of the user.
+     *
+     * @param googleUid New googleUid
+     */
+    fun updateGoogleUid(googleUid: String) {
+        dataUser.googleUid = googleUid
+        updateUser(dataUser)
+    }
+
+
+    fun getBookList(bookList: List<UUID>): List<DataBook> {
+        return booksFirestoreSource.getBooksList(bookList){it}
+    }
+}
Index: app/src/main/java/com/android/bookswap/data/DataUser.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/DataUser.kt b/app/src/main/java/com/android/bookswap/data/DataUser.kt
new file mode 100644
--- /dev/null	(date 1731615667844)
+++ b/app/src/main/java/com/android/bookswap/data/DataUser.kt	(date 1731615667844)
@@ -0,0 +1,22 @@
+package com.android.bookswap.data
+
+import java.util.UUID
+
+data class DataUser(
+    var userUUID: UUID = UUID.randomUUID(),
+    var greeting: String = "",
+    var firstName: String = "",
+    var lastName: String = "",
+    var email: String = "",
+    var phoneNumber: String = "",
+    var latitude: Double = 0.0,
+    var longitude: Double = 0.0,
+    var profilePictureUrl: String = "",
+    var bookList: List<UUID> = emptyList(),
+    var googleUid: String = ""
+) {
+
+  fun printFullname(): String {
+    return "$greeting $firstName $lastName"
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/screen/UserProfileScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/screen/UserProfileScreen.kt b/app/src/androidTest/java/com/android/bookswap/screen/UserProfileScreen.kt
new file mode 100644
--- /dev/null	(date 1731615667837)
+++ b/app/src/androidTest/java/com/android/bookswap/screen/UserProfileScreen.kt	(date 1731615667837)
@@ -0,0 +1,19 @@
+package com.android.bookswap.screen
+
+import androidx.compose.ui.test.SemanticsNodeInteractionsProvider
+import androidx.compose.ui.test.hasTestTag
+import io.github.kakaocup.compose.node.element.ComposeScreen
+import io.github.kakaocup.compose.node.element.KNode
+
+class UserProfileScreen(semanticsProvider: SemanticsNodeInteractionsProvider) :
+    ComposeScreen<UserProfileScreen>(
+        semanticsProvider = semanticsProvider,
+        viewBuilderAction = { hasTestTag("profileScreenContainer") }) {
+
+  val titleTxt: KNode = child { hasTestTag("TopAppBar_Title") }
+  val fullNameTxt: KNode = child { hasTestTag("fullNameTxt") }
+  val emailTxt: KNode = child { hasTestTag("emailTxt") }
+  val phoneNumberTxt: KNode = child { hasTestTag("phoneNumberTxt") }
+  val addressTxt: KNode = child { hasTestTag("addressTxt") }
+  val editProfileBtn: KNode = child { hasTestTag("editProfileBtn") }
+}
Index: app/src/androidTest/java/com/android/bookswap/utils/Books.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/utils/Books.kt b/app/src/androidTest/java/com/android/bookswap/utils/Books.kt
new file mode 100644
--- /dev/null	(date 1730385753955)
+++ b/app/src/androidTest/java/com/android/bookswap/utils/Books.kt	(date 1730385753955)
@@ -0,0 +1,17 @@
+package com.android.bookswap.utils
+
+import com.android.bookswap.data.DataBook
+import io.mockk.Matcher
+import io.mockk.MockKMatcherScope
+
+data class DataBookMatcher(val expectedBook: DataBook, val idEq: Boolean) : Matcher<DataBook> {
+
+  override fun match(arg: DataBook?): Boolean {
+    return if (idEq) expectedBook == arg else expectedBook == arg?.copy(uuid = expectedBook.uuid)
+  }
+
+  override fun toString() = "matchBook(book=$expectedBook, idEq=$idEq)"
+}
+
+fun MockKMatcherScope.matchDataBook(dataBook: DataBook, idEq: Boolean = false): DataBook =
+    match(DataBookMatcher(dataBook, idEq))
Index: app/src/androidTest/java/com/android/bookswap/endtoend/NavigationBarEndToEnd.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/endtoend/NavigationBarEndToEnd.kt b/app/src/androidTest/java/com/android/bookswap/endtoend/NavigationBarEndToEnd.kt
new file mode 100644
--- /dev/null	(date 1731617426000)
+++ b/app/src/androidTest/java/com/android/bookswap/endtoend/NavigationBarEndToEnd.kt	(date 1731617426000)
@@ -0,0 +1,56 @@
+package com.android.bookswap.endtoend
+
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.compose.ui.test.performClick
+import com.android.bookswap.MainActivity
+import com.android.bookswap.data.repository.BooksRepository
+import com.android.bookswap.data.repository.UsersRepository
+import com.android.bookswap.data.source.network.MessageFirestoreSource
+import com.android.bookswap.ui.navigation.Route
+import com.google.firebase.firestore.FirebaseFirestore
+import io.mockk.every
+import io.mockk.just
+import io.mockk.mockk
+import io.mockk.runs
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+class NavigationBarEndToEnd {
+  @get:Rule val composeTestRule = createComposeRule()
+
+  private lateinit var mockBookRepository: BooksRepository
+  private lateinit var mockUserRepository: UsersRepository
+
+  @Before
+  fun setUp() {
+    mockBookRepository = mockk()
+    every { mockBookRepository.getBook(any()) } just runs
+    mockUserRepository = mockk()
+    every { mockUserRepository.getUsers(any()) } just runs
+
+    composeTestRule.setContent {
+      val db = FirebaseFirestore.getInstance()
+
+      val messageRepository = MessageFirestoreSource(db)
+      MainActivity()
+          .BookSwapApp(messageRepository, mockBookRepository, mockUserRepository, Route.MAP)
+    }
+  }
+
+  @Test
+  fun testNavigationBar() {
+    // Click on the Add Book tab and check if the AddToBookScreen is displayed
+    composeTestRule.onNodeWithTag("New Book").assertExists().performClick()
+    composeTestRule.onNodeWithTag("addBookChoiceScreen").assertExists()
+
+    // Click on the Chat tab and check if the ListChatScreen is displayed
+    composeTestRule.onNodeWithTag("Chat").assertExists().performClick()
+    composeTestRule.onNodeWithTag("chat_listScreen").assertExists()
+
+    // Click on the Map tab and check if the MapScreen is displayed
+    composeTestRule.onNodeWithTag("Map").assertExists().performClick()
+    composeTestRule.onNodeWithTag("mapScreen").assertExists()
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/screen/EditProfileScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/screen/EditProfileScreen.kt b/app/src/androidTest/java/com/android/bookswap/screen/EditProfileScreen.kt
new file mode 100644
--- /dev/null	(date 1730385753953)
+++ b/app/src/androidTest/java/com/android/bookswap/screen/EditProfileScreen.kt	(date 1730385753953)
@@ -0,0 +1,19 @@
+package com.android.bookswap.screen
+
+import androidx.compose.ui.test.SemanticsNodeInteractionsProvider
+import io.github.kakaocup.compose.node.element.ComposeScreen
+import io.github.kakaocup.compose.node.element.KNode
+
+class EditProfileScreen(semanticsProvider: SemanticsNodeInteractionsProvider) :
+    ComposeScreen<EditProfileScreen>(
+        semanticsProvider = semanticsProvider,
+        viewBuilderAction = { hasTestTag("editProfileContainer") }) {
+  val titleTxt: KNode = child { hasTestTag("editProfileTitleTxt") }
+  val greetingTbx: KNode = child { hasTestTag("greetingTbx") }
+  val firstnameTbx: KNode = child { hasTestTag("firstnameTbx") }
+  val lastnameTbx: KNode = child { hasTestTag("lastnameTbx") }
+  val emailTbx: KNode = child { hasTestTag("emailTbx") }
+  val phoneNumberTbx: KNode = child { hasTestTag("phoneTbx") }
+  val confirmBtn: KNode = child { hasTestTag("confirmBtn") }
+  val dismissBtn: KNode = child { hasTestTag("dismissBtn") }
+}
Index: app/src/test/java/com/android/bookswap/data/DataUserTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/DataUserTest.kt b/app/src/test/java/com/android/bookswap/data/DataUserTest.kt
new file mode 100644
--- /dev/null	(date 1731617442000)
+++ b/app/src/test/java/com/android/bookswap/data/DataUserTest.kt	(date 1731617442000)
@@ -0,0 +1,113 @@
+package com.android.bookswap.data
+
+import com.android.bookswap.data.repository.UsersRepository
+import com.android.bookswap.model.UserViewModel
+import io.mockk.every
+import io.mockk.mockk
+import java.util.UUID
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertNotNull
+import org.junit.Assert.assertTrue
+import org.junit.Test
+
+class DataUserTest {
+
+  private val mockUsersRepo: UsersRepository = mockk()
+
+  private val standardUser =
+      DataUser(
+          userUUID = UUID.randomUUID(),
+          greeting = "M.",
+          firstName = "John",
+          lastName = "Doe",
+          email = "john.doe@example.com",
+          phoneNumber = "+41223456789",
+          latitude = 1.0,
+          longitude = 7.0,
+          profilePictureUrl = "dummyPic.png",
+          bookList = listOf(UUID(1000, 2000)),
+          googleUid = "googleUid")
+
+  @Test
+  fun checkAssign() {
+    assertNotNull(standardUser.userUUID)
+    assertEquals("M.", standardUser.greeting)
+    assertEquals("John", standardUser.firstName)
+    assertEquals("Doe", standardUser.lastName)
+    assertEquals("john.doe@example.com", standardUser.email)
+    assertEquals("+41223456789", standardUser.phoneNumber)
+    assertEquals(1.0, standardUser.latitude, 0.000001)
+    assertEquals(7.0, standardUser.longitude, 0.000001)
+    assertEquals("dummyPic.png", standardUser.profilePictureUrl)
+    assertEquals(listOf(UUID(1000, 2000)), standardUser.bookList)
+    assertEquals("googleUid", standardUser.googleUid)
+  }
+  /**
+   * @Test fun viewModelFetch() { val userVM = UserViewModel(standardUser.userUUID, mockUsersRepo)
+   *   assertTrue(!userVM.isStored.value!!)
+   *
+   * every { mockUsersRepo.getUser(standardUser.userUUID, any()) } answers {
+   * secondArg<(Result<DataUser>) -> Unit>()(Result.success(standardUser)) } andThenJust Runs
+   *
+   * val result = userVM.getUser()
+   *
+   * assertEquals(standardUser, result) assertTrue(userVM.isStored.value!!)
+   *
+   * // Verify that second calls does not fetch again userVM.getUser() verify(exactly = 1) {
+   * mockUsersRepo.getUser(uuid = any(), any()) } }
+   */
+  @Test
+  fun viewModelUpdateCorrectly() {
+    val updatedUser =
+        standardUser.copy(
+            greeting = "Mme.",
+            firstName = "Alice",
+            email = "alice.doe@example.com",
+            longitude = 5.0,
+            latitude = 3.2,
+            phoneNumber = "+4122346666",
+            profilePictureUrl = "zzz",
+            bookList = listOf(UUID(10, 5)),
+            googleUid = "googleUid")
+
+    every { mockUsersRepo.updateUser(any(), any()) } answers
+        {
+          secondArg<(Result<Unit>) -> Unit>()(Result.success(Unit))
+        }
+
+    val userVM = UserViewModel(standardUser.userUUID, mockUsersRepo)
+    userVM.updateUser(
+        updatedUser.greeting,
+        updatedUser.firstName,
+        updatedUser.lastName,
+        updatedUser.email,
+        updatedUser.phoneNumber,
+        updatedUser.latitude,
+        updatedUser.longitude,
+        updatedUser.profilePictureUrl,
+        updatedUser.bookList,
+        updatedUser.googleUid)
+
+    assertTrue(userVM.isStored.value!!)
+
+    // Verify it fails correctly
+    every { mockUsersRepo.updateUser(any(), any()) } answers
+        {
+          secondArg<(Result<Unit>) -> Unit>()(Result.failure(Exception()))
+        }
+
+    userVM.updateUser(
+        updatedUser.greeting,
+        updatedUser.firstName,
+        updatedUser.lastName,
+        updatedUser.email,
+        updatedUser.phoneNumber,
+        updatedUser.latitude,
+        updatedUser.longitude,
+        updatedUser.profilePictureUrl,
+        updatedUser.bookList,
+        updatedUser.googleUid)
+
+    assertTrue(!userVM.isStored.value!!)
+  }
+}
Index: app/src/test/java/com/android/bookswap/model/map/BookFilterTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/model/map/BookFilterTest.kt b/app/src/test/java/com/android/bookswap/model/map/BookFilterTest.kt
new file mode 100644
--- /dev/null	(date 1730385753963)
+++ b/app/src/test/java/com/android/bookswap/model/map/BookFilterTest.kt	(date 1730385753963)
@@ -0,0 +1,80 @@
+package com.android.bookswap.model.map
+
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import java.util.UUID
+import junit.framework.TestCase.assertEquals
+import org.junit.Before
+import org.junit.Test
+
+class BookFilterTest {
+  private val bookFilter = BookFilter()
+  private val bookList =
+      listOf(
+          DataBook(
+              uuid = UUID.randomUUID(),
+              title = "Book 1",
+              author = "Author 1",
+              description = "Description of Book 1",
+              rating = 5,
+              photo = null,
+              language = BookLanguages.ENGLISH,
+              isbn = null,
+              genres = listOf(BookGenres.FANTASY)),
+          DataBook(
+              uuid = UUID.randomUUID(),
+              title = "Book 2",
+              author = "Author 2",
+              description = "Description of Book 2",
+              rating = 4,
+              photo = null,
+              language = BookLanguages.FRENCH,
+              isbn = null,
+              genres = listOf(BookGenres.FICTION)),
+          DataBook(
+              uuid = UUID.randomUUID(),
+              title = "Book 3",
+              author = "Author 3",
+              description = "Description of Book 3",
+              rating = null,
+              photo = null,
+              language = BookLanguages.GERMAN,
+              isbn = null,
+              genres = listOf(BookGenres.SCIENCEFICTION, BookGenres.AUTOBIOGRAPHY)),
+      )
+
+  @Before fun setUp() {}
+
+  @Test
+  fun `empty filter should return all books`() {
+    val filteredBooks = bookFilter.filterBooks(bookList)
+    assertEquals(bookList, filteredBooks)
+  }
+
+  @Test
+  fun `filter by genre should return matching books`() {
+    bookFilter.setGenres(listOf("Fiction"))
+    val filteredBooks = bookFilter.filterBooks(bookList)
+    assertEquals(listOf(bookList[1]), filteredBooks)
+
+    bookFilter.setGenres(listOf("Fantasy", "Science-Fiction"))
+    val filteredBooks2 = bookFilter.filterBooks(bookList)
+    assertEquals(listOf(bookList[0], bookList[2]), filteredBooks2)
+  }
+
+  @Test
+  fun `filter by language should return matching books`() {
+    bookFilter.setLanguages(listOf("French"))
+    val filteredBooks = bookFilter.filterBooks(bookList)
+    assertEquals(listOf(bookList[1]), filteredBooks)
+  }
+
+  @Test
+  fun `filter by genre and language should return matching books`() {
+    bookFilter.setGenres(listOf("Science-Fiction"))
+    bookFilter.setLanguages(listOf("German"))
+    val filteredBooks = bookFilter.filterBooks(bookList)
+    assertEquals(listOf(bookList[2]), filteredBooks)
+  }
+}
Index: app/src/main/java/com/android/bookswap/ui/components/ButtonComponent.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/components/ButtonComponent.kt b/app/src/main/java/com/android/bookswap/ui/components/ButtonComponent.kt
new file mode 100644
--- /dev/null	(date 1731617442000)
+++ b/app/src/main/java/com/android/bookswap/ui/components/ButtonComponent.kt	(date 1731617442000)
@@ -0,0 +1,126 @@
+package com.android.bookswap.ui.components
+
+import androidx.compose.foundation.BorderStroke
+import androidx.compose.foundation.interaction.MutableInteractionSource
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.PaddingValues
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.RowScope
+import androidx.compose.foundation.layout.defaultMinSize
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.shape.CircleShape
+import androidx.compose.material3.ButtonDefaults
+import androidx.compose.material3.LocalContentColor
+import androidx.compose.material3.LocalTextStyle
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.Surface
+import androidx.compose.material3.minimumInteractiveComponentSize
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.CompositionLocalProvider
+import androidx.compose.runtime.remember
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.draw.clip
+import androidx.compose.ui.semantics.Role
+import androidx.compose.ui.semantics.role
+import androidx.compose.ui.semantics.semantics
+import androidx.compose.ui.unit.dp
+
+private val BUTTON_CONTENT_PADDING = 8.dp
+
+@Composable
+fun ButtonComponent(
+    onClick: () -> Unit,
+    modifier: Modifier = Modifier,
+    enabled: Boolean = true,
+    border: BorderStroke? = ButtonDefaults.outlinedButtonBorder,
+    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
+    content: @Composable() (RowScope.() -> Unit)
+) {
+  val colors = ButtonDefaults.outlinedButtonColors()
+  val contentPadding = PaddingValues(BUTTON_CONTENT_PADDING)
+  val shape = CircleShape
+  val containerColor =
+      if (enabled) {
+        MaterialTheme.colorScheme.primary
+      } else {
+        colors.disabledContainerColor
+      }
+  val contentColor =
+      if (enabled) {
+        MaterialTheme.colorScheme.onPrimary
+      } else {
+        colors.disabledContentColor
+      }
+
+  Surface(
+      onClick = onClick,
+      modifier =
+          modifier.minimumInteractiveComponentSize().clip(shape).semantics { role = Role.Button },
+      enabled = enabled,
+      shape = shape,
+      color = containerColor,
+      contentColor = contentColor,
+      border = border,
+      interactionSource = interactionSource) {
+        val mergedStyle = LocalTextStyle.current.merge(MaterialTheme.typography.labelLarge)
+        CompositionLocalProvider(
+            LocalContentColor provides contentColor, LocalTextStyle provides mergedStyle) {
+              Row(
+                  Modifier.defaultMinSize(
+                          minWidth = ButtonDefaults.MinWidth, minHeight = ButtonDefaults.MinHeight)
+                      .padding(contentPadding),
+                  horizontalArrangement = Arrangement.Center,
+                  verticalAlignment = Alignment.CenterVertically,
+                  content = content)
+            }
+      }
+}
+
+/*
+@Preview(uiMode = Configuration.UI_MODE_NIGHT_NO, showBackground = true, name = "LightMode")
+@Preview(uiMode = Configuration.UI_MODE_NIGHT_YES, showBackground = true, name = "DarkMode")
+@Composable
+fun ButtonComponentPreview() {
+  val text = "Button"
+  BookSwapAppTheme {
+    Column(verticalArrangement = Arrangement.spacedBy(1.dp)) {
+      ButtonComponent({}) { Text(text) }
+      TextButton(
+          onClick = { /*TODO*/},
+          modifier = Modifier.padding(0.5.dp),
+          border = ButtonDefaults.outlinedButtonBorder) {
+            Text(text)
+          }
+      ButtonComponent(onClick = { /*TODO*/}, border = null) {
+        Icon(
+            imageVector = Icons.AutoMirrored.Filled.ArrowBack,
+            // tint = MaterialTheme.colorScheme.secondary,
+            contentDescription = "Back",
+            modifier = Modifier.testTag("backIcon").size(32.dp))
+      }
+      IconButtonComponent(onClick = { /*TODO*/}, tint = MaterialTheme.colorScheme.outline) {
+        Icon(
+            imageVector = Icons.AutoMirrored.Filled.ArrowBack,
+            // tint = MaterialTheme.colorScheme.secondary,
+            contentDescription = "Back",
+            modifier = Modifier.testTag("backIcon").size(32.dp))
+      }
+      IconButton(onClick = { /*TODO*/}) {
+        Icon(
+            imageVector = Icons.AutoMirrored.Filled.ArrowBack,
+            // tint = MaterialTheme.colorScheme.secondary,
+            contentDescription = "Back",
+            modifier = Modifier.testTag("backIcon").size(32.dp))
+      }
+      TextButton(onClick = { /*TODO*/}) {
+        Icon(
+            imageVector = Icons.AutoMirrored.Filled.ArrowBack,
+            // tint = MaterialTheme.colorScheme.secondary,
+            contentDescription = "Back",
+            modifier = Modifier.testTag("backIcon").size(32.dp))
+      }
+    }
+  }
+}
+*/
Index: app/src/main/java/com/android/bookswap/ui/books/add/BookAdditionChoiceScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/books/add/BookAdditionChoiceScreen.kt b/app/src/main/java/com/android/bookswap/ui/books/add/BookAdditionChoiceScreen.kt
new file mode 100644
--- /dev/null	(date 1731615667000)
+++ b/app/src/main/java/com/android/bookswap/ui/books/add/BookAdditionChoiceScreen.kt	(date 1731615667000)
@@ -0,0 +1,127 @@
+package com.android.bookswap.ui.books.add
+
+import androidx.compose.foundation.BorderStroke
+import androidx.compose.foundation.Image
+import androidx.compose.foundation.background
+import androidx.compose.foundation.layout.*
+import androidx.compose.foundation.shape.RoundedCornerShape
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.automirrored.filled.ArrowForward
+import androidx.compose.material.icons.filled.Add
+import androidx.compose.material.icons.filled.ArrowForward
+import androidx.compose.material3.Button
+import androidx.compose.material3.ButtonDefaults
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.Icon
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.painter.Painter
+import androidx.compose.ui.graphics.vector.ImageVector
+import androidx.compose.ui.platform.LocalConfiguration
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.res.painterResource
+import androidx.compose.ui.unit.Dp
+import androidx.compose.ui.unit.dp
+import androidx.compose.ui.unit.sp
+import androidx.compose.ui.unit.times
+import com.android.bookswap.R
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.theme.ColorVariable
+
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun BookAdditionChoiceScreen(
+    navController: NavigationActions,
+    topAppBar: @Composable () -> Unit = {},
+    bottomAppBar: @Composable () -> Unit = {},
+) {
+  val columnPadding = 16.dp
+  val buttonWidth = (LocalConfiguration.current.screenWidthDp.dp * (0.75f))
+  Scaffold(
+      modifier = Modifier.testTag("addBookChoiceScreen"),
+      topBar = topAppBar,
+      bottomBar = bottomAppBar) { innerPadding ->
+        Column(
+            modifier =
+                Modifier.padding(innerPadding)
+                    .fillMaxSize()
+                    .background(ColorVariable.BackGround)
+                    .padding(bottom = 10f * columnPadding, top = columnPadding),
+            verticalArrangement = Arrangement.Center,
+            horizontalAlignment = Alignment.CenterHorizontally) {
+              ButtonWithIcon(
+                  text = "Manually",
+                  leftIcon = Icons.Default.Add,
+                  leftIconPainter = null,
+                  navController = navController,
+                  navDestination = "AddBookManually Screen",
+                  buttonWidth = buttonWidth)
+              Spacer(modifier = Modifier.height(2f * columnPadding))
+              ButtonWithIcon(
+                  text = "From ISBN",
+                  leftIcon = null,
+                  leftIconPainter = painterResource(id = R.drawable.download),
+                  navController = navController,
+                  navDestination = "AddBookISBN Screen",
+                  buttonWidth = buttonWidth)
+              Spacer(modifier = Modifier.height(2f * columnPadding))
+              ButtonWithIcon(
+                  text = "From Photo",
+                  leftIcon = null,
+                  leftIconPainter = painterResource(id = R.drawable.photoicon),
+                  navController = navController,
+                  navDestination = "AddBookScan Screen",
+                  buttonWidth = buttonWidth)
+            }
+      }
+}
+
+@Composable
+fun ButtonWithIcon(
+    text: String,
+    leftIcon: ImageVector? = null,
+    leftIconPainter: Painter? = null,
+    navController: NavigationActions,
+    navDestination: String,
+    buttonWidth: Dp
+) {
+  val borderPadding = 1.dp
+  val buttonPadding = 8.dp
+  val iconSize = 32.dp
+  val pngSize = 24.dp
+  val textSize = 18.sp
+  Button(
+      onClick = { navController.navigateTo(navDestination) },
+      colors =
+          ButtonDefaults.buttonColors(
+              containerColor = ColorVariable.AccentSecondary,
+              contentColor = ColorVariable.BackGround),
+      border = BorderStroke(borderPadding, ColorVariable.Accent),
+      shape = RoundedCornerShape(buttonPadding),
+      modifier = Modifier.padding(buttonPadding).width(buttonWidth).testTag("button_$text")) {
+        Row(
+            modifier = Modifier.fillMaxWidth(),
+            horizontalArrangement = Arrangement.SpaceBetween,
+            verticalAlignment = Alignment.CenterVertically) {
+              if (leftIcon != null) {
+                Icon(
+                    imageVector = leftIcon,
+                    contentDescription = null,
+                    modifier = Modifier.size(iconSize).testTag("leftIcon_$text"))
+              } else if (leftIconPainter != null) {
+                Image(
+                    painter = leftIconPainter,
+                    contentDescription = null,
+                    modifier = Modifier.size(pngSize).testTag("leftPngIcon_$text"))
+              }
+              Text(text, fontSize = textSize)
+              Icon(
+                  imageVector = Icons.AutoMirrored.Filled.ArrowForward,
+                  contentDescription = null,
+                  modifier = Modifier.size(iconSize).testTag("rightIcon_$text"))
+            }
+      }
+}
Index: app/src/main/java/com/android/bookswap/ui/books/add/AddISBNScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/books/add/AddISBNScreen.kt b/app/src/main/java/com/android/bookswap/ui/books/add/AddISBNScreen.kt
new file mode 100644
--- /dev/null	(date 1731617442000)
+++ b/app/src/main/java/com/android/bookswap/ui/books/add/AddISBNScreen.kt	(date 1731617442000)
@@ -0,0 +1,103 @@
+package com.android.bookswap.ui.books.add
+
+import android.util.Log
+import android.widget.Toast
+import androidx.compose.foundation.background
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.padding
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.filled.Search
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.Icon
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.setValue
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.platform.LocalContext
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.unit.dp
+import com.android.bookswap.data.repository.BooksRepository
+import com.android.bookswap.data.source.api.GoogleBookDataSource
+import com.android.bookswap.ui.components.ButtonComponent
+import com.android.bookswap.ui.components.FieldComponent
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.navigation.TopLevelDestinations
+import com.android.bookswap.ui.theme.ColorVariable
+
+/** This is the main screen for the chat feature. It displays the list of messages */
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun AddISBNScreen(
+    navigationActions: NavigationActions,
+    booksRepository: BooksRepository,
+    topAppBar: @Composable () -> Unit = {},
+    bottomAppBar: @Composable () -> Unit = {}
+) {
+  val context = LocalContext.current
+  Scaffold(
+      topBar = topAppBar,
+      bottomBar = bottomAppBar,
+      content = { pv ->
+        Box(
+            modifier =
+                Modifier.fillMaxSize().padding(pv).background(color = ColorVariable.BackGround)) {
+              var isbn by remember { mutableStateOf("") }
+
+              Column(
+                  modifier = Modifier.fillMaxWidth().padding(top = 40.dp),
+                  horizontalAlignment = Alignment.CenterHorizontally,
+                  verticalArrangement = Arrangement.spacedBy(45.dp)) {
+                    FieldComponent(
+                        modifier = Modifier.testTag("isbn_field"),
+                        labelText = "ISBN*",
+                        value = isbn) {
+                          if (it.all { c -> c.isDigit() } && it.length <= 13) {
+                            isbn = it
+                          }
+                        }
+                    ButtonComponent(
+                        modifier = Modifier.testTag("isbn_searchButton"),
+                        onClick = {
+                          GoogleBookDataSource(context).getBookFromISBN(isbn) { result ->
+                            if (result.isFailure) {
+                              Toast.makeText(context, "Search unsuccessful", Toast.LENGTH_LONG)
+                                  .show()
+                              Log.e("AddBook", result.exceptionOrNull().toString())
+                            } else {
+                              booksRepository.addBook(
+                                  result.getOrThrow(),
+                                  callback = { res ->
+                                    if (res.isSuccess) {
+                                      navigationActions.navigateTo(TopLevelDestinations.NEW_BOOK)
+                                    } else {
+                                      val error = res.exceptionOrNull()!!
+                                      Log.e("AddBook", res.toString())
+                                      Toast.makeText(context, error.message, Toast.LENGTH_LONG)
+                                          .show()
+                                    }
+                                  })
+                            }
+                          }
+                        }) {
+                          Row(verticalAlignment = Alignment.CenterVertically) {
+                            Text("Search")
+                            Icon(
+                                Icons.Filled.Search,
+                                contentDescription = "Search icon",
+                            )
+                          }
+                        }
+                  }
+            }
+      })
+}
Index: .github/workflows/buildApk.yml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.github/workflows/buildApk.yml b/.github/workflows/buildApk.yml
new file mode 100644
--- /dev/null	(date 1730449039972)
+++ b/.github/workflows/buildApk.yml	(date 1730449039972)
@@ -0,0 +1,60 @@
+name: Build APK
+
+on:
+  push:
+    branches:
+      - main
+      - M1
+      - M2
+      - M3
+  workflow_dispatch:
+
+jobs:
+  build-apk:
+    name: Build APK
+    runs-on: ubuntu-latest
+
+    steps:
+      - name: Checkout code
+        uses: actions/checkout@v4
+
+      - name: Set up JDK 17
+        uses: actions/setup-java@v4
+        with:
+          distribution: 'temurin'
+          java-version: '17'
+
+      - name: Grant execute permission for gradlew
+        run: chmod +x ./gradlew
+
+      # Load google-services.json and local.properties from the secrets
+      - name: Decode secrets
+        env:
+          GOOGLE_SERVICES: ${{ secrets.GOOGLE_SERVICES }}
+          LOCAL_PROPERTIES: ${{ secrets.LOCAL_PROPERTIES }}
+        run: |
+          echo "$GOOGLE_SERVICES" | base64 --decode > ./app/google-services.json
+          echo "$LOCAL_PROPERTIES" | base64 --decode > ./local.properties
+
+      - name: Build Apk
+        run: |
+          ./gradlew assembleRelease # Build the release version
+      - name: Move files
+        run: |
+          mv app/build/outputs/apk/release/app-release-unsigned.apk app/build/outputs/app-release.apk
+          ls -l app/build/outputs/app-release.apk
+      - name: Sign App
+        id: sign_app
+        uses: ilharp/sign-android-release@v1.0.4
+        with:
+          releaseDir: app/build/outputs
+          signingKey: ${{ secrets.ANDROID_SIGNING_KEY }}
+          keyAlias: ${{ secrets.ANDROID_KEY_ALIAS }}
+          keyStorePassword: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
+          keyPassword: ${{ secrets.ANDROID_KEY_PASSWORD }}
+      - name: Upload Release Build to Artifacts
+        uses: actions/upload-artifact@v3
+        with:
+          name: apk-signed.apk
+          path: ${{ env.ANDROID_SIGNED_FILE }}
+          if-no-files-found: error
\ No newline at end of file
Index: app/build.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/build.gradle.kts b/app/build.gradle.kts
new file mode 100644
--- /dev/null	(date 1731617442000)
+++ b/app/build.gradle.kts	(date 1731617442000)
@@ -0,0 +1,283 @@
+import java.io.FileInputStream
+import java.util.Properties
+
+plugins {
+    jacoco
+    alias(libs.plugins.androidApplication)
+    alias(libs.plugins.jetbrainsKotlinAndroid)
+    alias(libs.plugins.ktfmt)
+    alias(libs.plugins.sonar)
+    id("com.google.gms.google-services")
+}
+
+android {
+    namespace = "com.android.bookswap"
+    compileSdk = 34
+
+    buildFeatures {
+        buildConfig = true
+    }
+    // Load the API key from local.properties
+    val localProperties = Properties()
+    val localPropertiesFile = rootProject.file("local.properties")
+    if (localPropertiesFile.exists()) {
+        localProperties.load(FileInputStream(localPropertiesFile))
+    }
+
+    val mapsApiKey: String = localProperties.getProperty("MAPS_API_KEY") ?: ""
+
+
+    defaultConfig {
+        applicationId = "com.android.bookswap"
+        minSdk = 28
+        targetSdk = 34
+        versionCode = 1
+        versionName = "1.0"
+
+        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
+        vectorDrawables {
+            useSupportLibrary = true
+        }
+        val openAiApiKey: String = localProperties.getProperty("OPENAI_API_KEY") ?: "\" placeHolder \" "
+        manifestPlaceholders["MAPS_API_KEY"] = mapsApiKey
+        manifestPlaceholders["OPENAI_API_KEY"] = openAiApiKey
+        buildConfigField("String", "OPENAI_API_KEY",  openAiApiKey)
+    }
+
+    buildTypes {
+        release {
+            signingConfig = null
+            isMinifyEnabled = false
+            proguardFiles(
+                getDefaultProguardFile("proguard-android-optimize.txt"),
+                "proguard-rules.pro"
+            )
+        }
+
+        debug {
+            enableUnitTestCoverage = true
+            enableAndroidTestCoverage = true
+        }
+    }
+
+    testCoverage {
+        jacocoVersion = "0.8.8"
+    }
+
+    buildFeatures {
+        compose = true
+        buildConfig = true //Generate a com.android.bookswap.BuildConfig file
+    }
+
+    composeOptions {
+        kotlinCompilerExtensionVersion = "1.4.2"
+    }
+
+    compileOptions {
+        sourceCompatibility = JavaVersion.VERSION_11
+        targetCompatibility = JavaVersion.VERSION_11
+    }
+
+    kotlinOptions {
+        jvmTarget = "11"
+    }
+
+    packaging {
+        resources {
+            excludes += "/META-INF/{AL2.0,LGPL2.1}"
+            merges += "META-INF/LICENSE.md"
+            merges += "META-INF/LICENSE-notice.md"
+            excludes += "META-INF/DEPENDENCIES"
+        }
+    }
+
+    testOptions {
+        unitTests {
+            isIncludeAndroidResources = true
+            isReturnDefaultValues = true
+        }
+    }
+
+    // Robolectric needs to be run only in debug. But its tests are placed in the shared source set (test)
+    // The next lines transfers the src/test/* from shared to the testDebug one
+    //
+    // This prevent errors from occurring during unit tests
+    sourceSets.getByName("testDebug") {
+        val test = sourceSets.getByName("test")
+
+        java.setSrcDirs(test.java.srcDirs)
+        res.setSrcDirs(test.res.srcDirs)
+        resources.setSrcDirs(test.resources.srcDirs)
+    }
+
+    sourceSets.getByName("test") {
+        java.setSrcDirs(emptyList<File>())
+        res.setSrcDirs(emptyList<File>())
+        resources.setSrcDirs(emptyList<File>())
+    }
+}
+
+sonar {
+    properties {
+        property("sonar.projectKey", "BookswapEPFL_Bookswap")
+        property("sonar.projectName", "BookSwapApp")
+        property("sonar.organization", "bookswapepfl")
+        property("sonar.host.url", "https://sonarcloud.io")
+        // Comma-separated paths to the various directories containing the *.xml JUnit report files. Each path may be absolute or relative to the project base directory.
+        property(
+            "sonar.junit.reportPaths",
+            "${project.layout.buildDirectory.get()}/test-results/testDebugunitTest/"
+        )
+        // Paths to xml files with Android Lint issues. If the main flavor is changed, this file will have to be changed too.
+        property(
+            "sonar.androidLint.reportPaths",
+            "${project.layout.buildDirectory.get()}/reports/lint-results-debug.xml"
+        )
+        // Paths to JaCoCo XML coverage report files.
+        property(
+            "sonar.coverage.jacoco.xmlReportPaths",
+            "${project.layout.buildDirectory.get()}/reports/jacoco/jacocoTestReport/jacocoTestReport.xml"
+        )
+    }
+}
+
+// When a library is used both by robolectric and connected tests, use this function
+fun DependencyHandlerScope.globalTestImplementation(dep: Any) {
+    androidTestImplementation(dep)
+    testImplementation(dep)
+}
+
+dependencies {
+    implementation("com.google.firebase:firebase-messaging:23.0.0")
+    implementation(platform("com.google.firebase:firebase-bom:33.4.0"))
+    implementation("com.google.firebase:firebase-auth")
+    implementation("com.google.firebase:firebase-analytics")
+    implementation ("com.google.firebase:firebase-storage:20.1.0")
+    implementation(libs.google.play.services.location)
+    implementation("io.coil-kt:coil-compose:2.1.0")
+    implementation(libs.androidx.core.ktx)
+    implementation(libs.androidx.appcompat)
+    implementation(libs.firebase.database.ktx)
+    implementation(libs.firebase.firestore)
+    implementation(libs.firebase.ui.auth)
+    implementation(libs.firebase.auth.ktx)
+    implementation(libs.firebase.auth)
+    implementation(libs.material)
+    implementation(libs.androidx.lifecycle.runtime.ktx)
+    implementation(platform(libs.compose.bom))
+    implementation(libs.androidx.espresso.intents)
+    implementation(libs.firebase.firestore.ktx)
+    implementation(libs.firebase.auth.ktx)
+    implementation(libs.androidx.navigation.compose)
+    implementation(libs.firebase.messaging.ktx)
+    implementation(libs.firebase.storage.ktx)
+    testImplementation(libs.junit)
+    testImplementation(libs.mockito.core)
+    testImplementation(libs.mockito.kotlin)
+    testImplementation(libs.mockk)
+    testImplementation(libs.mockito.inline)
+    globalTestImplementation(libs.androidx.junit)
+    globalTestImplementation(libs.androidx.espresso.core)
+    androidTestImplementation(libs.mockk.android)
+
+    // Google Service and Maps
+    implementation(libs.play.services.maps)
+    implementation(libs.play.services.auth)
+
+    // Google Service and Maps
+    implementation(libs.play.services.maps)
+    implementation(libs.maps.compose)
+    implementation(libs.maps.compose.utils)
+
+    // ------------- Jetpack Compose ------------------
+    implementation("androidx.compose.material:material:1.7.1")
+    val composeBom = platform(libs.compose.bom)
+    implementation(composeBom)
+    globalTestImplementation(composeBom)
+
+    implementation(libs.compose.ui)
+    implementation(libs.compose.ui.graphics)
+    // Material Design 3
+    implementation(libs.compose.material3)
+    // Integration with activities
+    implementation(libs.compose.activity)
+    // Integration with ViewModels
+    implementation(libs.compose.viewmodel)
+    // Android Studio Preview support
+    implementation(libs.compose.preview)
+    debugImplementation(libs.compose.tooling)
+    // UI Tests
+    globalTestImplementation(libs.compose.test.junit)
+    debugImplementation(libs.compose.test.manifest)
+
+    // --------- Kaspresso test framework ----------
+    globalTestImplementation(libs.kaspresso)
+    globalTestImplementation(libs.kaspresso.compose)
+
+    testImplementation(libs.mockito.core)
+    testImplementation(libs.mockito.inline)
+    testImplementation(libs.mockito.kotlin)
+    androidTestImplementation(libs.mockito.android)
+    androidTestImplementation(libs.mockito.kotlin)
+
+
+    // ----------       Robolectric     ------------
+    testImplementation(libs.robolectric)
+
+    implementation(libs.volley) //HTTP request
+    implementation(libs.okhttp)
+
+    implementation("org.apache.httpcomponents:httpclient:4.5.14")
+    implementation("org.apache.httpcomponents:httpcore:4.4.13")
+    implementation(libs.json) //JSON parser
+    implementation("androidx.appcompat:appcompat:1.6.1")
+    implementation("androidx.vectordrawable:vectordrawable:1.1.0")
+
+
+}
+
+tasks.withType<Test> {
+    // Configure Jacoco for each tests
+    configure<JacocoTaskExtension> {
+        isIncludeNoLocationClasses = true
+        excludes = listOf("jdk.internal.*")
+    }
+}
+
+tasks.register("jacocoTestReport", JacocoReport::class) {
+    mustRunAfter("testDebugUnitTest", "connectedDebugAndroidTest")
+
+    reports {
+        xml.required = true
+        html.required = true
+    }
+
+    val fileFilter = listOf(
+        "**/R.class",
+        "**/R$*.class",
+        "**/BuildConfig.*",
+        "**/Manifest*.*",
+        "**/*Test*.*",
+        "android/**/*.*",
+    )
+
+    val debugTree = fileTree("${project.layout.buildDirectory.get()}/tmp/kotlin-classes/debug") {
+        exclude(fileFilter)
+    }
+
+    val mainSrc = "${project.layout.projectDirectory}/src/main/java"
+    sourceDirectories.setFrom(files(mainSrc))
+    classDirectories.setFrom(files(debugTree))
+    executionData.setFrom(fileTree(project.layout.buildDirectory.get()) {
+        include("outputs/unit_test_code_coverage/debugUnitTest/testDebugUnitTest.exec")
+        include("outputs/code_coverage/debugAndroidTest/connected/*/coverage.ec")
+    })
+
+    doLast {
+        val reportFile = reports.xml.outputLocation.asFile.get()
+        val newContent = reportFile.readText().replace("<line[^>]+nr=\"65535\"[^>]*>".toRegex(), "")
+        reportFile.writeText(newContent)
+
+        logger.quiet("Wrote summarized jacoco test coverage report xml to ${reportFile.absolutePath}")
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/android/bookswap/ui/profile/UserProfile.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/profile/UserProfile.kt b/app/src/main/java/com/android/bookswap/ui/profile/UserProfile.kt
new file mode 100644
--- /dev/null	(date 1731634508328)
+++ b/app/src/main/java/com/android/bookswap/ui/profile/UserProfile.kt	(date 1731634508328)
@@ -0,0 +1,156 @@
+package com.android.bookswap.ui.profile
+
+import androidx.compose.foundation.*
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.aspectRatio
+import androidx.compose.foundation.layout.consumeWindowInsets
+import androidx.compose.foundation.layout.fillMaxHeight
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.shape.CircleShape
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.outlined.Edit
+import androidx.compose.material.icons.rounded.AccountCircle
+import androidx.compose.material3.*
+import androidx.compose.runtime.*
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.draw.clipToBounds
+import androidx.compose.ui.draw.scale
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.graphics.ColorFilter
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.unit.dp
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.model.UserViewModel
+import com.android.bookswap.ui.components.BookListComponent
+import com.android.bookswap.ui.components.ButtonComponent
+import com.android.bookswap.ui.theme.*
+import com.google.firebase.firestore.FirebaseFirestore
+
+@Composable
+fun UserProfile(
+    userVM: UserViewModel =
+        UserViewModel(java.util.UUID.randomUUID(), FirebaseFirestore.getInstance()),
+    topAppBar: @Composable () -> Unit = {},
+    bottomAppBar: @Composable () -> Unit = {}
+) {
+
+  var user = userVM.getUser()
+  var showEditProfile by remember { mutableStateOf(false) }
+    var bookList by remember { mutableStateOf(emptyList<DataBook>()) }
+  var needRecompose by remember { mutableStateOf(false) }
+
+  if (showEditProfile) {
+    EditProfileDialog(
+        onDismiss = {
+          showEditProfile = false
+          needRecompose = true
+        },
+        onSave = {
+          userVM.updateUser(
+              greeting = it.greeting,
+              firstName = it.firstName,
+              lastName = it.lastName,
+              email = it.email,
+              phone = it.phoneNumber,
+              user.latitude,
+              user.longitude,
+              picURL = user.profilePictureUrl)
+          showEditProfile = false
+          needRecompose = true
+        },
+        dataUser = user)
+  }
+
+  LaunchedEffect(userVM.uuid, needRecompose) {
+    user = userVM.getUser()
+     bookList =userVM.getBookList(user.bookList)
+    needRecompose = false
+  }
+
+  // Scaffold to provide basic UI structure with a top app bar
+  Scaffold(
+      modifier = Modifier.testTag("profileScreenContainer"),
+      topBar = topAppBar,
+      bottomBar = bottomAppBar) {
+        // Column layout to stack input fields vertically with spacing
+        Row(
+            modifier = Modifier.padding(it).consumeWindowInsets(it).fillMaxWidth(),
+            horizontalArrangement = Arrangement.spacedBy(5f.dp)) {
+              Column(modifier = Modifier.fillMaxWidth(0.25f)) {
+                Box {
+                  IconButton(
+                      onClick = { /*TODO: Edit profile picture*/},
+                      modifier = Modifier.aspectRatio(1f)) {
+                        Box(
+                            modifier =
+                                Modifier.padding(2.5f.dp)
+                                    .border(3.5f.dp, Color(0xFFA98467), CircleShape)) {
+                              Image(
+                                  imageVector = Icons.Rounded.AccountCircle,
+                                  contentDescription = "",
+                                  modifier = Modifier.fillMaxSize().scale(1.2f).clipToBounds(),
+                                  colorFilter = ColorFilter.tint(Color(0xFF6C584C)))
+                            }
+                        Box(
+                            modifier = Modifier.fillMaxSize().padding(0f.dp),
+                            contentAlignment = Alignment.TopEnd) {
+                              Image(
+                                  imageVector = Icons.Outlined.Edit,
+                                  contentDescription = "",
+                                  colorFilter = ColorFilter.tint(Color(0xFFAAAAAA)))
+                            }
+                      }
+                }
+              }
+              Column(Modifier.fillMaxHeight().fillMaxWidth(), Arrangement.spacedBy(8.dp)) {
+                // Full name text
+                Text(
+                    text = "${user.greeting} ${user.firstName} ${user.lastName}",
+                    modifier = Modifier.testTag("fullNameTxt"))
+
+                // Email text
+                Text(text = user.email, modifier = Modifier.testTag("emailTxt"))
+
+                // Phone number text
+                Text(text = user.phoneNumber, modifier = Modifier.testTag("phoneNumberTxt"))
+
+                // User address
+                Text(
+                    text = "${user.latitude}, ${user.longitude}",
+                    modifier = Modifier.testTag("addressTxt"))
+
+                // Edit Button
+                ButtonComponent({ showEditProfile = true }, Modifier.testTag("editProfileBtn")) {
+                  Text("Edit Profile")
+                }
+              }
+            }
+        BookListComponent(
+            modifier = Modifier.fillMaxWidth().padding(8.dp),bookList = bookList)
+      }
+}
+
+// @Preview(showBackground = true, widthDp = 540, heightDp = 1110)
+// @Composable
+// fun UserProfilePreview() {
+//  val userVM = UserViewModel("")
+//  userVM.updateUser(
+//    DataUser(
+//      "M.",
+//      "John",
+//      "Doe",
+//      "John.Doe@example.com",
+//      "+41223456789",
+//      0.0,
+//      0.0,
+//      "dummyPic.png",
+//      "dummyUUID0000")
+//  )
+//  UserProfile(userVM)
+// }
Index: app/src/main/java/com/android/bookswap/ui/components/FieldComponent.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/components/FieldComponent.kt b/app/src/main/java/com/android/bookswap/ui/components/FieldComponent.kt
new file mode 100644
--- /dev/null	(date 1731617442000)
+++ b/app/src/main/java/com/android/bookswap/ui/components/FieldComponent.kt	(date 1731617442000)
@@ -0,0 +1,342 @@
+package com.android.bookswap.ui.components
+
+import androidx.compose.animation.animateColorAsState
+import androidx.compose.animation.core.animateDpAsState
+import androidx.compose.animation.core.tween
+import androidx.compose.foundation.BorderStroke
+import androidx.compose.foundation.background
+import androidx.compose.foundation.border
+import androidx.compose.foundation.interaction.InteractionSource
+import androidx.compose.foundation.interaction.MutableInteractionSource
+import androidx.compose.foundation.interaction.collectIsFocusedAsState
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.PaddingValues
+import androidx.compose.foundation.layout.defaultMinSize
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.shape.CircleShape
+import androidx.compose.foundation.shape.RoundedCornerShape
+import androidx.compose.foundation.text.BasicTextField
+import androidx.compose.foundation.text.KeyboardActions
+import androidx.compose.foundation.text.KeyboardOptions
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.LocalTextStyle
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.OutlinedTextFieldDefaults
+import androidx.compose.material3.Text
+import androidx.compose.material3.TextFieldColors
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.State
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.rememberUpdatedState
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.Brush
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.graphics.SolidColor
+import androidx.compose.ui.graphics.takeOrElse
+import androidx.compose.ui.semantics.semantics
+import androidx.compose.ui.text.TextLayoutResult
+import androidx.compose.ui.text.TextStyle
+import androidx.compose.ui.text.input.VisualTransformation
+import androidx.compose.ui.unit.Dp
+import androidx.compose.ui.unit.dp
+
+private val FIELD_MIN_WIDTH = 280.dp
+private val FIELD_MIN_HEIGHT = 56.dp
+
+private val FIELD_PADDING = 8.dp
+private val FIELD_CONTENT_PADDING = 16.dp
+
+private val ANIMATION_DURATION = 150
+
+@Composable
+fun FieldComponent(
+    labelText: String,
+    value: String,
+    modifier: Modifier = Modifier,
+    onValueChange: (String) -> Unit = {}
+) {
+  FieldComponent(
+      value = value,
+      onValueChange = onValueChange,
+      modifier = modifier,
+      label = { Text(labelText) })
+}
+
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun FieldComponent(
+    value: String,
+    onValueChange: (String) -> Unit,
+    modifier: Modifier = Modifier,
+    enabled: Boolean = true,
+    readOnly: Boolean = false,
+    textStyle: TextStyle = LocalTextStyle.current,
+    label: @Composable() (() -> Unit)? = null,
+    placeholder: @Composable() (() -> Unit)? = null,
+    isError: Boolean = false,
+    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,
+    keyboardActions: KeyboardActions = KeyboardActions.Default,
+    singleLine: Boolean = false,
+    maxLines: Int = if (singleLine) 1 else Int.MAX_VALUE,
+    minLines: Int = 1,
+    visualTransformation: VisualTransformation = VisualTransformation.None,
+    onTextLayout: (TextLayoutResult) -> Unit = {},
+    interactionSource: MutableInteractionSource? = null,
+    cursorBrush: Brush = SolidColor(Color.Black)
+) {
+  val colors = OutlinedTextFieldDefaults.colors()
+  val m_interactionSource = interactionSource ?: remember { MutableInteractionSource() }
+  val textColor =
+      textStyle.color.takeOrElse { textColor(enabled, isError, m_interactionSource, colors).value }
+  val mergedTextStyle = textStyle.merge(TextStyle(color = textColor))
+  Box() {
+    BasicTextField(
+        value = value,
+        onValueChange = onValueChange,
+        modifier =
+            if (label != null) {
+              modifier
+                  .defaultMinSize(FIELD_MIN_WIDTH, FIELD_MIN_HEIGHT)
+                  // Merge semantics at the beginning of the modifier chain to ensure padding is
+                  // considered part of the text field.
+                  .semantics(mergeDescendants = true) {}
+                  .padding(top = FIELD_PADDING)
+            } else {
+              modifier
+            },
+        enabled,
+        readOnly,
+        mergedTextStyle,
+        keyboardOptions,
+        keyboardActions,
+        singleLine,
+        maxLines,
+        minLines,
+        visualTransformation,
+        onTextLayout,
+        m_interactionSource,
+        cursorBrush,
+        decorationBox =
+            @Composable {
+              OutlinedTextFieldDefaults.DecorationBox(
+                  value = value,
+                  innerTextField = it,
+                  enabled = enabled,
+                  singleLine = singleLine,
+                  visualTransformation = visualTransformation,
+                  interactionSource = m_interactionSource,
+                  isError = isError,
+                  label = label,
+                  placeholder = placeholder,
+                  container = {
+                    Box(
+                        Modifier.border(
+                                animateBorderStrokeAsState(
+                                        enabled = enabled,
+                                        isError = isError,
+                                        interactionSource = m_interactionSource,
+                                        colors = colors,
+                                        focusedBorderThickness = 2.dp,
+                                        unfocusedBorderThickness = 1.dp)
+                                    .value,
+                                RoundedCornerShape(100))
+                            .background(
+                                backgroundColor(
+                                        enabled = enabled,
+                                        isError = isError,
+                                        isEmpty =
+                                            if (m_interactionSource
+                                                .collectIsFocusedAsState()
+                                                .value) {
+                                              false
+                                            } else {
+                                              value.isEmpty()
+                                            },
+                                        colors = colors)
+                                    .value,
+                                CircleShape)
+                            .padding(FIELD_PADDING)
+                            .background(
+                                backgroundColor(
+                                        enabled = enabled,
+                                        isError = isError,
+                                        isEmpty =
+                                            if (m_interactionSource
+                                                .collectIsFocusedAsState()
+                                                .value) {
+                                              true
+                                            } else {
+                                              value.isEmpty()
+                                            },
+                                        colors = colors)
+                                    .value,
+                                CircleShape),
+                    )
+                  },
+                  contentPadding = PaddingValues(FIELD_CONTENT_PADDING))
+            })
+  }
+}
+
+@Composable
+private fun animateBorderStrokeAsState(
+    enabled: Boolean,
+    isError: Boolean,
+    interactionSource: InteractionSource,
+    colors: TextFieldColors,
+    focusedBorderThickness: Dp,
+    unfocusedBorderThickness: Dp
+): State<BorderStroke> {
+  val focused by interactionSource.collectIsFocusedAsState()
+  val indicatorColor = indicatorColor(enabled, isError, interactionSource, colors)
+  val targetThickness = if (focused) focusedBorderThickness else unfocusedBorderThickness
+  val animatedThickness =
+      if (enabled) {
+        animateDpAsState(targetThickness, tween(durationMillis = ANIMATION_DURATION))
+      } else {
+        rememberUpdatedState(unfocusedBorderThickness)
+      }
+  return rememberUpdatedState(
+      BorderStroke(animatedThickness.value, SolidColor(indicatorColor.value)))
+}
+
+@Composable
+internal fun backgroundColor(
+    enabled: Boolean,
+    isError: Boolean,
+    isEmpty: Boolean,
+    colors: TextFieldColors
+): State<Color> {
+  val targetValue =
+      when {
+        !enabled -> colors.disabledContainerColor
+        isError -> colors.errorContainerColor
+        isEmpty -> MaterialTheme.colorScheme.secondaryContainer
+        else -> colors.unfocusedContainerColor
+      }
+  return if (enabled) {
+    animateColorAsState(
+        targetValue, tween(durationMillis = ANIMATION_DURATION), "BackgroundColorAnim")
+  } else {
+    rememberUpdatedState(targetValue)
+  }
+}
+
+@Composable
+internal fun textColor(
+    enabled: Boolean,
+    isError: Boolean,
+    interactionSource: InteractionSource,
+    colors: TextFieldColors
+): State<Color> {
+  val focused by interactionSource.collectIsFocusedAsState()
+
+  return rememberUpdatedState(
+      when {
+        !enabled -> colors.disabledTextColor
+        isError -> colors.errorTextColor
+        focused -> colors.focusedTextColor
+        else -> colors.unfocusedTextColor
+      })
+}
+
+@Composable
+internal fun indicatorColor(
+    enabled: Boolean,
+    isError: Boolean,
+    interactionSource: InteractionSource,
+    colors: TextFieldColors
+): State<Color> {
+  val focused by interactionSource.collectIsFocusedAsState()
+
+  val targetValue =
+      when {
+        !enabled -> colors.disabledIndicatorColor
+        isError -> colors.errorIndicatorColor
+        focused -> colors.focusedIndicatorColor
+        else -> colors.unfocusedIndicatorColor
+      }
+  return if (enabled) {
+    animateColorAsState(
+        targetValue, tween(durationMillis = ANIMATION_DURATION), "IndicatorColorAnim")
+  } else {
+    rememberUpdatedState(targetValue)
+  }
+}
+
+/*
+@androidx.compose.ui.tooling.preview.Preview(
+    uiMode = android.content.res.Configuration.UI_MODE_NIGHT_NO,
+    showBackground = true,
+    name = "LightMode",
+    widthDp = 672,
+)
+@androidx.compose.ui.tooling.preview.Preview(
+    uiMode = android.content.res.Configuration.UI_MODE_NIGHT_YES,
+    showBackground = true,
+    name = "DarkMode",
+    widthDp = 672,
+)
+@Composable
+fun FieldComponentPreview() {
+  val txtValue1 = remember { androidx.compose.runtime.mutableStateOf("FExample TextStr") }
+  val txtValue2 = remember { androidx.compose.runtime.mutableStateOf("OExample TextStr") }
+  val txtValue3 = remember { androidx.compose.runtime.mutableStateOf("FExample TextStr") }
+  val txtValue4 = remember { androidx.compose.runtime.mutableStateOf("OExample TextTFV") }
+  val txtValue5 = remember { androidx.compose.runtime.mutableStateOf("FExample TextTFV") }
+  val txtValue6 = remember { androidx.compose.runtime.mutableStateOf("") }
+  val labelText = "Example Label"
+  val label: @Composable() (String) -> Unit = { Text(labelText + it) }
+
+  com.android.bookswap.ui.theme.BookSwapAppTheme(false) {
+    Box(modifier = Modifier.padding(4.dp)) {
+	  androidx.compose.foundation.layout.Row(Modifier.padding(4.dp)) {
+		androidx.compose.foundation.layout.Column(Modifier.padding(16.dp)) {
+		  FieldComponent("1", "2", Modifier)
+          FieldComponent(
+              value = txtValue1.value,
+              { txtValue1.value = it },
+              modifier = Modifier.padding(8.dp, 4.dp),
+              false,
+              true,
+              label = { label("Str1") },
+          )
+		  androidx.compose.material3.OutlinedTextField(
+              value = txtValue2.value,
+              { txtValue2.value = it },
+              modifier = Modifier.padding(8.dp, 4.dp),
+              label = { label("Str2") },
+          )
+          FieldComponent(
+              value = txtValue3.value,
+              { txtValue3.value = it },
+              modifier = Modifier.padding(8.dp, 4.dp),
+              false,
+              label = { label("Str3") },
+              isError = true)
+        }
+		androidx.compose.foundation.layout.Column(Modifier.padding(16.dp)) {
+		  androidx.compose.material3.OutlinedTextField(
+              value = txtValue4.value,
+              { txtValue4.value = it },
+              modifier = Modifier.padding(8.dp, 4.dp),
+              label = { label("TFV4") })
+          FieldComponent(
+              value = txtValue5.value,
+              { txtValue5.value = it },
+              modifier = Modifier.padding(8.dp, 4.dp),
+              label = { label("TFV5") },
+          )
+          FieldComponent(
+              value = txtValue6.value,
+              { txtValue6.value = it },
+              modifier = Modifier.padding(8.dp, 4.dp),
+              label = { label("TFV6") },
+          )
+        }
+      }
+    }
+  }
+}
+// */
Index: app/src/main/java/com/android/bookswap/ui/components/BackButtonComponent.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/components/BackButtonComponent.kt b/app/src/main/java/com/android/bookswap/ui/components/BackButtonComponent.kt
new file mode 100644
--- /dev/null	(date 1731615499000)
+++ b/app/src/main/java/com/android/bookswap/ui/components/BackButtonComponent.kt	(date 1731615499000)
@@ -0,0 +1,24 @@
+package com.android.bookswap.ui.components
+
+import androidx.compose.foundation.layout.size
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.automirrored.filled.ArrowBack
+import androidx.compose.material3.Icon
+import androidx.compose.material3.IconButton
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.unit.dp
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.theme.ColorVariable
+
+@Composable
+fun BackButtonComponent(navActions: NavigationActions) {
+  IconButton(onClick = { navActions.goBack() }, modifier = Modifier.testTag("backButton")) {
+    Icon(
+        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
+        tint = ColorVariable.Accent,
+        contentDescription = "Back",
+        modifier = Modifier.testTag("backIcon").size(32.dp))
+  }
+}
Index: app/src/main/java/com/android/bookswap/data/source/network/PhotoFirestoreSource 2.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/source/network/PhotoFirestoreSource 2.kt b/app/src/main/java/com/android/bookswap/data/source/network/PhotoFirestoreSource 2.kt
new file mode 100644
--- /dev/null	(date 1731617426000)
+++ b/app/src/main/java/com/android/bookswap/data/source/network/PhotoFirestoreSource 2.kt	(date 1731617426000)
@@ -0,0 +1,167 @@
+package com.android.bookswap.data.source.network
+
+import android.graphics.Bitmap
+import android.graphics.BitmapFactory
+import android.util.Base64
+import android.util.Log
+import com.android.bookswap.data.DataPhoto
+import com.android.bookswap.data.repository.PhotoRepository
+import com.google.android.gms.tasks.Task
+import com.google.firebase.firestore.DocumentSnapshot
+import com.google.firebase.firestore.FirebaseFirestore
+import java.io.ByteArrayOutputStream
+import java.util.UUID
+
+/** Constants : */
+/** Name of the Firestore collection that stores users */
+const val PHOTO_COLLECTION_PATH = "photos"
+/** Quality of the compressed image */
+const val COMPRESSION_QUALITY = 70
+/** Offset for the byte array */
+const val OFFSET = 0
+
+/**
+ * A class that implements the PhotoRepository interface using Firebase Firestore as the data
+ * source.
+ *
+ * @property db The Firestore database instance.
+ */
+class PhotoFirestoreSource(private val db: FirebaseFirestore) : PhotoRepository {
+
+  /**
+   * Generates and returns a new unique ID for a photo in Firestore.
+   *
+   * @return A new UUID.
+   */
+  override fun getNewUUID(): UUID {
+    return UUID.randomUUID()
+  }
+
+  /**
+   * Initializes the PhotoFirestoreSource.
+   *
+   * @param callback A callback function that receives Result.success(Unit) on success or
+   *   Result.failure(exception) on failure.
+   */
+  override fun init(callback: (Result<Unit>) -> Unit) {
+    try {
+      callback(Result.success(Unit))
+    } catch (e: Exception) {
+      Log.e("PhotoSource", "Initialization failed: ${e.message}")
+      callback(Result.failure(e))
+    }
+  }
+
+  /**
+   * Fetches a specific photo from Firestore by UUID.
+   *
+   * @param uuid the UUID of the photo to fetch
+   * @param callback callback function that receives Result.success(DataPhoto) when operation
+   *   succeed of Result.failure(exception) if error
+   */
+  override fun getPhoto(uuid: UUID, callback: (Result<DataPhoto>) -> Unit) {
+    db.collection(PHOTO_COLLECTION_PATH).document(uuid.toString()).get().addOnCompleteListener {
+        task ->
+      if (task.isSuccessful) {
+        val photo = task.result?.let { documentToPhoto(it) }
+        if (photo != null) {
+          callback(Result.success(photo))
+        } else {
+          callback(Result.failure(Exception("Photo not found or failed to convert")))
+        }
+      } else {
+        task.exception?.let { callback(Result.failure(it)) }
+      }
+    }
+  }
+
+  // Maybe not in the repository (I think it should be in the viewmodel)
+  /**
+   * Converts a Bitmap object to a Base64 encoded string.
+   *
+   * @param bitmap The Bitmap object to convert.
+   * @return The Base64 encoded string representation of the bitmap.
+   */
+  override fun bitmapToBase64(bitmap: Bitmap): String {
+    val baos = ByteArrayOutputStream()
+    bitmap.compress(Bitmap.CompressFormat.JPEG, COMPRESSION_QUALITY, baos)
+    val byteArray = baos.toByteArray()
+    return Base64.encodeToString(byteArray, Base64.DEFAULT)
+  }
+
+  // Same, maybe not in the repository (I think it should be in the viewmodel)
+  /**
+   * Converts a Base64 encoded string to a Bitmap object.
+   *
+   * @param base64 The Base64 encoded string to convert.
+   * @return The Bitmap object representation of the Base64 string.
+   */
+  override fun base64ToBitmap(base64: String): Bitmap {
+    val byteArray = Base64.decode(base64, Base64.DEFAULT)
+    return BitmapFactory.decodeByteArray(byteArray, OFFSET, byteArray.size)
+  }
+
+  /**
+   * Uploads a photo to Firestore.
+   *
+   * @param dataPhoto The DataPhoto object to be added to Firestore.
+   * @param callback Callback function that is called when the photo is successfully added or error
+   *   otherwise.
+   */
+  override fun addPhoto(dataPhoto: DataPhoto, callback: (Result<Unit>) -> Unit) {
+    Log.d("PhotoFirestoreRepository", "Attempting to add photo with UUID: ${dataPhoto.uuid}")
+
+    performFirestoreOperation(
+        db.collection(PHOTO_COLLECTION_PATH).document(dataPhoto.uuid.toString()).set(dataPhoto),
+        {
+          Log.d("PhotoFirestoreRepository", "Photo added successfully with UUID: ${dataPhoto.uuid}")
+          callback(Result.success(Unit))
+        },
+        { e ->
+          Log.e("PhotoFirestoreRepository", "Failed to add photo: ${e.message}", e)
+          callback(Result.failure(e))
+        })
+  }
+
+  /**
+   * Converts a Firestore document to a DataPhoto object.
+   *
+   * @param document The Firestore document to convert.
+   * @return The DataPhoto object if conversion is successful, otherwise null.
+   */
+  fun documentToPhoto(document: DocumentSnapshot): DataPhoto? {
+    return try {
+      val uuid = UUID.fromString(document.getString("uuid")) ?: return null
+      val url = document.getString("url") ?: ""
+      val timestamp = document.getLong("timestamp") ?: System.currentTimeMillis()
+      val base64 = document.getString("base64") ?: return null
+
+      DataPhoto(uuid = uuid, url = url, timestamp = timestamp, base64 = base64)
+    } catch (e: Exception) {
+      Log.e("PhotoFirestoreRepository", "Error converting document to DataPhoto", e)
+      null
+    }
+  }
+
+  /**
+   * Helper function to perform Firestore operations (add, update, delete). Executes the provided
+   * Firestore task and triggers success or failure callbacks.
+   *
+   * @param task The Firestore task to execute.
+   * @param onSuccess Callback function that is called when the task is successful.
+   * @param onFailure Callback function that is called when the task fails.
+   */
+  private fun performFirestoreOperation(
+      task: Task<Void>,
+      onSuccess: () -> Unit,
+      onFailure: (Exception) -> Unit
+  ) {
+    task.addOnCompleteListener { result ->
+      if (result.isSuccessful) {
+        onSuccess()
+      } else {
+        result.exception?.let { onFailure(it) }
+      }
+    }
+  }
+}
Index: app/src/main/java/com/android/bookswap/model/chat/NotificationActionReceiver.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/chat/NotificationActionReceiver.kt b/app/src/main/java/com/android/bookswap/model/chat/NotificationActionReceiver.kt
new file mode 100644
--- /dev/null	(date 1730385753957)
+++ b/app/src/main/java/com/android/bookswap/model/chat/NotificationActionReceiver.kt	(date 1730385753957)
@@ -0,0 +1,33 @@
+package com.android.bookswap.model.chat
+
+import android.content.BroadcastReceiver
+import android.content.Context
+import android.content.Intent
+import android.widget.Toast
+
+/** BroadcastReceiver to handle notification actions. */
+class NotificationActionReceiver : BroadcastReceiver() {
+  /**
+   * Called when the BroadcastReceiver is receiving an Intent broadcast.
+   *
+   * @param context the Context in which the receiver is running.
+   * @param intent the Intent being received.
+   */
+  override fun onReceive(context: Context, intent: Intent) {
+    when (intent.action) {
+      "ACTION_ACCEPT" -> {
+        // Handle accept action
+        requestCode(context, "Accepted")
+      }
+      "ACTION_DECLINE" -> {
+        // Handle decline action
+        requestCode(context, "Declined")
+      }
+    }
+  }
+
+  private fun requestCode(context: Context, action: String) {
+    // Implement the logic to handle the request code based on the action
+    Toast.makeText(context, "Action: $action", Toast.LENGTH_SHORT).show()
+  }
+}
Index: app/src/main/java/com/android/bookswap/ui/books/edit/EditBookScreen 2.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/books/edit/EditBookScreen 2.kt b/app/src/main/java/com/android/bookswap/ui/books/edit/EditBookScreen 2.kt
new file mode 100644
--- /dev/null	(date 1731617426318)
+++ b/app/src/main/java/com/android/bookswap/ui/books/edit/EditBookScreen 2.kt	(date 1731617426318)
@@ -0,0 +1,323 @@
+package com.android.bookswap.ui.books.edit
+
+import android.widget.Toast
+import androidx.compose.foundation.background
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.widthIn
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.automirrored.filled.ArrowBack
+import androidx.compose.material3.Button
+import androidx.compose.material3.ButtonDefaults
+import androidx.compose.material3.DropdownMenuItem
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.ExposedDropdownMenuBox
+import androidx.compose.material3.ExposedDropdownMenuDefaults
+import androidx.compose.material3.Icon
+import androidx.compose.material3.IconButton
+import androidx.compose.material3.OutlinedTextField
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.Text
+import androidx.compose.material3.TextFieldDefaults
+import androidx.compose.material3.TopAppBar
+import androidx.compose.material3.TopAppBarDefaults
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.setValue
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.platform.LocalConfiguration
+import androidx.compose.ui.platform.LocalContext
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.unit.dp
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.source.network.BooksFirestoreSource
+import com.android.bookswap.ui.books.add.createDataBook
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.theme.ColorVariable
+
+/** Constants * */
+private val SCREEN_PADDING = 16.dp
+private val ELEMENT_SPACING = 8.dp
+private val BUTTON_SPACER_HEIGHT = 16.dp
+private const val COLUMN_WIDTH_RATIO = 0.9f // Column width as 90% of screen width
+
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun EditBookScreen(
+    booksRepository: BooksFirestoreSource,
+    navigationActions: NavigationActions,
+    book: DataBook
+) {
+
+  val configuration = LocalConfiguration.current
+  val screenWidth = configuration.screenWidthDp.dp
+  val columnMaxWidth = screenWidth * COLUMN_WIDTH_RATIO
+  /*val book =
+      booksRepository.selectedBook.collectAsState().value
+          ?: return Text(text = "No Book selected. Should not happen", color = Color.Red)
+  */
+  // Use this and modify the editBookScreen structure if needed when incorporating in the app
+  // navigation
+
+  var title by remember { mutableStateOf(book.title) }
+  var author by remember { mutableStateOf(book.author ?: "") }
+  var description by remember { mutableStateOf(book.description ?: "") }
+  var rating by remember { mutableStateOf(book.rating?.toString() ?: "") }
+  var photo by remember { mutableStateOf(book.photo ?: "") }
+  var language by remember { mutableStateOf(book.language.toString()) }
+  var genres by remember { mutableStateOf(book.genres) }
+  var selectedGenre by remember { mutableStateOf<BookGenres?>(null) } // Genre selection state
+  var expanded by remember { mutableStateOf(false) } // State for dropdown menu
+
+  val context = LocalContext.current
+
+  Scaffold(
+      modifier = Modifier.testTag("editBookScreen").background(ColorVariable.BackGround),
+      containerColor = ColorVariable.BackGround, // Sets entire Scaffold background color
+      topBar = {
+        TopAppBar(
+            title = { Text("Edit your Book", modifier = Modifier.testTag("editBookTitle")) },
+            navigationIcon = {
+              IconButton(
+                  modifier = Modifier.testTag("goBackButton"),
+                  onClick = { navigationActions.goBack() }) {
+                    Icon(
+                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
+                        contentDescription = "Back")
+                  }
+            },
+            colors = TopAppBarDefaults.topAppBarColors(containerColor = ColorVariable.BackGround))
+      },
+      content = { paddingValues ->
+        LazyColumn(
+            modifier =
+                Modifier.fillMaxWidth()
+                    .padding(paddingValues)
+                    .padding(SCREEN_PADDING)
+                    .widthIn(max = columnMaxWidth)
+                    .background(ColorVariable.BackGround)
+                    .testTag("editBookScreenColumn"),
+            verticalArrangement = Arrangement.spacedBy(ELEMENT_SPACING)) {
+              // Title Edit Field
+              item {
+                OutlinedTextField(
+                    value = title,
+                    onValueChange = { title = it },
+                    label = { Text("Title") },
+                    placeholder = { Text("Enter the book title") },
+                    modifier = Modifier.fillMaxWidth().testTag("inputBookTitle"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+
+              item {
+                // Genre Dropdown Edit Field
+                ExposedDropdownMenuBox(
+                    expanded = expanded,
+                    onExpandedChange = { expanded = !expanded },
+                    modifier = Modifier.fillMaxWidth().testTag("GenreDropdown")) {
+                      OutlinedTextField(
+                          value = selectedGenre?.Genre ?: "Select Genre",
+                          onValueChange = {},
+                          label = { Text("Genre") },
+                          readOnly = true,
+                          trailingIcon = {
+                            ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)
+                          },
+                          modifier = Modifier.menuAnchor().testTag("SelectedGenre"),
+                          colors =
+                              TextFieldDefaults.outlinedTextFieldColors(
+                                  containerColor = ColorVariable.Secondary,
+                                  focusedBorderColor = Color.Black,
+                                  unfocusedBorderColor = Color.Black))
+                      ExposedDropdownMenu(
+                          expanded = expanded, onDismissRequest = { expanded = false }) {
+                            BookGenres.values().forEach { genre ->
+                              DropdownMenuItem(
+                                  text = { Text(text = genre.Genre) },
+                                  modifier = Modifier.testTag("GenreDropdownItem_${genre.Genre}"),
+                                  onClick = {
+                                    selectedGenre = genre
+                                    genres = listOf(genre) // Update genres list with selected genre
+                                    expanded = false
+                                  })
+                            }
+                          }
+                    }
+              }
+
+              item {
+                // Author Edit Field
+                OutlinedTextField(
+                    value = author,
+                    onValueChange = { author = it },
+                    label = { Text("Author") },
+                    placeholder = { Text("Enter the author's name") },
+                    modifier = Modifier.fillMaxWidth().testTag("inputBookAuthor"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+
+              item {
+                // Description Edit Field
+                OutlinedTextField(
+                    value = description,
+                    onValueChange = { description = it },
+                    label = { Text("Description") },
+                    placeholder = { Text("Provide a description of the book") },
+                    modifier = Modifier.fillMaxWidth().testTag("inputBookDescription"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+
+              item {
+                // Rating Edit Field
+                OutlinedTextField(
+                    value = rating,
+                    onValueChange = { rating = it },
+                    label = { Text("Rating") },
+                    placeholder = { Text("Rate the book (e.g. 4.5)") },
+                    modifier = Modifier.fillMaxWidth().testTag("inputBookRating"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+              // ISBN Edit Field
+              /*OutlinedTextField(
+                  value = isbn,
+                  onValueChange = { isbn = it },
+                  label = { Text("ISBN") },
+                  placeholder = { Text("ISBN Number") },
+                  modifier = Modifier.fillMaxWidth().testTag("inputBookISBN")
+              )*/
+              // Remove for now but could be added later
+
+              item {
+                // Photo Edit Field
+                OutlinedTextField(
+                    value = photo,
+                    onValueChange = { photo = it },
+                    label = { Text("Photo ") },
+                    placeholder = { Text("Enter a photo of the books") },
+                    modifier = Modifier.testTag("inputBookPhoto"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+
+              item {
+                // Language Edit Field
+                OutlinedTextField(
+                    value = language,
+                    onValueChange = { language = it },
+                    label = { Text("Language ") },
+                    placeholder = { Text("In which language are the book") },
+                    modifier = Modifier.testTag("inputBookLanguage"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+              item { Spacer(modifier = Modifier.height(BUTTON_SPACER_HEIGHT)) }
+
+              item {
+                Button(
+                    onClick = {
+                      try {
+                        if (title.isBlank())
+                            throw IllegalArgumentException("Title cannot be null or blank")
+                        if (author.isBlank())
+                            throw IllegalArgumentException("Author cannot be null or blank")
+                        if (description.isBlank())
+                            throw IllegalArgumentException("Description cannot be null or blank")
+                        if (rating.isBlank())
+                            throw IllegalArgumentException("Rating cannot be null or blank")
+                        if (photo.isBlank())
+                            throw IllegalArgumentException("Photo cannot be null or blank")
+                        if (language.isBlank())
+                            throw IllegalArgumentException("Language cannot be null or blank")
+                        if (book.isbn.isNullOrBlank())
+                            throw IllegalArgumentException("ISBN cannot be null or blank")
+                        if (genres.isEmpty())
+                            throw IllegalArgumentException("Genres cannot be empty")
+
+                        val updatedBook =
+                            createDataBook(
+                                context = context,
+                                uuid = book.uuid,
+                                title = title,
+                                author = author,
+                                description = description,
+                                ratingStr = rating,
+                                photo = photo,
+                                bookLanguageStr = language,
+                                isbn = book.isbn,
+                                genres = genres)
+
+                        booksRepository.updateBook(
+                            updatedBook!!,
+                            callback = { result ->
+                              if (result.isSuccess) {
+                                navigationActions.goBack()
+                              } else {
+                                Toast.makeText(
+                                        context, "Failed to update book.", Toast.LENGTH_SHORT)
+                                    .show()
+                              }
+                            })
+                      } catch (e: Exception) {
+                        Toast.makeText(context, "Error: ${e.message}", Toast.LENGTH_SHORT).show()
+                      }
+                    },
+                    modifier = Modifier.fillMaxWidth().testTag("bookSave"),
+                    enabled = title.isNotBlank(),
+                    colors = ButtonDefaults.buttonColors(containerColor = ColorVariable.Primary)) {
+                      Text("Save", color = Color.White)
+                    }
+              }
+
+              item {
+                Button(
+                    onClick = {
+                      booksRepository.deleteBooks(
+                          book.uuid,
+                          book,
+                          callback = { result ->
+                            if (result.isSuccess) {
+                              navigationActions.goBack()
+                            } else {
+                              Toast.makeText(context, "Failed to delete book.", Toast.LENGTH_SHORT)
+                                  .show()
+                            }
+                          })
+                    },
+                    modifier = Modifier.fillMaxWidth().testTag("bookDelete"),
+                    colors = ButtonDefaults.buttonColors(containerColor = ColorVariable.Primary)) {
+                      Text("Delete", color = Color.White)
+                    }
+              }
+            }
+      })
+}
Index: app/src/main/java/com/android/bookswap/model/chat/PermissionHandler.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/chat/PermissionHandler.kt b/app/src/main/java/com/android/bookswap/model/chat/PermissionHandler.kt
new file mode 100644
--- /dev/null	(date 1731615499000)
+++ b/app/src/main/java/com/android/bookswap/model/chat/PermissionHandler.kt	(date 1731615499000)
@@ -0,0 +1,83 @@
+package com.android.bookswap.model.chat
+
+import android.Manifest
+import android.content.pm.PackageManager
+import android.os.Build
+import android.widget.Toast
+import androidx.activity.ComponentActivity
+import androidx.activity.result.ActivityResultLauncher
+import androidx.activity.result.contract.ActivityResultContracts
+import androidx.annotation.RequiresApi
+import androidx.appcompat.app.AlertDialog
+import androidx.core.content.ContextCompat
+import com.google.firebase.messaging.FirebaseMessaging
+
+class PermissionHandler(private val activity: ComponentActivity) {
+
+  @RequiresApi(Build.VERSION_CODES.TIRAMISU)
+  val requestPermissionLauncher: ActivityResultLauncher<String> =
+      activity.registerForActivityResult(ActivityResultContracts.RequestPermission()) {
+          isGranted: Boolean ->
+        if (isGranted) {
+          enableNotifications()
+        } else {
+          informUserNotificationsDisabled()
+          showRationaleDialog()
+        }
+      }
+
+  fun askNotificationPermission() {
+    // Check if the API level is 33 or higher (Android 13+)
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
+      when {
+        // Case 1: Permission already granted
+        ContextCompat.checkSelfPermission(activity, Manifest.permission.POST_NOTIFICATIONS) ==
+            PackageManager.PERMISSION_GRANTED -> {
+          // FCM SDK (and your app) can post notifications.
+          enableNotifications()
+        }
+        // Case 2: No need to show rationale, directly request permission
+        else -> {
+          // Directly request the notification permission
+          requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
+        }
+      }
+    }
+  }
+
+  fun enableNotifications() {
+    // Initialize FCM SDK
+    FirebaseMessaging.getInstance().isAutoInitEnabled = true
+    // Additional setup if needed
+    Toast.makeText(activity, "Notifications have been enabled.", Toast.LENGTH_LONG).show()
+  }
+
+  fun informUserNotificationsDisabled() {
+    // Code to inform the user that notifications are disabled
+    // For example, you might show a Toast or a Snackbar
+    // This is a placeholder implementation
+    Toast.makeText(
+            activity,
+            "Notifications are disabled. You will not receive updates.",
+            Toast.LENGTH_LONG)
+        .show()
+  }
+
+  @RequiresApi(Build.VERSION_CODES.TIRAMISU)
+  private fun showRationaleDialog() {
+    AlertDialog.Builder(activity)
+        .setTitle("Notification Permission Required")
+        .setMessage(
+            "To keep you informed about important updates, please allow notification permissions.")
+        .setPositiveButton("OK") { _, _ ->
+          // Request the permission when the user agrees
+          requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
+        }
+        .setNegativeButton("No thanks") { dialog, _ ->
+          // Dismiss the dialog and continue without asking for permission
+          dialog.dismiss()
+        }
+        .create()
+        .show()
+  }
+}
Index: app/src/main/java/com/android/bookswap/ui/profile/EditProfile.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/profile/EditProfile.kt b/app/src/main/java/com/android/bookswap/ui/profile/EditProfile.kt
new file mode 100644
--- /dev/null	(date 1731615499000)
+++ b/app/src/main/java/com/android/bookswap/ui/profile/EditProfile.kt	(date 1731615499000)
@@ -0,0 +1,132 @@
+package com.android.bookswap.ui.profile
+
+import android.util.Log
+import androidx.compose.foundation.layout.*
+import androidx.compose.foundation.text.KeyboardOptions
+import androidx.compose.material3.*
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.text.input.KeyboardType
+import androidx.compose.ui.unit.dp
+import androidx.compose.ui.window.Dialog
+import androidx.compose.ui.window.DialogProperties
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.ui.theme.BookSwapAppTheme
+
+@Composable
+fun EditProfileDialog(onDismiss: () -> Unit, onSave: (DataUser) -> Unit, dataUser: DataUser) {
+
+  val _email = remember { mutableStateOf<String>(dataUser.email) }
+  val _phone = remember { mutableStateOf<String>(dataUser.phoneNumber) }
+  val _greeting = remember { mutableStateOf<String>(dataUser.greeting) }
+  val _firstName = remember { mutableStateOf<String>(dataUser.firstName) }
+  val _lastName = remember { mutableStateOf<String>(dataUser.lastName) }
+
+  BookSwapAppTheme {
+    Dialog({ onDismiss() }, DialogProperties(true, true)) {
+      Card(Modifier.testTag("editProfileContainer").padding(16.dp)) {
+        Column(
+            Modifier.fillMaxWidth().padding(16.dp),
+            Arrangement.Center,
+            Alignment.CenterHorizontally) {
+              Text("Edit Profile", Modifier.testTag("editProfileTitleTxt"))
+              OutlinedTextField(
+                  _greeting.value,
+                  {
+                    _greeting.value = it
+                    dataUser.greeting = _greeting.value
+                  },
+                  Modifier.testTag("greetingTbx").fillMaxWidth().padding(8.dp, 4.dp),
+                  label = { Text("Greeting") },
+                  placeholder = { Text("Mr.", Modifier, Color.Gray) },
+                  keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Text),
+                  singleLine = true)
+
+              OutlinedTextField(
+                  _firstName.value,
+                  {
+                    _firstName.value = it
+                    dataUser.firstName = _firstName.value
+                  },
+                  Modifier.testTag("firstnameTbx").fillMaxWidth().padding(8.dp, 4.dp),
+                  label = { Text("Firstname") },
+                  placeholder = { Text("John", Modifier, Color.Gray) },
+                  keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Text),
+                  singleLine = true)
+
+              OutlinedTextField(
+                  _lastName.value,
+                  {
+                    _lastName.value = it
+                    dataUser.lastName = _lastName.value
+                  },
+                  Modifier.testTag("lastnameTbx").fillMaxWidth().padding(8.dp, 4.dp),
+                  label = { Text("Lastname") },
+                  placeholder = { Text("Doe", Modifier, Color.Gray) },
+                  keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Text),
+                  singleLine = true)
+
+              OutlinedTextField(
+                  _email.value,
+                  {
+                    _email.value = it
+                    dataUser.email = _email.value
+                  },
+                  Modifier.testTag("emailTbx").fillMaxWidth().padding(8.dp, 4.dp),
+                  label = { Text("Email") },
+                  placeholder = { Text("John.Doe@example.com", Modifier, Color.Gray) },
+                  keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),
+                  singleLine = true)
+
+              OutlinedTextField(
+                  _phone.value,
+                  {
+                    _phone.value = it
+                    dataUser.phoneNumber = _phone.value
+                  },
+                  Modifier.testTag("phoneTbx").fillMaxWidth().padding(8.dp, 4.dp),
+                  label = { Text("Phone") },
+                  placeholder = { Text("+4122345678", Modifier, Color.Gray) },
+                  keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Phone),
+                  singleLine = true)
+
+              Row(Modifier.fillMaxWidth().padding(8.dp), Arrangement.SpaceEvenly) {
+                Button(
+                    {
+                      Log.d(
+                          "EditProfile_ClickBtn",
+                          "Save Clicked, User info: ${dataUser.printFullname()}")
+                      onSave(dataUser)
+                    },
+                    Modifier.testTag("confirmBtn")) {
+                      Text("Save")
+                    }
+
+                Button(
+                    { Log.d("EditProfile_ClickBtn", "Cancel Clicked") },
+                    Modifier.testTag("dismissBtn")) {
+                      Text("Cancel")
+                    }
+              }
+            }
+      }
+    }
+  }
+}
+
+/*@Preview(showBackground = true, widthDp = 540, heightDp = 1110)
+@Composable
+fun EditProfileDialoguePreview() {
+  val address = android.location.Address(java.util.Locale.getDefault())
+  address.countryCode = "CH"
+  address.locality = "Lausanne"
+  address.postalCode = "1000"
+  address.countryName = "Switzerland"
+  address.setAddressLine(0, "Rue de la Gare 1")
+  EditProfileDialog(onDismiss = { *//*TODO*//* }, onSave = { *//*TODO*//* }, dataUser = DataUser("Mr.", "John", "Doe", "John.Dow@example.com","+41223456789",address,"dummyPic.png","dummyUUID0000"))
+                                                                       }*/
Index: app/src/main/java/com/android/bookswap/model/map/BookManagerViewModel 2.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/map/BookManagerViewModel 2.kt b/app/src/main/java/com/android/bookswap/model/map/BookManagerViewModel 2.kt
new file mode 100644
--- /dev/null	(date 1731617426000)
+++ b/app/src/main/java/com/android/bookswap/model/map/BookManagerViewModel 2.kt	(date 1731617426000)
@@ -0,0 +1,150 @@
+package com.android.bookswap.model.map
+
+import android.location.Location
+import android.util.Log
+import androidx.lifecycle.ViewModel
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.UserBooksWithLocation
+import com.android.bookswap.data.repository.BooksRepository
+import com.android.bookswap.data.repository.UsersRepository
+import kotlinx.coroutines.*
+import kotlinx.coroutines.flow.*
+
+private const val REFRESH_TIME_DELAY = 5000L
+private const val RETRY_TIME_DELAY = 250L
+private const val MAXIMUM_RETRIES = 3
+
+/**
+ * The `BookManagerViewModel` class is responsible for managing book data and user data with
+ * location information, fetching data from the `BooksRepository`, computing distances between the
+ * current location and user locations, and filtering books based on user preferences. The list of
+ * all books can be obtained with the filteredBooks and the list of the list of books with the
+ * location of its owner with the filteredUsers
+ *
+ * @param geolocation the geolocation of the current user
+ * @param booksRepository an instance of [BooksRepository] to retrieve the books from the database.
+ * @param userRepository an instance of [UsersRepository] to retrieve the users from the database.
+ * @param bookFilter an instance of [BookFilter] that manages the filter that needs to be applied.
+ * @param computingDistanceMethod optional : a computation method for distances for testing purposes
+ */
+class BookManagerViewModel(
+    private val geolocation: IGeolocation,
+    private val booksRepository: BooksRepository,
+    private val userRepository: UsersRepository,
+    private val bookFilter: BookFilter,
+    // For the unit tests, the Android framework cannot be interacted with. The
+    // Location.distanceBetween needs to be replaced for testing.
+    private val computingDistanceMethod: (Double, Double, Double, Double) -> Double =
+        { startLatitude, startLongitude, endLatitude, endLongitude ->
+          val result = FloatArray(1)
+          Location.distanceBetween(startLatitude, startLongitude, endLatitude, endLongitude, result)
+          result[0].toDouble()
+        }
+) : ViewModel() {
+  // Internal MutableStateFlows to manage dynamic data
+  private val _allBooks = MutableStateFlow<List<DataBook>>(emptyList())
+  private val _allUsers = MutableStateFlow<List<DataUser>>(emptyList())
+  private val _allUserDistance = MutableStateFlow<List<Pair<DataUser, Double>>>(emptyList())
+  private val _filteredBooks = MutableStateFlow<List<DataBook>>(emptyList())
+  private val _filteredUsers = MutableStateFlow<List<UserBooksWithLocation>>(emptyList())
+
+  // Public StateFlows for UI to observe
+  val filteredBooks: StateFlow<List<DataBook>> = _filteredBooks.asStateFlow()
+  val filteredUsers: StateFlow<List<UserBooksWithLocation>> = _filteredUsers.asStateFlow()
+
+  private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())
+
+  fun startUpdatingBooks() {
+    scope.launch {
+      while (true) {
+        fetchBooksFromRepository()
+        delay(REFRESH_TIME_DELAY)
+      }
+    }
+    computeDistanceOfUsers()
+    combineFlowsAndFilterBooks()
+  }
+
+  fun stopUpdatingBooks() {
+    scope.cancel()
+  }
+
+  // Fetch books and users from the repository and update `_allBooks` and `_allUsers`
+  private suspend fun fetchBooksFromRepository() {
+    var successBooks = false
+    var successUsers = false
+    var currentAttempt = 0
+    while ((!successBooks || !successUsers) && currentAttempt < MAXIMUM_RETRIES) {
+      userRepository.getUsers { users ->
+        if (users.isSuccess) {
+          _allUsers.value = users.getOrNull()!!
+          successUsers = true
+        } else {
+          Log.e("BookManagerViewModel", "Failed to fetch users.")
+        }
+      }
+      booksRepository.getBook(
+          callback = { result ->
+            if (result.isSuccess) {
+              _allBooks.value = result.getOrThrow()
+              successBooks = true
+            } else {
+              Log.e(
+                  "BookManagerViewModel",
+                  "Failed to fetch books: ${result.exceptionOrNull()!!.message}")
+            }
+          })
+
+      if (!successBooks || !successUsers) {
+        currentAttempt++
+        delay(RETRY_TIME_DELAY)
+      }
+      if (currentAttempt == MAXIMUM_RETRIES) {
+        Log.e("BookManagerViewModel", "All retries failed.")
+      }
+    }
+  }
+
+  // Combine books and filter flows and apply filtering logic
+  private fun combineFlowsAndFilterBooks() {
+    scope.launch {
+      combine(_allBooks, _allUserDistance, bookFilter.genresFilter, bookFilter.languagesFilter) {
+              books,
+              userDistance,
+              _,
+              _ ->
+            val userBooksWithLocation =
+                userDistance.map { user ->
+                  UserBooksWithLocation(
+                      userUUID = user.first.userUUID,
+                      longitude = user.first.longitude,
+                      latitude = user.first.latitude,
+                      books =
+                          bookFilter.filterBooks(books).filter { book ->
+                            book.uuid in user.first.bookList
+                          })
+                }
+
+            _filteredBooks.value = userBooksWithLocation.flatMap { it.books }
+            _filteredUsers.value = userBooksWithLocation
+          }
+          .collect()
+    }
+  }
+
+  private fun computeDistanceOfUsers() {
+    scope.launch {
+      combine(_allUsers, geolocation.latitude, geolocation.longitude) { users, latitude, longitude
+            ->
+            val userDistance =
+                users.map { user ->
+                  user to
+                      computingDistanceMethod(latitude, longitude, user.latitude, user.longitude)
+                }
+            userDistance.sortedBy { it.second }
+          }
+          .collect { sortedUserDistance -> _allUserDistance.value = sortedUserDistance }
+    }
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/books/edit/EditBookTest 2.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/books/edit/EditBookTest 2.kt b/app/src/androidTest/java/com/android/bookswap/ui/books/edit/EditBookTest 2.kt
new file mode 100644
--- /dev/null	(date 1731617426312)
+++ b/app/src/androidTest/java/com/android/bookswap/ui/books/edit/EditBookTest 2.kt	(date 1731617426312)
@@ -0,0 +1,161 @@
+package com.android.bookswap.ui.books.edit
+
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.assertTextContains
+import androidx.compose.ui.test.assertTextEquals
+import androidx.compose.ui.test.hasTestTag
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.compose.ui.test.performClick
+import androidx.compose.ui.test.performScrollToNode
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.source.network.BooksFirestoreSource
+import com.android.bookswap.ui.navigation.NavigationActions
+import io.mockk.MockKAnnotations
+import io.mockk.every
+import io.mockk.impl.annotations.MockK
+import java.util.UUID
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+class EditBookScreenTest {
+
+  @MockK private lateinit var booksRepository: BooksFirestoreSource
+
+  @MockK private lateinit var navigationActions: NavigationActions
+
+  @get:Rule val composeTestRule = createComposeRule()
+
+  private val sampleBook =
+      DataBook(
+          uuid = UUID.randomUUID(),
+          title = "Sample Book",
+          author = "Sample Author",
+          description = "Sample Description",
+          rating = 4,
+          photo = "sample_photo_url",
+          language = BookLanguages.ENGLISH,
+          isbn = "123456789",
+          genres = listOf(BookGenres.FANTASY))
+
+  @Before
+  fun setUp() {
+    MockKAnnotations.init(this)
+
+    every { navigationActions.currentRoute() } returns "EDIT_BOOK"
+  }
+
+  @Test
+  fun displayEditScreenComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("editBookScreen").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditTitleComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("editBookTitle").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditTitleValueComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("editBookTitle").assertTextEquals("Edit your Book")
+  }
+
+  @Test
+  fun displayEditButtonComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("goBackButton").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditSaveValueComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule
+        .onNodeWithTag("editBookScreenColumn")
+        .performScrollToNode(hasTestTag("bookSave"))
+    composeTestRule.onNodeWithTag("bookSave").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("bookSave").assertTextEquals("Save")
+  }
+
+  @Test
+  fun displayEditDeleteValueComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule
+        .onNodeWithTag("editBookScreenColumn")
+        .performScrollToNode(hasTestTag("bookDelete"))
+    composeTestRule.onNodeWithTag("bookDelete").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("bookDelete").assertTextEquals("Delete")
+  }
+
+  @Test
+  fun displayEditBookTitleComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("inputBookTitle").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookAuthorComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookAuthor").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookDescriptionComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookDescription").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookRatingComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookRating").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookPhotoComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookPhoto").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookLanguageComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookLanguage").assertIsDisplayed()
+  }
+
+  @Test
+  fun inputsHaveInitialValue() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("inputBookTitle").assertTextContains(sampleBook.title)
+    composeTestRule.onNodeWithTag("inputBookAuthor").assertTextContains(sampleBook.author ?: "")
+    composeTestRule
+        .onNodeWithTag("inputBookDescription")
+        .assertTextContains(sampleBook.description ?: "")
+    composeTestRule.onNodeWithTag("inputBookPhoto").assertTextContains(sampleBook.photo ?: "")
+    composeTestRule
+        .onNodeWithTag("inputBookLanguage")
+        .assertTextContains(sampleBook.language.toString())
+  }
+
+  @Test
+  fun genreDropdownWorks() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    // opens genre dropdown and select a genre
+    composeTestRule.onNodeWithTag("GenreDropdown").performClick()
+    composeTestRule.onNodeWithTag("GenreDropdownItem_Fantasy").performClick()
+
+    // verify the selected genre
+    composeTestRule.onNodeWithTag("SelectedGenre").assertTextContains("Fantasy")
+  }
+}
Index: app/src/main/java/com/android/bookswap/ui/map/FilterButton.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/map/FilterButton.kt b/app/src/main/java/com/android/bookswap/ui/map/FilterButton.kt
new file mode 100644
--- /dev/null	(date 1731615499000)
+++ b/app/src/main/java/com/android/bookswap/ui/map/FilterButton.kt	(date 1731615499000)
@@ -0,0 +1,44 @@
+package com.android.bookswap.ui.map
+
+import androidx.compose.foundation.background
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.shape.RoundedCornerShape
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.filled.MoreVert
+import androidx.compose.material3.Icon
+import androidx.compose.material3.IconButton
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.unit.dp
+import com.android.bookswap.ui.theme.ColorVariable
+
+// Constants
+private val PADDING_DP = 16.dp
+private val BUTTON_SIZE_DP = 40.dp
+private val ICON_SIZE_DP = 32.dp
+private val BUTTON_CORNER_RADIUS_DP = 50.dp
+
+@Composable
+fun FilterButton(onClick: () -> Unit) {
+  Box(modifier = Modifier.padding(PADDING_DP)) {
+    IconButton(
+        onClick = onClick,
+        modifier =
+            Modifier.testTag("filterButton")
+                .background(
+                    color = ColorVariable.BackGround,
+                    shape = RoundedCornerShape(size = BUTTON_CORNER_RADIUS_DP)) // Use constant
+                .size(BUTTON_SIZE_DP)
+                .align(Alignment.TopStart)) {
+          Icon(
+              imageVector = Icons.Default.MoreVert,
+              contentDescription = "Filter",
+              tint = ColorVariable.Accent,
+              modifier = Modifier.size(ICON_SIZE_DP))
+        }
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/profile/UserProfileScreenTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/profile/UserProfileScreenTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/profile/UserProfileScreenTest.kt
new file mode 100644
--- /dev/null	(date 1731615667000)
+++ b/app/src/androidTest/java/com/android/bookswap/ui/profile/UserProfileScreenTest.kt	(date 1731615667000)
@@ -0,0 +1,125 @@
+package com.android.bookswap.ui.profile
+
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.navigation.compose.rememberNavController
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.model.UserViewModel
+import com.android.bookswap.screen.UserProfileScreen
+import com.android.bookswap.ui.components.TopAppBarComponent
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.kaspersky.kaspresso.testcases.api.testcase.TestCase
+import io.github.kakaocup.compose.node.element.ComposeScreen
+import io.mockk.every
+import io.mockk.mockk
+import java.util.UUID
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+/**
+ * Instrumented test, which will execute on an Android device.
+ *
+ * See [testing documentation](http://d.android.com/tools/testing).
+ */
+@RunWith(AndroidJUnit4::class)
+class UserProfileScreenTest : TestCase() {
+
+  @get:Rule val composeTestRule = createComposeRule()
+  private val standardUser =
+      DataUser(
+          UUID.randomUUID(),
+          "M.",
+          "John",
+          "Doe",
+          "John.Doe@example.com",
+          "+41223456789",
+          0.0,
+          0.0,
+          "dummyPic.png")
+
+  @Before
+  fun setup() {
+    val userVM: UserViewModel = mockk()
+    every { userVM.getUser(any()) } returns standardUser
+    every { userVM.uuid } returns standardUser.userUUID
+
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      UserProfile(userVM = userVM, { TopAppBarComponent(Modifier, navigationActions, "Messages") })
+    }
+  }
+
+  @Test
+  fun testDisplay() {
+    run(testName = "assertContent") {
+      step("Start User Profile Screen") {
+        ComposeScreen.onComposeScreen<UserProfileScreen>(composeTestRule) {
+          titleTxt { assertIsDisplayed() }
+          fullNameTxt {
+            assertIsDisplayed()
+            assertTextEquals("M. John Doe")
+          }
+          emailTxt {
+            assertIsDisplayed()
+            assertTextEquals("John.Doe@example.com")
+          }
+          phoneNumberTxt {
+            assertIsDisplayed()
+            assertTextEquals("+41223456789")
+          }
+          addressTxt {
+            assertIsDisplayed()
+            assertTextEquals("0.0, 0.0")
+          }
+          editProfileBtn {
+            assertIsDisplayed()
+            assertIsEnabled()
+          }
+        }
+      }
+    }
+  }
+
+  @Test
+  fun testEdit() {
+    run(testName = "assertEditAction") {
+      ComposeScreen.onComposeScreen<UserProfileScreen>(composeTestRule) {
+        step("Start User Profile Screen") {
+          fullNameTxt {
+            assertIsDisplayed()
+            assertTextEquals("M. John Doe")
+          }
+          emailTxt {
+            assertIsDisplayed()
+            assertTextEquals("John.Doe@example.com")
+          }
+          phoneNumberTxt {
+            assertIsDisplayed()
+            assertTextEquals("+41223456789")
+          }
+          addressTxt {
+            assertIsDisplayed()
+            assertTextEquals("0.0, 0.0")
+          }
+          editProfileBtn {
+            assertIsDisplayed()
+            assertIsEnabled()
+            assertHasClickAction()
+          }
+        }
+        step("Click edit button") {
+          editProfileBtn {
+            assertIsDisplayed()
+            assertIsEnabled()
+            assertHasClickAction()
+            performClick()
+          }
+        }
+      }
+    }
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/books/add/addBookTest 2.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/books/add/addBookTest 2.kt b/app/src/androidTest/java/com/android/bookswap/ui/books/add/addBookTest 2.kt
new file mode 100644
--- /dev/null	(date 1731617426000)
+++ b/app/src/androidTest/java/com/android/bookswap/ui/books/add/addBookTest 2.kt	(date 1731617426000)
@@ -0,0 +1,150 @@
+package com.android.bookswap.ui.books.add
+
+import android.content.Context
+import android.widget.Toast
+import androidx.compose.ui.test.assertIsEnabled
+import androidx.compose.ui.test.assertIsNotEnabled
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onNodeWithText
+import androidx.compose.ui.test.performClick
+import androidx.compose.ui.test.performTextInput
+import androidx.navigation.compose.rememberNavController
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.repository.BooksRepository
+import com.android.bookswap.ui.navigation.NavigationActions
+import io.mockk.every
+import io.mockk.mockk
+import io.mockk.mockkStatic
+import java.util.UUID
+import junit.framework.TestCase.assertEquals
+import junit.framework.TestCase.assertNull
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+class AddToBookTest {
+  @get:Rule val composeTestRule = createComposeRule()
+  private val mockContext: Context = mockk()
+  private val mockBooksRepository: BooksRepository = mockk()
+
+  @Before
+  fun init() {
+    mockkStatic(Toast::class)
+    val toastMock = mockk<Toast>()
+    every { toastMock.show() } returns Unit
+    every { Toast.makeText(any(), any<String>(), any()) } returns toastMock
+  }
+
+  @Test
+  fun testSaveButtonDisabledInitially() {
+    composeTestRule.setContent { AddToBookScreen(mockBooksRepository) }
+    // Check if the Save button is initially disabled
+    composeTestRule.onNodeWithText("Save").assertIsNotEnabled()
+  }
+
+  @Test
+  fun testSaveButtonEnabledWhenRequiredFieldsAreFilled() {
+    composeTestRule.setContent { AddToBookScreen(mockBooksRepository) }
+    // Fill in the Title and ISBN fields
+    composeTestRule.onNodeWithText("Title").performTextInput("My Book Title")
+    composeTestRule.onNodeWithText("ISBN").performTextInput("1234567890")
+    // Check if the Save button is now enabled
+    composeTestRule.onNodeWithText("Select Genre").performClick()
+    composeTestRule.onNodeWithText("Save").assertIsEnabled()
+  }
+
+  @Test
+  fun testCreateDataBook_ValidData() {
+    // Test with valid data
+    val book =
+        createDataBook(
+            context = mockContext,
+            uuid = UUID.randomUUID(),
+            title = "My Book",
+            author = "Author Name",
+            description = "This is a description",
+            ratingStr = "4",
+            photo = "https://example.com/photo.jpg",
+            bookLanguageStr = "ENGLISH",
+            isbn = "1234567890",
+            genres = listOf(BookGenres.TRAVEL))
+
+    // Assert the book is created correctly
+    assertEquals("My Book", book?.title)
+    assertEquals("Author Name", book?.author)
+    assertEquals("This is a description", book?.description)
+    assertEquals(4, book?.rating)
+    assertEquals("https://example.com/photo.jpg", book?.photo)
+    assertEquals(BookLanguages.ENGLISH, book?.language)
+    assertEquals("1234567890", book?.isbn)
+  }
+
+  @Test
+  fun testCreateDataBook_InvalidData() {
+    // Test with invalid data (empty title)
+    var book =
+        createDataBook(
+            context = mockContext,
+            uuid = UUID.randomUUID(),
+            title = "",
+            author = "Author Name",
+            description = "This is a description",
+            ratingStr = "4",
+            photo = "https://example.com/photo.jpg",
+            bookLanguageStr = "ENGLISH",
+            isbn = "1234567890",
+            genres = listOf(BookGenres.TRAVEL))
+
+    // Assert that the book is null due to invalid title
+    assertNull(book)
+
+    // Test with invalid rating
+    book =
+        createDataBook(
+            context = mockContext,
+            uuid = UUID.randomUUID(),
+            title = "My Book",
+            author = "Author Name",
+            description = "This is a description",
+            ratingStr = "invalid_rating",
+            photo = "https://example.com/photo.jpg",
+            bookLanguageStr = "ENGLISH",
+            isbn = "1234567890",
+            genres = listOf(BookGenres.TRAVEL))
+
+    // Assert that the book is null due to invalid rating
+    assertNull(book)
+
+    // Test with invalid language
+    book =
+        createDataBook(
+            context = mockContext,
+            uuid = UUID.randomUUID(),
+            title = "My Book",
+            author = "Author Name",
+            description = "This is a description",
+            ratingStr = "4",
+            photo = "https://example.com/photo.jpg",
+            bookLanguageStr = "INVALID_LANGUAGE",
+            isbn = "1234567890",
+            genres = listOf(BookGenres.TRAVEL))
+
+    // Assert that the book is null due to invalid language
+    assertNull(book)
+  }
+
+  @Test
+  fun testSaveButtonDisabledWhenTitleIsEmpty() {
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      AddToBookScreen(mockBooksRepository)
+    }
+    // Fill in the ISBN field but leave the Title field empty
+    composeTestRule.onNodeWithText("ISBN").performTextInput("1234567890")
+
+    // Check if the Save button is still disabled
+    composeTestRule.onNodeWithText("Save").assertIsNotEnabled()
+  }
+}
Index: app/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
new file mode 100644
--- /dev/null	(date 1731615667000)
+++ b/app/src/main/AndroidManifest.xml	(date 1731615667000)
@@ -0,0 +1,85 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.android.bookswap">
+
+    <permission
+        android:name="com.android.bookswap.permission.SEND_MESSAGES"
+        android:protectionLevel="signature" />
+
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
+    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
+    <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+    <uses-permission android:name="android.permission.WAKE_LOCK" />
+    <uses-permission android:name="com.google.android.c2dm.permission.RECEIVE" />
+    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
+
+    <!-- Photo permissions -->
+    <uses-permission android:name="android.permission.CAMERA" />
+    <uses-feature android:name="android.hardware.camera" android:required="false" />
+
+    <application
+        android:allowBackup="true"
+        android:dataExtractionRules="@xml/data_extraction_rules"
+        android:fullBackupContent="@xml/backup_rules"
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name"
+        android:roundIcon="@mipmap/ic_launcher_round"
+        android:supportsRtl="true"
+        android:theme="@style/Theme.BookSwapApp"
+        tools:targetApi="31">
+
+        <activity
+            android:name=".MainActivity"
+            android:exported="true"
+            android:label="@string/title_activity_main"
+            android:theme="@style/Theme.BookSwapApp">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+
+        <service
+            android:name=".model.chat.MyFirebaseMessagingService"
+            android:exported="true"
+            android:permission="com.android.bookswap.permission.SEND_MESSAGES">
+            <intent-filter>
+                <action android:name="com.google.firebase.MESSAGING_EVENT"/>
+            </intent-filter>
+        </service>
+
+        <meta-data
+            android:name="com.google.android.geo.API_KEY"
+            android:value="${MAPS_API_KEY}" />
+
+        <meta-data
+            android:name="com.google.firebase.messaging.default_notification_channel_id"
+            android:value="bookswap_notifications_channel" />
+
+        <receiver
+            android:name="com.google.firebase.iid.FirebaseInstanceIdReceiver"
+            android:exported="true"
+            android:permission="com.google.android.c2dm.permission.SEND">
+            <intent-filter>
+                <action android:name="com.google.android.c2dm.intent.RECEIVE" />
+                <category android:name="${applicationId}" />
+            </intent-filter>
+        </receiver>
+
+        <!-- Photo file provider -->
+        <provider
+            android:name="androidx.core.content.FileProvider"
+            android:authorities="${applicationId}.provider"
+            android:exported="false"
+            android:grantUriPermissions="true">
+            <meta-data
+                android:name="android.support.FILE_PROVIDER_PATHS"
+                android:resource="@xml/filepaths" />
+        </provider>
+
+    </application>
+
+</manifest>
\ No newline at end of file
Index: app/src/androidTest/java/com/android/bookswap/ui/profile/EditProfileScreenTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/profile/EditProfileScreenTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/profile/EditProfileScreenTest.kt
new file mode 100644
--- /dev/null	(date 1731615667000)
+++ b/app/src/androidTest/java/com/android/bookswap/ui/profile/EditProfileScreenTest.kt	(date 1731615667000)
@@ -0,0 +1,441 @@
+package com.android.bookswap.ui.profile
+
+import android.util.Log
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.screen.EditProfileScreen
+import com.kaspersky.kaspresso.testcases.api.testcase.TestCase
+import io.github.kakaocup.compose.node.element.ComposeScreen
+import java.util.UUID
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+/**
+ * Instrumented test, which will execute on an Android device.
+ *
+ * See [testing documentation](http://d.android.com/tools/testing).
+ */
+@RunWith(AndroidJUnit4::class)
+class EditProfileScreenTest : TestCase() {
+  @get:Rule val composeTestRule = createComposeRule()
+
+  private val standardUser =
+      DataUser(
+          UUID.randomUUID(),
+          "M.",
+          "John",
+          "Doe",
+          "John.Doe@example.com",
+          "+41223456789",
+          0.0,
+          0.0,
+          "dummyPic.png")
+
+  @Test
+  fun testDisplay() =
+      run(testName = "test alert display") {
+        val userUUID = UUID.randomUUID()
+        composeTestRule.setContent {
+          EditProfileDialog(
+              { Log.d("EditProfileTest_Dismiss", "User info discarded") },
+              { Log.d("EditProfileTest_Save", "User info saved ${it.printFullname()}") },
+              DataUser(userUUID, "", "", "", "", "", 0.0, 0.0, ""))
+        }
+        step("try displaying the alert box") {
+          ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {
+            titleTxt {
+              assertIsDisplayed()
+              assertTextEquals("Edit Profile")
+            }
+            greetingTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextContains("Greeting", true)
+              performTextClearance()
+              assertTextContains("Mr.", true)
+            }
+            firstnameTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextContains("Firstname", true)
+              performTextClearance()
+              assertTextContains("John", true)
+            }
+            lastnameTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextContains("Lastname", true)
+              performTextClearance()
+              assertTextContains("Doe", true)
+            }
+            emailTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextContains("Email", true)
+              performTextClearance()
+              assertTextContains("John.Doe@example.com", true)
+            }
+            phoneNumberTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextContains("Phone", true)
+              performTextClearance()
+              assertTextContains("+4122345678", true)
+            }
+            confirmBtn {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextEquals("Save")
+            }
+            dismissBtn {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextEquals("Cancel")
+            }
+          }
+        }
+      }
+
+  @Test
+  fun testEdit() =
+      run(testName = "test alert edit") {
+        composeTestRule.setContent {
+          EditProfileDialog(
+              { Log.d("EditProfileTest_Dismiss", "User info discarded") },
+              { Log.d("EditProfileTest_Save", "User info saved ${it.printFullname()}") },
+              standardUser)
+        }
+        step("try editing the textbox values") {
+          ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {
+            titleTxt {
+              assertIsDisplayed()
+              assertTextEquals("Edit Profile")
+            }
+            greetingTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              performClick()
+              performTextClearance()
+              assertTextContains("Greeting", true)
+              performTextInput("Mr.")
+              assertTextContains("Mr.", true)
+            }
+            firstnameTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              performClick()
+              performTextClearance()
+              assertTextContains("Firstname", true)
+              performTextInput("Jones")
+              assertTextContains("Jones", true)
+            }
+            lastnameTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              performClick()
+              performTextClearance()
+              assertTextContains("Lastname", true)
+              performTextInput("Douses")
+              assertTextContains("Douses", true)
+            }
+            emailTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              performClick()
+              performTextClearance()
+              assertTextContains("Email", true)
+              performTextInput("Jones.Douses@example.com")
+              assertTextContains("Jones.Douses@example.com", true)
+            }
+            phoneNumberTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              performClick()
+              performTextClearance()
+              assertTextContains("Phone", true)
+              performTextInput("+41234567890")
+              assertTextContains("+41234567890", true)
+            }
+            confirmBtn {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextEquals("Save")
+            }
+            dismissBtn {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextEquals("Cancel")
+            }
+          }
+        }
+      }
+
+  @Test
+  fun testEditConfirm() =
+      run(testName = "test edit and confirm") {
+        composeTestRule.setContent {
+          EditProfileDialog(
+              { Log.d("EditProfileTest_Dismiss", "User info discarded") },
+              { Log.d("EditProfileTest_Save", "User info saved ${it.printFullname()}") },
+              standardUser)
+        }
+        step("try editing the textbox values then confirming the changes") {
+          ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {
+            titleTxt {
+              assertIsDisplayed()
+              assertTextEquals("Edit Profile")
+            }
+            greetingTbx {
+              performTextClearance()
+              performTextInput("Mr.")
+              assertTextEquals("Greeting", "Mr.")
+            }
+            firstnameTbx {
+              performTextClearance()
+              performTextInput("Jones")
+              assertTextEquals("Firstname", "Jones")
+            }
+            lastnameTbx {
+              performTextClearance()
+              performTextInput("Douses")
+              assertTextEquals("Lastname", "Douses")
+            }
+            emailTbx {
+              performTextClearance()
+              performTextInput("Jones.Douses@example.com")
+              assertTextEquals("Email", "Jones.Douses@example.com")
+            }
+            phoneNumberTbx {
+              performTextClearance()
+              performTextInput("+41234567890")
+              assertTextEquals("Phone", "+41234567890")
+            }
+            confirmBtn {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextEquals("Save")
+            }
+            dismissBtn {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextEquals("Cancel")
+            }
+          }
+        }
+        step("try pressing on confirm") {
+          ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {
+            step("") {
+              titleTxt {
+                assertIsDisplayed()
+                assertTextEquals("Edit Profile")
+              }
+              greetingTbx {
+                assertIsDisplayed()
+                assertIsEnabled()
+                assertTextEquals("Greeting", "Mr.")
+              }
+              firstnameTbx {
+                assertIsDisplayed()
+                assertIsEnabled()
+                assertTextEquals("Firstname", "Jones")
+              }
+              lastnameTbx {
+                assertIsDisplayed()
+                assertIsEnabled()
+                assertTextEquals("Lastname", "Douses")
+              }
+              emailTbx {
+                assertIsDisplayed()
+                assertIsEnabled()
+                assertTextEquals("Email", "Jones.Douses@example.com")
+              }
+              phoneNumberTbx {
+                assertIsDisplayed()
+                assertIsEnabled()
+                assertTextEquals("Phone", "+41234567890")
+              }
+              confirmBtn {
+                assertIsDisplayed()
+                assertIsEnabled()
+                assertTextEquals("Save")
+              }
+              dismissBtn {
+                assertIsDisplayed()
+                assertIsEnabled()
+                assertTextEquals("Cancel")
+              }
+            }
+            step("") {
+              confirmBtn {
+                assertIsDisplayed()
+                assertIsEnabled()
+                assertTextEquals("Save")
+                performClick()
+              }
+            }
+          }
+        }
+      }
+
+  @Test
+  fun testEditDismiss() =
+      run(testName = "test alert display") {
+        composeTestRule.setContent {
+          EditProfileDialog(
+              { Log.d("EditProfileTest_Dismiss", "User info discarded") },
+              { Log.d("EditProfileTest_Save", "User info saved ${it.printFullname()}") },
+              standardUser)
+        }
+        step("try editing the textbox values then cancelling the changes") {
+          ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {
+            titleTxt {
+              assertIsDisplayed()
+              assertTextEquals("Edit Profile")
+            }
+            greetingTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              performClick()
+              performTextClearance()
+              performTextInput("Mr.")
+            }
+            firstnameTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              performClick()
+              performTextClearance()
+              performTextInput("Jones")
+            }
+            lastnameTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              performClick()
+              performTextClearance()
+              performTextInput("Douses")
+            }
+            emailTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              performClick()
+              performTextClearance()
+              performTextInput("Jones.Douses@example.com")
+            }
+            phoneNumberTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              performClick()
+              performTextClearance()
+              performTextInput("+41234567890")
+            }
+            confirmBtn {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextEquals("Save")
+            }
+            dismissBtn {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextEquals("Cancel")
+            }
+          }
+        }
+        step("test if the values are edited") {
+          ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {
+            titleTxt {
+              assertIsDisplayed()
+              assertTextEquals("Edit Profile")
+            }
+            greetingTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextEquals("Greeting", "Mr.")
+            }
+            firstnameTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextEquals("Firstname", "Jones")
+            }
+            lastnameTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextEquals("Lastname", "Douses")
+            }
+            emailTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextEquals("Email", "Jones.Douses@example.com")
+            }
+            phoneNumberTbx {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextEquals("Phone", "+41234567890")
+            }
+            confirmBtn {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextEquals("Save")
+            }
+            dismissBtn {
+              assertIsDisplayed()
+              assertIsEnabled()
+              assertTextEquals("Cancel")
+            }
+          }
+        }
+        step("try pressing on cancel") {
+          ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {
+            step("") {
+              titleTxt {
+                assertIsDisplayed()
+                assertTextEquals("Edit Profile")
+              }
+              greetingTbx {
+                assertIsDisplayed()
+                assertIsEnabled()
+                assertTextEquals("Greeting", "Mr.")
+              }
+              firstnameTbx {
+                assertIsDisplayed()
+                assertIsEnabled()
+                assertTextEquals("Firstname", "Jones")
+              }
+              lastnameTbx {
+                assertIsDisplayed()
+                assertIsEnabled()
+                assertTextEquals("Lastname", "Douses")
+              }
+              emailTbx {
+                assertIsDisplayed()
+                assertIsEnabled()
+                assertTextEquals("Email", "Jones.Douses@example.com")
+              }
+              phoneNumberTbx {
+                assertIsDisplayed()
+                assertIsEnabled()
+                assertTextEquals("Phone", "+41234567890")
+              }
+              confirmBtn {
+                assertIsDisplayed()
+                assertIsEnabled()
+                assertTextEquals("Save")
+              }
+              dismissBtn {
+                assertIsDisplayed()
+                assertIsEnabled()
+                assertTextEquals("Cancel")
+              }
+            }
+            step("") {
+              dismissBtn {
+                assertIsDisplayed()
+                assertIsEnabled()
+                assertTextEquals("Cancel")
+                performClick()
+              }
+            }
+          }
+        }
+      }
+}
Index: app/src/main/java/com/android/bookswap/model/chat/MyFirebaseMessagingService.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/chat/MyFirebaseMessagingService.kt b/app/src/main/java/com/android/bookswap/model/chat/MyFirebaseMessagingService.kt
new file mode 100644
--- /dev/null	(date 1730385753957)
+++ b/app/src/main/java/com/android/bookswap/model/chat/MyFirebaseMessagingService.kt	(date 1730385753957)
@@ -0,0 +1,118 @@
+package com.android.bookswap.model.chat
+
+import android.app.NotificationChannel
+import android.app.NotificationManager
+import android.app.PendingIntent
+import android.content.Context.NOTIFICATION_SERVICE
+import android.content.Intent
+import android.os.Build
+import androidx.core.app.NotificationCompat
+import androidx.core.content.ContextCompat.getSystemService
+import com.android.bookswap.MainActivity
+import com.android.bookswap.R
+import com.google.firebase.messaging.FirebaseMessagingService
+import com.google.firebase.messaging.RemoteMessage
+
+/** Service to handle Firebase Cloud Messaging notifications. */
+const val DEFAULT_TITLE = "Hello There!"
+const val DEFAULT_BODY = "You have a new notification"
+
+open class MyFirebaseMessagingService : FirebaseMessagingService() {
+  /**
+   * Called when a message is received.
+   *
+   * @param remoteMessage the message received from Firebase Cloud Messaging.
+   */
+  override fun onMessageReceived(remoteMessage: RemoteMessage) {
+    val notification = remoteMessage.notification
+    val title = notification?.title ?: DEFAULT_TITLE
+    val body = notification?.body ?: DEFAULT_BODY
+    sendNotification(title, body)
+  }
+
+  /**
+   * Sends a notification to the user.
+   *
+   * @param title the title of the notification.
+   * @param messageBody the body of the notification.
+   */
+  fun sendNotification(title: String, messageBody: String) {
+    // Create an intent to open the MainActivity when the notification is clicked
+    val intent =
+        Intent(this, MainActivity::class.java).apply { addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP) }
+    val pendingIntent =
+        PendingIntent.getActivity(
+            this, 0, intent, PendingIntent.FLAG_ONE_SHOT or PendingIntent.FLAG_IMMUTABLE)
+    // Create intent and PendingIntent for the "Accept" action
+    val acceptIntent =
+        Intent(this, NotificationActionReceiver::class.java).apply { action = "ACTION_ACCEPT" }
+    val acceptPendingIntent =
+        PendingIntent.getBroadcast(
+            this,
+            0,
+            acceptIntent,
+            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
+
+    // Create intent and PendingIntent for the "Decline" action
+    val declineIntent =
+        Intent(this, NotificationActionReceiver::class.java).apply { action = "ACTION_DECLINE" }
+    val declinePendingIntent =
+        PendingIntent.getBroadcast(
+            this,
+            1,
+            declineIntent,
+            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
+
+    // Define a meaningful channel ID and channel name
+    val channelId = "bookswap_notifications_channel"
+    val channelName = "BookSwap Notifications"
+
+    // Build the notification
+    val notificationBuilder =
+        NotificationCompat.Builder(this, channelId)
+            .setSmallIcon(R.drawable.ic_launcher_foreground)
+            .setContentTitle(title)
+            .setContentText(messageBody)
+            .setAutoCancel(true)
+            .setContentIntent(pendingIntent)
+            .setPriority(NotificationCompat.PRIORITY_HIGH)
+            .addAction(R.drawable.ic_launcher_foreground, "Accept", acceptPendingIntent)
+            .addAction(R.drawable.ic_launcher_foreground, "Decline", declinePendingIntent)
+
+    // Get the NotificationManager
+    val notificationManager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager
+
+    // Create the notification channel
+    createNotificationChannel(notificationManager, channelId, channelName)
+
+    // Use a unique ID for each notification to avoid overwriting
+    val notificationId = System.currentTimeMillis().toInt()
+    notificationManager.notify(notificationId, notificationBuilder.build())
+  }
+
+  /**
+   * Creates a notification channel for Android O and above.
+   *
+   * @param notificationManager the NotificationManager to create the channel.
+   * @param channelId the ID of the notification channel.
+   * @param channelName the name of the notification channel.
+   */
+  fun createNotificationChannel(
+      notificationManager: NotificationManager,
+      channelId: String,
+      channelName: String
+  ) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      val importance = NotificationManager.IMPORTANCE_HIGH
+      val channel =
+          NotificationChannel(channelId, channelName, importance).apply {
+            description = "Channel for BookSwap notifications"
+            enableLights(true)
+
+            lightColor = android.graphics.Color.RED
+            enableVibration(true)
+          }
+      notificationManager.createNotificationChannel(channel)
+    }
+  }
+}
Index: app/src/main/java/com/android/bookswap/model/map/BookFilter.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/map/BookFilter.kt b/app/src/main/java/com/android/bookswap/model/map/BookFilter.kt
new file mode 100644
--- /dev/null	(date 1730385753957)
+++ b/app/src/main/java/com/android/bookswap/model/map/BookFilter.kt	(date 1730385753957)
@@ -0,0 +1,71 @@
+package com.android.bookswap.model.map
+
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.flow.asStateFlow
+
+/** This class is responsible for filtering books based on the selected genres and languages */
+class BookFilter {
+
+  private val _genresFilter = MutableStateFlow<List<BookGenres>>(emptyList())
+  private val _languagesFilter = MutableStateFlow<List<BookLanguages>>(emptyList())
+
+  val genresFilter: StateFlow<List<BookGenres>> = _genresFilter.asStateFlow()
+  val languagesFilter: StateFlow<List<BookLanguages>> = _languagesFilter.asStateFlow()
+
+  /**
+   * Filters the books based on the selected genres and languages
+   *
+   * @param books The list of books to be filtered
+   * @return The filtered list of books
+   */
+  fun filterBooks(books: List<DataBook>): List<DataBook> {
+    var filteredBooks = books
+    if (_genresFilter.value.isNotEmpty()) {
+      filteredBooks = filterByGenres(filteredBooks)
+    }
+    if (_languagesFilter.value.isNotEmpty()) {
+      filteredBooks = filterByLanguages(filteredBooks)
+    }
+    return filteredBooks
+  }
+
+  // Filters the books based on the selected genres
+  private fun filterByGenres(books: List<DataBook>): List<DataBook> {
+    return books.filter { book -> book.genres.any { it in _genresFilter.value } }
+  }
+  // Filters the books based on the selected languages
+  private fun filterByLanguages(books: List<DataBook>): List<DataBook> {
+    return books.filter { book -> book.language in _languagesFilter.value }
+  }
+
+  /**
+   * Sets the selected genres
+   *
+   * @param genres The list of genres to be set
+   */
+  fun setGenres(genres: List<String>) {
+    val newGenresFilter =
+        genres.mapNotNull { genre ->
+          // Use the Genre parameter to get the corresponding BookGenres enum
+          BookGenres.values().firstOrNull { it.Genre.equals(genre, ignoreCase = true) }
+        }
+    _genresFilter.value = newGenresFilter
+  }
+
+  /**
+   * Sets the selected languages
+   *
+   * @param languages The list of languages to be set
+   */
+  fun setLanguages(languages: List<String>) {
+    val newLanguagesFilter =
+        languages.mapNotNull { language ->
+          runCatching { BookLanguages.valueOf(language.uppercase()) }.getOrNull()
+        }
+    _languagesFilter.value = newLanguagesFilter
+  }
+}
Index: app/src/main/java/com/android/bookswap/MainActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/MainActivity.kt b/app/src/main/java/com/android/bookswap/MainActivity.kt
new file mode 100644
--- /dev/null	(date 1731618874000)
+++ b/app/src/main/java/com/android/bookswap/MainActivity.kt	(date 1731618874000)
@@ -0,0 +1,260 @@
+package com.android.bookswap
+
+import android.os.Bundle
+import androidx.activity.ComponentActivity
+import androidx.activity.compose.setContent
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.Surface
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.semantics.semantics
+import androidx.compose.ui.semantics.testTag
+import androidx.navigation.compose.NavHost
+import androidx.navigation.compose.composable
+import androidx.navigation.compose.rememberNavController
+import androidx.navigation.navigation
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.MessageBox
+import com.android.bookswap.data.repository.BooksRepository
+import com.android.bookswap.data.repository.MessageRepository
+import com.android.bookswap.data.repository.UsersRepository
+import com.android.bookswap.data.source.network.BooksFirestoreSource
+import com.android.bookswap.data.source.network.MessageFirestoreSource
+import com.android.bookswap.data.source.network.UserFirestoreSource
+import com.android.bookswap.model.UserViewModel
+import com.android.bookswap.model.chat.PermissionHandler
+import com.android.bookswap.model.map.BookFilter
+import com.android.bookswap.model.map.BookManagerViewModel
+import com.android.bookswap.model.map.DefaultGeolocation
+import com.android.bookswap.model.map.Geolocation
+import com.android.bookswap.model.map.IGeolocation
+import com.android.bookswap.resources.C
+import com.android.bookswap.ui.authentication.SignInScreen
+import com.android.bookswap.ui.books.add.AddISBNScreen
+import com.android.bookswap.ui.books.add.AddToBookScreen
+import com.android.bookswap.ui.books.add.BookAdditionChoiceScreen
+import com.android.bookswap.ui.chat.ChatScreen
+import com.android.bookswap.ui.chat.ListChatScreen
+import com.android.bookswap.ui.components.TopAppBarComponent
+import com.android.bookswap.ui.map.FilterMapScreen
+import com.android.bookswap.ui.map.MapScreen
+import com.android.bookswap.ui.navigation.BottomNavigationMenu
+import com.android.bookswap.ui.navigation.List_Navigation_Bar_Destinations
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.navigation.Route
+import com.android.bookswap.ui.navigation.Screen
+import com.android.bookswap.ui.profile.NewUserScreen
+import com.android.bookswap.ui.profile.UserProfile
+import com.android.bookswap.ui.theme.BookSwapAppTheme
+import com.google.firebase.Firebase
+import com.google.firebase.auth.auth
+import com.google.firebase.auth.ktx.auth
+import com.google.firebase.firestore.FirebaseFirestore
+import java.util.UUID
+
+class MainActivity : ComponentActivity() {
+
+  private lateinit var permissionHandler: PermissionHandler
+
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+    // permissionHandler = PermissionHandler(this)
+    // permissionHandler.askNotificationPermission()
+    setContent { BookSwapApp() }
+  }
+
+  @Composable
+  fun BookSwapApp() {
+
+    // Initialize a Firebase Firestore database instance
+    val db = FirebaseFirestore.getInstance()
+
+    // Create the data source objects
+    val messageRepository = MessageFirestoreSource(db)
+    val bookRepository = BooksFirestoreSource(db)
+    val userDataSource = UserFirestoreSource(db)
+
+    // Initialize the geolocation
+    val geolocation = Geolocation(this)
+    BookSwapAppTheme {
+      // A surface container using the 'background' color from the theme
+      Surface(
+          modifier = Modifier.fillMaxSize().semantics { testTag = C.Tag.main_screen_container },
+          color = MaterialTheme.colorScheme.background) {
+            BookSwapApp(
+                messageRepository, bookRepository, userDataSource, geolocation = geolocation)
+          }
+    }
+  }
+
+  @Composable
+  fun BookSwapApp(
+      messageRepository: MessageRepository,
+      bookRepository: BooksRepository,
+      userRepository: UsersRepository,
+      startDestination: String = Route.AUTH,
+      geolocation: IGeolocation = DefaultGeolocation()
+  ) {
+    // navigation part
+    val navController = rememberNavController()
+    val navigationActions = NavigationActions(navController)
+
+    // user part
+    Firebase.auth.signOut() // Uncomment this line to test the sign in screen
+    val currentUser = Firebase.auth.currentUser
+    val userVM = UserViewModel(UUID.randomUUID(), firebase = FirebaseFirestore.getInstance())
+
+    if (currentUser != null) {
+      userVM.getUserByGoogleUid(currentUser.uid) // This will scrap the user from the database
+    }
+    // Book part
+    val bookFilter = BookFilter()
+    val bookManagerViewModel =
+        BookManagerViewModel(geolocation, bookRepository, userRepository, bookFilter)
+
+    val currentUserUUID = UUID.fromString("550e8400-e29b-41d4-a716-446655440000")
+    val otherUserUUID = UUID.fromString("550e8400-e29b-41d4-a716-446655440001")
+    val testUserUUID = UUID.fromString("550e8400-e29b-41d4-a716-446655440002")
+    val currentUserPlaceholder =
+        DataUser(
+            currentUserUUID,
+            "Mr.",
+            "Jaime",
+            "Oliver Pastor",
+            "",
+            "",
+            42.5717,
+            0.5471,
+            "https://media.istockphoto.com/id/693813718/photo/the-fortress-of-jaca-soain.jpg?s=612x612&w=0&k=20&c=MdnKl1VJIKQRwGdrGwBFx_L00vS8UVphR9J-nS6J90c=",
+            emptyList(),
+            "googleUid")
+
+    val otherUser =
+        DataUser(
+            otherUserUUID,
+            "Mr.",
+            "Théo",
+            "Schlaeppi",
+            "",
+            "",
+            46.3,
+            6.43,
+            "https://www.shutterstock.com/image-photo/wonderful-epesses-fairtytale-village-middle-600nw-2174791585.jpg",
+            emptyList(),
+            "googleUid")
+    val testUser =
+        DataUser(
+            testUserUUID,
+            "Mr.",
+            "John",
+            "Doe",
+            "john.doe@hotmail.com",
+            "+41999999999",
+            0.0,
+            0.0,
+            "john_doe.jpg",
+            emptyList(),
+            "googleUid")
+
+    val placeHolder =
+        listOf(MessageBox(otherUser, message = "Welcome message for user124", date = "01.01.24")) +
+            List(5) {
+              MessageBox(
+                  DataUser(
+                      UUID.randomUUID(),
+                      "Hello",
+                      "First ${it + 1}",
+                      "Last ${it + 1}",
+                      "",
+                      "",
+                      0.0,
+                      0.0,
+                      "",
+                      emptyList(),
+                      "googleUid"),
+                  message = "Test message $it test for the feature of ellipsis in the message",
+                  date = "01.01.24")
+            } +
+            listOf(MessageBox(testUser, message = "Welcome message for test", date = "01.01.24"))
+    val topAppBar =
+        @Composable { s: String? ->
+          TopAppBarComponent(
+              modifier = Modifier,
+              navigationActions = navigationActions,
+              title = s ?: navigationActions.currentRoute())
+        }
+    val bottomAppBar =
+        @Composable { s: String? ->
+          BottomNavigationMenu(
+              onTabSelect = { destination -> navigationActions.navigateTo(destination) },
+              tabList = List_Navigation_Bar_Destinations,
+              selectedItem = s ?: "")
+        }
+
+    NavHost(navController = navController, startDestination = startDestination) {
+      navigation(startDestination = Screen.AUTH, route = Route.AUTH) {
+        composable(Screen.AUTH) { SignInScreen(navigationActions, userVM) }
+        composable(Screen.NEW_USER) { NewUserScreen(navigationActions, userVM) }
+      }
+      navigation(startDestination = Screen.CHATLIST, route = Route.CHAT) {
+        composable(Screen.CHATLIST) {
+          ListChatScreen(
+              placeHolder,
+              navigationActions,
+              topAppBar = { topAppBar("Messages") },
+              bottomAppBar = { bottomAppBar(this@navigation.route ?: "") })
+        }
+        composable("${Screen.CHAT}/{user2}") { backStackEntry ->
+          val user2UUID = UUID.fromString(backStackEntry.arguments?.getString("user2"))
+          val user2 = placeHolder.firstOrNull { it.contact.userUUID == user2UUID }?.contact
+
+          if (user2 != null) {
+            ChatScreen(messageRepository, currentUserPlaceholder, user2, navigationActions)
+          } else {
+            BookAdditionChoiceScreen(
+                navigationActions,
+                topAppBar = { topAppBar("Add a Book") },
+                bottomAppBar = { bottomAppBar(this@navigation.route ?: "") })
+          }
+        }
+      }
+      navigation(startDestination = Screen.MAP, route = Route.MAP) {
+        composable(Screen.MAP) {
+          MapScreen(
+              bookManagerViewModel,
+              navigationActions = navigationActions,
+              geolocation = geolocation,
+              topAppBar = { topAppBar("Map") },
+              bottomAppBar = { bottomAppBar(this@navigation.route ?: "") })
+        }
+        composable(Screen.FILTER) { FilterMapScreen(navigationActions, bookFilter) }
+      }
+      navigation(startDestination = Screen.NEWBOOK, route = Route.NEWBOOK) {
+        composable(Screen.NEWBOOK) {
+          BookAdditionChoiceScreen(
+              navigationActions,
+              topAppBar = { topAppBar("Add a Book") },
+              bottomAppBar = { bottomAppBar(this@navigation.route ?: "") })
+        }
+        composable(Screen.ADD_BOOK_MANUALLY) {
+          AddToBookScreen(
+              bookRepository,
+              topAppBar = { topAppBar(null) },
+              bottomAppBar = { bottomAppBar(this@navigation.route ?: "") })
+        }
+        composable(Screen.ADD_BOOK_SCAN) { /*Todo*/}
+        composable(Screen.ADD_BOOK_ISBN) {
+          AddISBNScreen(
+              navigationActions,
+              bookRepository,
+              topAppBar = { topAppBar(null) },
+              bottomAppBar = { bottomAppBar(this@navigation.route ?: "") })
+        }
+      }
+      navigation(startDestination = Screen.PROFILE, route = Route.PROFILE) {
+        composable(Screen.PROFILE) { UserProfile(userVM) }
+      }
+    }
+  }
+}
Index: app/src/main/java/com/android/bookswap/data/source/api/GoogleBookDataSource.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/source/api/GoogleBookDataSource.kt b/app/src/main/java/com/android/bookswap/data/source/api/GoogleBookDataSource.kt
new file mode 100644
--- /dev/null	(date 1731617426315)
+++ b/app/src/main/java/com/android/bookswap/data/source/api/GoogleBookDataSource.kt	(date 1731617426315)
@@ -0,0 +1,89 @@
+package com.android.bookswap.data.source.api
+
+import android.content.Context
+import androidx.annotation.VisibleForTesting
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.utils.getJSONArrayOrNull
+import com.android.bookswap.utils.getJSONObjectOrNull
+import com.android.bookswap.utils.getStringOrNull
+import com.android.volley.Request
+import com.android.volley.VolleyError
+import com.android.volley.toolbox.StringRequest
+import com.android.volley.toolbox.Volley
+import java.util.UUID
+import org.json.JSONObject
+
+const val GOOGLE_BOOK_API = "https://www.googleapis.com/books/v1/volumes?q="
+
+/**
+ * Source to request data from GoogleBook
+ *
+ * @param context the context from where the request is made
+ */
+class GoogleBookDataSource(context: Context) {
+  private val queue = Volley.newRequestQueue(context)
+
+  /**
+   * Request a book from GoogleBook using an ISBN This function return the data using callback
+   *
+   * @param isbn a string of 10 or 13 digits representing an ISBN
+   * @param callback callback with a Result of a DataBook
+   * @throws IllegalArgumentException if isbn is not in a valid format
+   * @author EdenKahane
+   */
+  fun getBookFromISBN(isbn: String, callback: (Result<DataBook>) -> Unit) {
+    try {
+      require(isbn.all { it.isDigit() }) { "ISBN should only be composed of digits" }
+      require(isbn.length == 10 || isbn.length == 13) { "ISBN should be of length 10 or 13" }
+    } catch (exception: Exception) {
+      callback(Result.failure(exception))
+      return
+    }
+
+    val stringRequest =
+        StringRequest(
+            Request.Method.GET,
+            GOOGLE_BOOK_API.plus("isbn:${isbn}"),
+            { response -> callback(parseISBNResponse(response)) },
+            { error -> Result.failure<VolleyError>(error) })
+    queue.add(stringRequest)
+  }
+
+  @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+  fun parseISBNResponse(response: String): Result<DataBook> {
+    try {
+      val json = JSONObject(response)
+      // Since we want the result to fail when specific data are not available (like title),
+      // we do not always use get..OrNull()
+      val item = json.getJSONArray("items").getJSONObject(0).getJSONObject("volumeInfo")
+
+      val language =
+          when (val languageCode = item.getStringOrNull("language")?.uppercase()) {
+            is String -> BookLanguages.values().first { it.languageCode == languageCode }
+            else -> null
+          }
+
+      // We do not know where the ISBN_13 is, so we need to filter for it
+      val industryIdentifiers = item.getJSONArray("industryIdentifiers")
+      val identifier =
+          (0 until industryIdentifiers.length())
+              .map { industryIdentifiers.getJSONObject(it) }
+              .first { it.getString("type") == "ISBN_13" }
+              .getString("identifier")
+
+      return Result.success(
+          DataBook(
+              UUID.randomUUID(),
+              item.getString("title"),
+              item.getJSONArrayOrNull("authors")?.getStringOrNull(0),
+              item.getStringOrNull("description"),
+              null,
+              item.getJSONObjectOrNull("imageLinks")?.getStringOrNull("thumbnail"),
+              language ?: BookLanguages.OTHER,
+              identifier))
+    } catch (exception: Exception) {
+      return Result.failure(exception)
+    }
+  }
+}
Index: app/src/main/java/com/android/bookswap/data/repository/BookRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/repository/BookRepository.kt b/app/src/main/java/com/android/bookswap/data/repository/BookRepository.kt
new file mode 100644
--- /dev/null	(date 1731617426314)
+++ b/app/src/main/java/com/android/bookswap/data/repository/BookRepository.kt	(date 1731617426314)
@@ -0,0 +1,55 @@
+package com.android.bookswap.data.repository
+
+import com.android.bookswap.data.DataBook
+import java.util.UUID
+
+/** Interface defining a contract for managing book-related operations in a repository. */
+interface BooksRepository {
+
+  /**
+   * Function to initialize the repository. This can be used to set up data or resources. This
+   * default implementation does nothing, but subclasses can override it.
+   */
+  fun init(onSuccess: () -> Unit)
+
+  /**
+   * Function to generate and return a new unique identifier (UUID) for a book. This default
+   * implementation returns an empty string, but it should be overridden to generate actual UUIDs.
+   */
+  fun getNewUUID(): UUID
+
+  /**
+   * Function to fetch a list of books from the repository.
+   *
+   * @param callback A callback function that receives the list of books when the operation succeeds
+   *   or an exception if it fails
+   */
+  fun getBook(callback: (Result<List<DataBook>>) -> Unit)
+
+  /**
+   * Function to add a new book to the repository
+   *
+   * @param dataBook The book data to be added
+   * @param callback A callback function that receives an exception if the operation fails
+   */
+  fun addBook(dataBook: DataBook, callback: (Result<Unit>) -> Unit)
+
+  /**
+   * Function to update an existing book in the repository.
+   *
+   * @param dataBook The book data to be updated
+   * @param callback A callback function that receives an exception if the operation fails
+   */
+  fun updateBook(dataBook: DataBook, callback: (Result<Unit>) -> Unit)
+
+  /**
+   * Function to delete a book from the repository.
+   *
+   * @param uuid The unique identifier of the book to be deleted.
+   * @param dataBook The book data to be deleted (can also just use the uuid).
+   * @param callback A callback function that receives an exception if the operation fails.
+   */
+  fun deleteBooks(uuid: UUID, dataBook: DataBook, callback: (Result<Unit>) -> Unit)
+
+  fun getBooksList(bookList: List<UUID>, callback: (Result<Unit>) -> Unit): List<DataBook>
+}
Index: app/src/main/java/com/android/bookswap/data/DataBook.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/DataBook.kt b/app/src/main/java/com/android/bookswap/data/DataBook.kt
new file mode 100644
--- /dev/null	(date 1731617426313)
+++ b/app/src/main/java/com/android/bookswap/data/DataBook.kt	(date 1731617426313)
@@ -0,0 +1,60 @@
+package com.android.bookswap.data
+
+import java.util.UUID
+
+/**
+ * Represent a book with various properties
+ *
+ * @param uuid Internal uuid for the book
+ * @param title Title of the book
+ * @param author Author of the book
+ * @param description Short description of the book
+ * @param rating Rating of the book out of 5 (if applicable)
+ * @param photo Photo of a book
+ * @param language Language of the book
+ * @param isbn ISBN of the book (International Standard Book Number)
+ */
+data class DataBook(
+    val uuid: UUID,
+    val title: String,
+    val author: String?,
+    val description: String?,
+    val rating: Int?,
+    val photo: String?,
+    val language: BookLanguages,
+    val isbn: String?,
+    val genres: List<BookGenres> = emptyList()
+)
+
+/** All supported book language type */
+enum class BookLanguages(val languageCode: String) {
+  FRENCH("FR"), // French language
+  GERMAN("DE"), // German language
+  ENGLISH("EN"), // English language
+  SPANISH("ES"), // Spanish language
+  ITALIAN("IT"), // Italian language
+  ROMANSH("RM"), // Romansh, a language spoken in Switzerland
+  OTHER("OTHER") // All languages that are not yet implemented
+}
+/** Genre of a book */
+enum class BookGenres(val Genre: String = "Other") {
+  FICTION("Fiction"),
+  NONFICTION("Non-Fiction"),
+  FANTASY("Fantasy"),
+  SCIENCEFICTION("Science-Fiction"),
+  MYSTERY("Mystery"),
+  THRILLER("Thriller"),
+  ROMANCE("Romance"),
+  HORROR("Horror"),
+  HISTORICAL("Historical"),
+  WESTERN("Western"),
+  DYSTOPIAN("Dystopian"),
+  MEMOIR("Memoir"),
+  BIOGRAPHY("Biography"),
+  AUTOBIOGRAPHY("Autobiography"),
+  SELFHELP("Self-Help"),
+  HEALTH("Health"),
+  TRAVEL("Travel"),
+  GUIDE("Guide"),
+  OTHER("Other") // Allows custom genre name
+}
Index: app/src/main/java/com/android/bookswap/ui/books/add/AddToBook.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/books/add/AddToBook.kt b/app/src/main/java/com/android/bookswap/ui/books/add/AddToBook.kt
new file mode 100644
--- /dev/null	(date 1731617426000)
+++ b/app/src/main/java/com/android/bookswap/ui/books/add/AddToBook.kt	(date 1731617426000)
@@ -0,0 +1,346 @@
+package com.android.bookswap.ui.books.add
+
+import android.content.Context
+import android.util.Log
+import android.widget.Toast
+import androidx.compose.foundation.background
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.padding
+import androidx.compose.material3.Button
+import androidx.compose.material3.ButtonDefaults
+import androidx.compose.material3.DropdownMenuItem
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.ExposedDropdownMenuBox
+import androidx.compose.material3.ExposedDropdownMenuDefaults
+import androidx.compose.material3.OutlinedTextField
+import androidx.compose.material3.OutlinedTextFieldDefaults
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.setValue
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.platform.LocalContext
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.unit.dp
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.repository.BooksRepository
+import com.android.bookswap.ui.theme.ColorVariable
+import com.android.bookswap.ui.theme.ColorVariable.BackGround
+import com.android.bookswap.ui.theme.ColorVariable.Primary
+import com.android.bookswap.ui.theme.ColorVariable.Secondary
+import java.util.UUID
+
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun AddToBookScreen(
+    repository: BooksRepository,
+    topAppBar: @Composable () -> Unit = {},
+    bottomAppBar: @Composable () -> Unit = {}
+) {
+  // State variables to store the values entered by the user
+  var title by remember { mutableStateOf("") }
+  var author by remember { mutableStateOf("") }
+  var description by remember { mutableStateOf("") }
+  var rating by remember { mutableStateOf("") }
+  var isbn by remember { mutableStateOf("") }
+  var photo by remember { mutableStateOf("") }
+  var language by remember { mutableStateOf("") }
+  var selectedGenre by remember { mutableStateOf<BookGenres?>(null) } // Genre selection state
+  var expanded by remember { mutableStateOf(false) } // State for dropdown menu
+  // Getting the context for showing Toast messages
+  val context = LocalContext.current
+
+  // Scaffold to provide basic UI structure with a top app bar
+  Scaffold(
+      modifier = Modifier.testTag("addBookScreen").background(BackGround),
+      topBar = topAppBar,
+      bottomBar = bottomAppBar,
+      content = { paddingValues ->
+        // Column layout to stack input fields vertically with spacing
+        Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
+          // Title Input Field
+          OutlinedTextField(
+              value = title,
+              onValueChange = { title = it },
+              label = { Text("Title") },
+              placeholder = { Text("Enter the book title") },
+              modifier =
+                  Modifier.padding(paddingValues)
+                      .testTag("inputBookTitle")
+                      .testTag("Title"), // Light background color inside the ,
+              colors =
+                  OutlinedTextFieldDefaults.colors(
+                      focusedBorderColor = Secondary, // Custom green for focused border
+                      unfocusedBorderColor = Secondary, // Lighter green for unfocused border
+                      cursorColor = Secondary, // Custom green for the cursor
+                      focusedLabelColor = Secondary, // Custom green for focused label
+                      unfocusedLabelColor = Secondary, // Lighter color for unfocused label
+                  ) // Adding padding to the input field
+              )
+
+          // Genre Dropdown
+          ExposedDropdownMenuBox(
+              expanded = expanded,
+              onExpandedChange = { expanded = !expanded },
+              modifier = Modifier.background(ColorVariable.BackGround) // Set background color here
+              ) {
+                OutlinedTextField(
+                    value = selectedGenre?.Genre ?: "Select Genre",
+                    onValueChange = {},
+                    label = { Text("Genre") },
+                    readOnly = true,
+                    trailingIcon = {
+                      ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)
+                    },
+                    modifier = Modifier.menuAnchor())
+                ExposedDropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {
+                  BookGenres.values().forEach { genre ->
+                    DropdownMenuItem(
+                        text = {
+                          Text(
+                              text = genre.Genre,
+                              // color = ColorVariable.Secondary // Green text in dropdownmenu
+                          )
+                        },
+                        onClick = {
+                          selectedGenre = genre
+                          expanded = false
+                        })
+                  }
+                }
+              }
+
+          // Author Input Field
+          OutlinedTextField(
+              value = author,
+              onValueChange = { author = it },
+              label = { Text("Author") },
+              placeholder = { Text("Enter the author's name") },
+              modifier =
+                  Modifier.padding(paddingValues).testTag("inputBookAuthor").testTag("Author"),
+              colors =
+                  OutlinedTextFieldDefaults.colors(
+                      focusedBorderColor = Secondary, // Custom green for focused border
+                      unfocusedBorderColor = Secondary, // Lighter green for unfocused border
+                      cursorColor = Secondary, // Custom green for the cursor
+                      focusedLabelColor = Secondary, // Custom green for focused label
+                      unfocusedLabelColor = Secondary // Lighter color for unfocused label
+                      ) // Adding padding to the input field
+              )
+          // Description Input Field
+          OutlinedTextField(
+              value = description,
+              onValueChange = { description = it },
+              label = { Text("Description") },
+              placeholder = { Text("Provide a description of the book") },
+              modifier = Modifier.testTag("inputBookDescription").testTag("Description"),
+              colors =
+                  OutlinedTextFieldDefaults.colors(
+                      focusedBorderColor = Secondary, // Custom green for focused border
+                      unfocusedBorderColor = Secondary, // Lighter green for unfocused border
+                      cursorColor = Secondary, // Custom green for the cursor
+                      focusedLabelColor = Secondary, // Custom green for focused label
+                      unfocusedLabelColor = Secondary // Lighter color for unfocused label
+                      ))
+          // Rating Input Field
+          OutlinedTextField(
+              value = rating,
+              onValueChange = { rating = it },
+              label = { Text("Rating") },
+              placeholder = { Text("Rate the book (e.g. 4.5)") },
+              modifier = Modifier.testTag("inputBookRating"),
+              colors =
+                  OutlinedTextFieldDefaults.colors(
+                      focusedBorderColor = Secondary, // Custom green for focused border
+                      unfocusedBorderColor = Secondary, // Lighter green for unfocused border
+                      cursorColor = Secondary, // Custom green for the cursor
+                      focusedLabelColor = Secondary, // Custom green for focused label
+                      unfocusedLabelColor = Secondary // Lighter color for unfocused label
+                      ))
+          // ISBN Input Field
+          OutlinedTextField(
+              value = isbn,
+              onValueChange = { isbn = it },
+              label = { Text("ISBN") },
+              placeholder = { Text("Enter the ISBN") },
+              modifier = Modifier.testTag("inputBookISBN").testTag("ISBN"),
+              colors =
+                  OutlinedTextFieldDefaults.colors(
+                      focusedBorderColor = Secondary, // Custom green for focused border
+                      unfocusedBorderColor = Secondary, // Lighter green for unfocused border
+                      cursorColor = Secondary, // Custom green for the cursor
+                      focusedLabelColor = Secondary, // Custom green for focused label
+                      unfocusedLabelColor = Secondary // Lighter color for unfocused label
+                      ))
+          // Photo  Input Field
+          OutlinedTextField(
+              value = photo,
+              onValueChange = { photo = it },
+              label = { Text("Photo ") },
+              placeholder = { Text("Enter a photo of the books") },
+              modifier = Modifier.testTag("inputBookPhoto").testTag("Photo"),
+              colors =
+                  OutlinedTextFieldDefaults.colors(
+                      focusedBorderColor = Secondary, // Custom green for focused border
+                      unfocusedBorderColor = Secondary, // Lighter green for unfocused border
+                      cursorColor = Secondary, // Custom green for the cursor
+                      focusedLabelColor = Secondary, // Custom green for focused label
+                      unfocusedLabelColor = Secondary // Lighter color for unfocused label
+                      ))
+          // Language Input Field
+          OutlinedTextField(
+              value = language,
+              onValueChange = { language = it },
+              label = { Text("Language ") },
+              placeholder = { Text("In which language are the book") },
+              modifier = Modifier.testTag("inputBookLanguage").testTag("Language"),
+              colors =
+                  OutlinedTextFieldDefaults.colors(
+                      focusedBorderColor = Secondary, // Custom green for focused border
+                      unfocusedBorderColor = Secondary, // Lighter green for unfocused border
+                      cursorColor = Secondary, // Custom green for the cursor
+                      focusedLabelColor = Secondary, // Custom green for focused label
+                      unfocusedLabelColor = Secondary // Lighter color for unfocused label
+                      ))
+          // Save Button
+          Button(
+              colors =
+                  ButtonDefaults.buttonColors(
+                      containerColor = Primary, // Light green
+                      contentColor = BackGround),
+              onClick = {
+                // Check if title and ISBN are not blank (required fields)
+                if (title.isNotBlank() && isbn.isNotBlank() && selectedGenre != null) {
+                  // You can handle book object creation here (e.g., save the book)
+                  val book =
+                      createDataBook(
+                          context,
+                          repository.getNewUUID(),
+                          title,
+                          author,
+                          description,
+                          rating,
+                          photo,
+                          language,
+                          isbn,
+                          listOf(selectedGenre!!))
+                  if (book == null) {
+                    Toast.makeText(context, "Invalid argument", Toast.LENGTH_SHORT).show()
+                  } else {
+                    repository.addBook(book, callback = {})
+                  }
+                } else {
+                  // Show a Toast message if title or ISBN is empty
+                  Toast.makeText(context, "Title and ISBN are required.", Toast.LENGTH_SHORT).show()
+                }
+              },
+              // Enable the button only if title and ISBN are filled
+              enabled = title.isNotBlank() && isbn.isNotBlank(),
+              modifier = Modifier.testTag("bookSave").testTag("Save")) {
+                // Text displayed on the button
+                Text("Save", modifier = Modifier.testTag("bookSave").testTag("Save"))
+              }
+        }
+      })
+}
+
+fun createDataBook(
+    context: Context,
+    uuid: UUID,
+    title: String,
+    author: String,
+    description: String,
+    ratingStr: String,
+    photo: String,
+    bookLanguageStr: String,
+    isbn: String,
+    genres: List<BookGenres>
+): DataBook? {
+  // Validate UUID
+  if (uuid.toString().isBlank()) {
+    Log.e("AddToBookScreen", "UUID cannot be empty.")
+    Toast.makeText(context, "UUID cannot be empty.", Toast.LENGTH_LONG).show()
+    return null
+  }
+
+  // Validate Title
+  if (title.isBlank()) {
+    Log.e("AddToBookScreen", "Title cannot be empty.")
+    Toast.makeText(context, "Title cannot be empty.", Toast.LENGTH_LONG).show()
+
+    return null
+  }
+
+  // Validate Author
+  if (author.isBlank()) {
+    Log.e("AddToBookScreen", "Author cannot be empty.")
+    Toast.makeText(context, "Author cannot be empty.", Toast.LENGTH_LONG).show()
+
+    return null
+  }
+
+  // Validate Rating
+  val rating: Int =
+      try {
+        ratingStr.toInt().also {
+          if (it !in 0..5) {
+            Log.e("AddToBookScreen", "Rating must be between 0 and 5.")
+            Toast.makeText(context, "Rating must be between 0 and 5.", Toast.LENGTH_LONG).show()
+
+            return null
+          }
+        }
+      } catch (e: NumberFormatException) {
+        Log.e("AddToBookScreen", "Rating must be a valid number.")
+        Toast.makeText(context, "Rating must be a valid number.", Toast.LENGTH_LONG).show()
+
+        return null
+      }
+
+  // Validate Photo (assuming basic validation here, just checking if not empty)
+  if (photo.isBlank()) {
+    Log.e("AddToBookScreen", "Photo URL cannot be empty.")
+    Toast.makeText(context, "Photo URL cannot be empty.", Toast.LENGTH_LONG).show()
+
+    return null
+  }
+
+  // Validate Language
+  val languages: BookLanguages =
+      try {
+        BookLanguages.valueOf(bookLanguageStr.uppercase())
+      } catch (e: IllegalArgumentException) {
+        Log.e(
+            "AddToBookScreen",
+            "Invalid language: $bookLanguageStr. Please use one of the supported languages.")
+        Toast.makeText(context, "Invalid language: $bookLanguageStr.", Toast.LENGTH_LONG).show()
+
+        return null
+      }
+
+  // Validate ISBN
+  if (isbn.isBlank()) {
+    Log.e("AddToBookScreen", "ISBN cannot be empty.")
+    Toast.makeText(context, "ISBN cannot be empty.", Toast.LENGTH_LONG).show()
+
+    return null
+  }
+
+  // If all validations pass, return a new DataBook instance
+  return DataBook(
+      uuid = uuid,
+      title = title,
+      author = author,
+      description = description,
+      rating = rating,
+      photo = photo,
+      language = languages,
+      isbn = isbn,
+      genres = genres)
+}
Index: app/src/main/java/com/android/bookswap/ui/chat/ListChat.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/chat/ListChat.kt b/app/src/main/java/com/android/bookswap/ui/chat/ListChat.kt
new file mode 100644
--- /dev/null	(date 1731615667000)
+++ b/app/src/main/java/com/android/bookswap/ui/chat/ListChat.kt	(date 1731615667000)
@@ -0,0 +1,134 @@
+package com.android.bookswap.ui.chat
+
+import androidx.compose.foundation.background
+import androidx.compose.foundation.border
+import androidx.compose.foundation.clickable
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.fillMaxHeight
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.filled.Person
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.HorizontalDivider
+import androidx.compose.material3.Icon
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.text.font.FontWeight
+import androidx.compose.ui.text.style.TextAlign
+import androidx.compose.ui.text.style.TextOverflow
+import androidx.compose.ui.unit.dp
+import androidx.compose.ui.unit.sp
+import com.android.bookswap.data.MessageBox
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.navigation.Screen
+import com.android.bookswap.ui.theme.ColorVariable
+
+/** This is the main screen for the chat feature. It displays the list of messages */
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun ListChatScreen(
+    placeHolderData: List<MessageBox> = emptyList(),
+    navigationActions: NavigationActions,
+    topAppBar: @Composable () -> Unit = {},
+    bottomAppBar: @Composable () -> Unit = {},
+) {
+  Scaffold(
+      modifier = Modifier.testTag("chat_listScreen"),
+      topBar = topAppBar,
+      content = { pv ->
+        LazyColumn(
+            contentPadding = pv,
+            modifier =
+                Modifier.fillMaxSize()
+                    .background(color = ColorVariable.BackGround)
+                    .testTag("chat_messageList")) {
+              item { MessageDivider() }
+              if (placeHolderData.isEmpty()) {
+                item {
+                  Text(
+                      text = "No messages yet",
+                      modifier = Modifier.fillMaxWidth().padding(16.dp),
+                      color = ColorVariable.Primary,
+                      fontSize = 20.sp,
+                      fontWeight = FontWeight.Bold,
+                      textAlign = TextAlign.Center)
+                }
+              } else {
+                items(placeHolderData.size) { message ->
+                  MessageBoxDisplay(placeHolderData[message]) {
+                    navigationActions.navigateTo(
+                        Screen.CHAT, placeHolderData[message].contact.userUUID.toString())
+                  }
+                  MessageDivider()
+                }
+              }
+            }
+      },
+      bottomBar = bottomAppBar)
+}
+
+/*
+This function is used to display the message box
+ */
+@Composable
+fun MessageBoxDisplay(message: MessageBox, onClick: () -> Unit = {}) {
+  Row(
+      Modifier.fillMaxWidth()
+          .height(55.dp)
+          .background(color = ColorVariable.BackGround)
+          .clickable(onClick = onClick)
+          .testTag("chat_messageBox"),
+  ) {
+    Icon(
+        imageVector = Icons.Filled.Person,
+        contentDescription = "Contact Icon",
+        modifier = Modifier.size(40.dp).align(Alignment.CenterVertically).fillMaxHeight(),
+    )
+    Column(
+        modifier = Modifier.weight(1f).padding(start = 8.dp, end = 8.dp, top = 4.dp),
+        verticalArrangement = Arrangement.Center) {
+          Row(
+              modifier = Modifier.fillMaxWidth(),
+              horizontalArrangement = Arrangement.SpaceBetween) {
+                Text(
+                    text = message.contact.firstName + " " + message.contact.lastName,
+                    fontWeight = FontWeight.Medium,
+                    fontSize = 18.sp,
+                    color = ColorVariable.Accent,
+                    modifier = Modifier.testTag("chat_messageContactName"))
+                Text(
+                    text = message.date,
+                    fontSize = 14.sp,
+                    color = ColorVariable.AccentSecondary,
+                    modifier = Modifier.testTag("chat_messageDate"))
+              }
+
+          Text(
+              text = message.message,
+              fontSize = 14.sp,
+              color = ColorVariable.AccentSecondary,
+              maxLines = 1,
+              overflow = TextOverflow.Ellipsis,
+              modifier = Modifier.testTag("chat_messageContent"))
+        }
+  }
+}
+
+/** This function is used to display a divider between the messages */
+@Composable
+fun MessageDivider() {
+  HorizontalDivider(
+      modifier = Modifier.fillMaxWidth().border(width = 2.dp, color = Color(0xFF6C584C)))
+}
Index: app/src/main/java/com/android/bookswap/ui/chat/ChatScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/chat/ChatScreen.kt b/app/src/main/java/com/android/bookswap/ui/chat/ChatScreen.kt
new file mode 100644
--- /dev/null	(date 1731617442000)
+++ b/app/src/main/java/com/android/bookswap/ui/chat/ChatScreen.kt	(date 1731617442000)
@@ -0,0 +1,447 @@
+package com.android.bookswap.ui.chat
+
+import android.util.Log
+import android.widget.Toast
+import androidx.compose.foundation.ExperimentalFoundationApi
+import androidx.compose.foundation.Image
+import androidx.compose.foundation.background
+import androidx.compose.foundation.border
+import androidx.compose.foundation.clickable
+import androidx.compose.foundation.combinedClickable
+import androidx.compose.foundation.gestures.detectTransformGestures
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.layout.widthIn
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.foundation.lazy.items
+import androidx.compose.foundation.shape.CircleShape
+import androidx.compose.foundation.shape.RoundedCornerShape
+import androidx.compose.foundation.text.BasicTextField
+import androidx.compose.material3.Button
+import androidx.compose.material3.ButtonColors
+import androidx.compose.material3.Card
+import androidx.compose.material3.CardColors
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.IconButton
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.Text
+import androidx.compose.material3.TopAppBar
+import androidx.compose.material3.TopAppBarDefaults
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.LaunchedEffect
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableFloatStateOf
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.setValue
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.draw.clip
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.graphics.graphicsLayer
+import androidx.compose.ui.input.pointer.pointerInput
+import androidx.compose.ui.layout.ContentScale
+import androidx.compose.ui.platform.LocalConfiguration
+import androidx.compose.ui.platform.LocalContext
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.res.painterResource
+import androidx.compose.ui.text.input.TextFieldValue
+import androidx.compose.ui.unit.dp
+import androidx.compose.ui.window.Popup
+import coil.compose.AsyncImage
+import com.android.bookswap.R
+import com.android.bookswap.data.DataMessage
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.MessageType
+import com.android.bookswap.data.repository.MessageRepository
+import com.android.bookswap.ui.components.BackButtonComponent
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.theme.ColorVariable
+import java.text.SimpleDateFormat
+import java.util.Date
+import java.util.Locale
+import java.util.UUID
+import kotlinx.coroutines.delay
+
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun ChatScreen(
+    messageRepository: MessageRepository,
+    currentUser: DataUser,
+    otherUser: DataUser,
+    navController: NavigationActions
+) {
+  val context = LocalContext.current
+  var messages by remember { mutableStateOf(emptyList<DataMessage>()) }
+  var newMessageText by remember { mutableStateOf(TextFieldValue("")) }
+  var selectedMessage by remember { mutableStateOf<DataMessage?>(null) }
+  var updateActive by remember { mutableStateOf(false) }
+  val padding8 = 8.dp
+  val padding24 = 24.dp
+  val padding36 = 36.dp
+  LaunchedEffect(Unit) {
+    while (true) {
+      messageRepository.getMessages { result ->
+        if (result.isSuccess) {
+          messages =
+              result
+                  .getOrThrow()
+                  .filter {
+                    (it.senderUUID == currentUser.userUUID &&
+                        it.receiverUUID == otherUser.userUUID) ||
+                        (it.senderUUID == otherUser.userUUID &&
+                            it.receiverUUID == currentUser.userUUID)
+                  }
+                  .sortedBy { it.timestamp }
+          Log.d("ChatScreen", "Fetched messages: $messages")
+        } else {
+          Log.e("ChatScreen", "Failed to fetch messages: ${result.exceptionOrNull()?.message}")
+        }
+      }
+      delay(2000) // Delay for 2 seconds
+    }
+  }
+  Box(modifier = Modifier.fillMaxSize().background(ColorVariable.BackGround)) {
+    Column(modifier = Modifier.fillMaxSize()) {
+      TopAppBar(
+          title = {
+            Text(
+                text = otherUser.firstName + " " + otherUser.lastName,
+                style = MaterialTheme.typography.titleMedium,
+                color = ColorVariable.Accent,
+                modifier =
+                    Modifier.testTag("chatName")
+                        .align(Alignment.CenterHorizontally)
+                        .padding(start = padding24))
+          },
+          navigationIcon = { BackButtonComponent(navController) },
+          actions = {
+            IconButton(onClick = { /* Handle profile icon click */}) {
+              AsyncImage(
+                  model = otherUser.profilePictureUrl,
+                  contentDescription = "Profile Picture",
+                  contentScale = ContentScale.Crop,
+                  modifier = Modifier.testTag("profileIcon").size(padding36).clip(CircleShape))
+            }
+          },
+          colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent),
+          modifier = Modifier.testTag("chatTopAppBar"))
+      Column(modifier = Modifier.fillMaxSize(), verticalArrangement = Arrangement.SpaceBetween) {
+        // Message list
+        LazyColumn(
+            modifier = Modifier.weight(1f).padding(padding8).testTag("column"),
+            verticalArrangement = Arrangement.Bottom) {
+              items(messages) { message ->
+                MessageItem(
+                    message = message,
+                    currentUserUUID = currentUser.userUUID,
+                    onLongPress = { selectedMessage = message })
+              }
+            }
+
+        // Message input field and send button
+        Row(
+            modifier =
+                Modifier.fillMaxWidth().padding(top = padding8).background(ColorVariable.Primary),
+            verticalAlignment = Alignment.CenterVertically) {
+              BasicTextField(
+                  value = newMessageText,
+                  onValueChange = { newMessageText = it },
+                  modifier =
+                      Modifier.weight(1f)
+                          .padding(padding8)
+                          .background(ColorVariable.Secondary, MaterialTheme.shapes.small)
+                          .border(1.dp, ColorVariable.Accent, MaterialTheme.shapes.small)
+                          .padding(padding8)
+                          .testTag("message_input_field"),
+              )
+              Button(
+                  onClick = {
+                    if (updateActive) {
+                      // Update the message
+                      messageRepository.updateMessage(
+                          selectedMessage!!.copy(text = newMessageText.text),
+                          { result: Result<Unit> ->
+                            if (result.isSuccess) {
+                              Log.d("ChatScreen", "Message updated successfully")
+                              selectedMessage = null
+                              newMessageText = TextFieldValue("")
+                              updateActive = false
+                            } else {
+                              Log.e(
+                                  "ChatScreen",
+                                  "Failed to update message: ${result.exceptionOrNull()?.message}")
+                              selectedMessage = null
+                              newMessageText = TextFieldValue("")
+                              updateActive = false
+                            }
+                          },
+                          context)
+                    } else {
+                      // Send a new message
+                      val messageId = messageRepository.getNewUUID()
+                      val newMessage =
+                          DataMessage(
+                              messageType = MessageType.TEXT,
+                              uuid = messageId,
+                              text = newMessageText.text,
+                              senderUUID = currentUser.userUUID,
+                              receiverUUID = otherUser.userUUID, // Ensure receiverId is set here
+                              timestamp = System.currentTimeMillis())
+                      // Send the message
+                      messageRepository.sendMessage(
+                          message = newMessage,
+                      ) { result ->
+                        if (result.isSuccess) {
+                          newMessageText = TextFieldValue("")
+                        } else {
+                          Toast.makeText(context, "Message could not be sent.", Toast.LENGTH_LONG)
+                              .show()
+                          Log.e(
+                              "MessageView",
+                              "Failed to send message: ${result.exceptionOrNull()?.message}")
+                        }
+                      }
+                    }
+                  },
+                  colors =
+                      ButtonColors(
+                          ColorVariable.Secondary,
+                          ColorVariable.Accent,
+                          ColorVariable.Secondary,
+                          ColorVariable.Accent),
+                  modifier = Modifier.padding(horizontal = padding8).testTag("send_button")) {
+                    Text(if (updateActive) "Update" else "Send")
+                  }
+            }
+      }
+    }
+    if (!updateActive) {
+      selectedMessage?.let { message ->
+        Popup(
+            alignment = Alignment.Center,
+            onDismissRequest = {
+              if (!updateActive) {
+                selectedMessage = null
+              }
+            }) {
+              Column(
+                  modifier =
+                      Modifier.background(ColorVariable.Primary, shape = RoundedCornerShape(8.dp))
+                          .border(2.dp, ColorVariable.Accent, shape = RoundedCornerShape(8.dp))
+                          .padding(padding8),
+                  verticalArrangement = Arrangement.Center,
+                  horizontalAlignment = Alignment.CenterHorizontally) {
+                    Button(
+                        onClick = {
+                          // Handle edit
+                          newMessageText = TextFieldValue(message.text)
+                          updateActive = true
+                        },
+                        modifier =
+                            Modifier.background(
+                                    ColorVariable.Primary, shape = RoundedCornerShape(50))
+                                .padding(padding8)
+                                .testTag("editButton")) {
+                          Text("Edit")
+                        }
+                    Button(
+                        onClick = {
+                          // Handle delete
+                          selectedMessage?.let { message ->
+                            messageRepository.deleteMessage(
+                                message.uuid,
+                                { result ->
+                                  if (result.isSuccess) {
+                                    Log.d("ChatScreen", "Message deleted successfully")
+                                    selectedMessage = null
+                                  } else {
+                                    Log.e(
+                                        "ChatScreen",
+                                        "Failed to delete message: ${result.exceptionOrNull()?.message}")
+                                  }
+                                },
+                                context)
+                          }
+                        },
+                        modifier =
+                            Modifier.background(
+                                    ColorVariable.Primary, shape = RoundedCornerShape(50))
+                                .padding(padding8)
+                                .testTag("deleteButton")) {
+                          Text("Delete")
+                        }
+                  }
+            }
+      }
+    }
+  }
+}
+
+@OptIn(ExperimentalFoundationApi::class)
+@Composable
+fun MessageItem(message: DataMessage, currentUserUUID: UUID, onLongPress: () -> Unit) {
+  val isCurrentUser = message.senderUUID == currentUserUUID
+  val cornerRadius = 25.dp
+  val padding8 = 8.dp
+  val padding16 = 16.dp
+  val imagePopUp = 300.dp
+  val shape =
+      if (isCurrentUser) {
+        RoundedCornerShape(
+            topStart = cornerRadius,
+            topEnd = cornerRadius,
+            bottomStart = cornerRadius,
+            bottomEnd = 5.dp)
+      } else {
+        RoundedCornerShape(
+            topStart = cornerRadius,
+            topEnd = cornerRadius,
+            bottomStart = 5.dp,
+            bottomEnd = cornerRadius)
+      }
+  var showPopup by remember { mutableStateOf(false) }
+  var scale by remember { mutableFloatStateOf(1f) }
+  var offsetX by remember { mutableFloatStateOf(0f) }
+  var offsetY by remember { mutableFloatStateOf(0f) }
+
+  Row(
+      modifier = Modifier.fillMaxWidth(),
+      horizontalArrangement = if (isCurrentUser) Arrangement.End else Arrangement.Start) {
+        Card(
+            colors =
+                if (isCurrentUser) {
+                  CardColors(
+                      ColorVariable.Primary,
+                      ColorVariable.Accent,
+                      ColorVariable.Primary,
+                      ColorVariable.Accent)
+                } else {
+                  CardColors(
+                      ColorVariable.Secondary,
+                      ColorVariable.Accent,
+                      ColorVariable.Secondary,
+                      ColorVariable.Accent)
+                },
+            shape = shape,
+            modifier =
+                Modifier.padding(padding8)
+                    .widthIn(max = (LocalConfiguration.current.screenWidthDp.dp * 2 / 3))
+                    .border(1.dp, ColorVariable.Accent, shape)
+                    .combinedClickable(
+                        onClick = {
+                          if (message.messageType == MessageType.IMAGE) showPopup = true
+                        },
+                        onLongClick = { onLongPress() })
+                    .testTag("message_item ${message.uuid}")) {
+              Column(
+                  modifier =
+                      Modifier.padding(16.dp).testTag("message_item_column ${message.uuid}")) {
+                    if (message.uuid != imageTestMessageUUID &&
+                        message.messageType == MessageType.IMAGE) {
+                      AsyncImage(
+                          model = message.text,
+                          contentDescription = "Message Image",
+                          modifier = Modifier.testTag("hobbit"))
+                    } else if (message.uuid == imageTestMessageUUID) {
+                      Image(
+                          painter = painterResource(id = R.drawable.the_hobbit_cover),
+                          contentDescription = "Hobbit",
+                          modifier = Modifier.size(100.dp).testTag("hobbit"))
+                    } else {
+                      Text(
+                          text = message.text,
+                          modifier = Modifier.testTag("message_text ${message.uuid}"),
+                          color = ColorVariable.Accent)
+                    }
+                    Text(
+                        text = formatTimestamp(message.timestamp),
+                        color = ColorVariable.AccentSecondary,
+                        style = MaterialTheme.typography.bodySmall,
+                        modifier =
+                            Modifier.align(Alignment.End)
+                                .testTag("message_timestamp ${message.uuid}"))
+                  }
+            }
+      }
+
+  if (showPopup) {
+    Popup(
+        alignment = Alignment.Center,
+        onDismissRequest = {
+          showPopup = false
+          scale = 1f
+          offsetX = 0f
+          offsetY = 0f
+        }) {
+          Box(
+              modifier =
+                  Modifier.fillMaxSize()
+                      .testTag("popupImage")
+                      .background(Color.Black.copy(alpha = 0.8f))
+                      .clickable {
+                        showPopup = false
+                        scale = 1f
+                        offsetX = 0f
+                        offsetY = 0f
+                      }
+                      .padding(padding16)) {
+                Box(
+                    modifier =
+                        Modifier.align(Alignment.Center)
+                            .size(imagePopUp * scale)
+                            .graphicsLayer(
+                                scaleX = scale,
+                                scaleY = scale,
+                                translationX = offsetX,
+                                translationY = offsetY)) {
+                      if (message.uuid == imageTestMessageUUID) {
+                        Image(
+                            painter = painterResource(id = R.drawable.the_hobbit_cover),
+                            contentDescription = "Hobbit",
+                            modifier = Modifier.size(imagePopUp * scale))
+                      } else
+                          AsyncImage(
+                              model = message.text,
+                              contentDescription = "Enlarged Image",
+                              modifier =
+                                  Modifier.size(imagePopUp * scale)
+                                      .pointerInput(Unit) {
+                                        detectTransformGestures { _, _, zoom, _ -> scale *= zoom }
+                                      }
+                                      .graphicsLayer(
+                                          scaleX = scale,
+                                          scaleY = scale,
+                                          translationX = offsetX,
+                                          translationY = offsetY)
+                                      .testTag("HobbitBig"))
+                    }
+              }
+        }
+  }
+}
+
+fun formatTimestamp(timestamp: Long): String {
+  val messageDate = Date(timestamp)
+  val currentDate = Date()
+  val dateFormat = SimpleDateFormat("yyyyMMdd", Locale.getDefault())
+  val timeFormat = SimpleDateFormat("HH:mm", Locale.getDefault())
+  val dateTimeFormat = SimpleDateFormat("MMM dd, yyyy", Locale.getDefault())
+
+  return if (dateFormat.format(messageDate) == dateFormat.format(currentDate)) {
+    timeFormat.format(messageDate)
+  } else {
+    dateTimeFormat.format(messageDate)
+  }
+}
+
+val imageTestMessageUUID: UUID =
+    UUID.fromString(
+        "11111111-aa16-43d1-8c47-082ac787f755") // Placeholder message for testing image (adapted to
+                                                // use UUID)
Index: app/src/main/res/mipmap-anydpi/ic_launcher_round.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/mipmap-anydpi/ic_launcher_round.xml b/app/src/main/res/mipmap-anydpi/ic_launcher_round.xml
new file mode 100644
--- /dev/null	(date 1730306755526)
+++ b/app/src/main/res/mipmap-anydpi/ic_launcher_round.xml	(date 1730306755526)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
+    <background android:drawable="@drawable/ic_launcher_background" />
+    <foreground android:drawable="@drawable/ic_launcher_foreground" />
+    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
+</adaptive-icon>
\ No newline at end of file
Index: app/src/main/res/mipmap-anydpi/ic_launcher.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/mipmap-anydpi/ic_launcher.xml b/app/src/main/res/mipmap-anydpi/ic_launcher.xml
new file mode 100644
--- /dev/null	(date 1730306755526)
+++ b/app/src/main/res/mipmap-anydpi/ic_launcher.xml	(date 1730306755526)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
+    <background android:drawable="@drawable/ic_launcher_background" />
+    <foreground android:drawable="@drawable/ic_launcher_foreground" />
+    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
+</adaptive-icon>
\ No newline at end of file
Index: app/src/main/res/drawable/ic_launcher_foreground.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/drawable/ic_launcher_foreground.xml b/app/src/main/res/drawable/ic_launcher_foreground.xml
new file mode 100644
--- /dev/null	(date 1730306755525)
+++ b/app/src/main/res/drawable/ic_launcher_foreground.xml	(date 1730306755525)
@@ -0,0 +1,30 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:aapt="http://schemas.android.com/aapt"
+    android:width="108dp"
+    android:height="108dp"
+    android:viewportWidth="108"
+    android:viewportHeight="108">
+    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
+        <aapt:attr name="android:fillColor">
+            <gradient
+                android:endX="85.84757"
+                android:endY="92.4963"
+                android:startX="42.9492"
+                android:startY="49.59793"
+                android:type="linear">
+                <item
+                    android:color="#44000000"
+                    android:offset="0.0" />
+                <item
+                    android:color="#00000000"
+                    android:offset="1.0" />
+            </gradient>
+        </aapt:attr>
+    </path>
+    <path
+        android:fillColor="#FFFFFF"
+        android:fillType="nonZero"
+        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
+        android:strokeWidth="1"
+        android:strokeColor="#00000000" />
+</vector>
\ No newline at end of file
Index: app/src/main/res/drawable/ic_launcher_background.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/drawable/ic_launcher_background.xml b/app/src/main/res/drawable/ic_launcher_background.xml
new file mode 100644
--- /dev/null	(date 1730306755525)
+++ b/app/src/main/res/drawable/ic_launcher_background.xml	(date 1730306755525)
@@ -0,0 +1,170 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="108dp"
+    android:height="108dp"
+    android:viewportWidth="108"
+    android:viewportHeight="108">
+    <path
+        android:fillColor="#3DDC84"
+        android:pathData="M0,0h108v108h-108z" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M9,0L9,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,0L19,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M29,0L29,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M39,0L39,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M49,0L49,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M59,0L59,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M69,0L69,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M79,0L79,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M89,0L89,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M99,0L99,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,9L108,9"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,19L108,19"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,29L108,29"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,39L108,39"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,49L108,49"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,59L108,59"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,69L108,69"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,79L108,79"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,89L108,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,99L108,99"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,29L89,29"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,39L89,39"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,49L89,49"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,59L89,59"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,69L89,69"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,79L89,79"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M29,19L29,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M39,19L39,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M49,19L49,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M59,19L59,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M69,19L69,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M79,19L79,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+</vector>
Index: app/src/main/java/com/android/bookswap/ui/profile/profileIcon.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/profile/profileIcon.kt b/app/src/main/java/com/android/bookswap/ui/profile/profileIcon.kt
new file mode 100644
--- /dev/null	(date 1731615667852)
+++ b/app/src/main/java/com/android/bookswap/ui/profile/profileIcon.kt	(date 1731615667852)
@@ -0,0 +1,27 @@
+package com.android.bookswap.ui.profile
+
+import androidx.compose.foundation.layout.size
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.filled.AccountCircle
+import androidx.compose.material3.Icon
+import androidx.compose.material3.IconButton
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.unit.dp
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.theme.ColorVariable
+
+/** Profile Icon for the top app bar */
+@Composable
+fun ProfileIcon(navigationActions: NavigationActions) {
+  IconButton(
+      onClick = { navigationActions.navigateTo("Profile Screen") },
+      modifier = Modifier.testTag("profileIconButton")) {
+        Icon(
+            Icons.Filled.AccountCircle,
+            contentDescription = "Profile Icon",
+            tint = ColorVariable.Accent,
+            modifier = Modifier.size(32.dp).testTag("profileIcon"))
+      }
+}
Index: app/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/values/strings.xml b/app/src/main/res/values/strings.xml
new file mode 100644
--- /dev/null	(date 1731615667856)
+++ b/app/src/main/res/values/strings.xml	(date 1731615667856)
@@ -0,0 +1,8 @@
+<resources>
+    <string name="app_name">BookSwapApp</string>
+    <string name="title_activity_main">MainActivity</string>
+    <string name="default_web_client_id">53350524991-rim3tpfdgv2ghibl586ku7fvq6ngcddn.apps.googleusercontent.com</string>
+    <string name="prompt">You are an AI designed to analyze images of book covers. Given an image of a book\'s back cover in URL format, extract the following information in a structured format (JSON) with the specified fields: title, author, description, language, and ISBN. Please ensure that: 1. If any of the fields are not present or cannot be confidently identified, indicate them with \"N/A\". 2. If the image does not appear to be a book cover, return an error message stating \"The image does not appear to be a valid book cover.\" 3. If the title, author, description, or other fields are in a different language, keep the original text for reference, and provide the appropriate language code using the following classification: - FRENCH (\"FR\") - GERMAN (\"DE\") - ENGLISH (\"EN\") - SPANISH (\"ES\") - ITALIAN (\"IT\") - ROMANSH (\"RM\") - OTHER (\"OTHER\") 4. The description should be the one written on the book\'s. 5. The ISBN is often over a barcode, in the bottom left or right corner. Example output format: { \"title\": \"Example Title\", \"author\": \"Example Author\", \"description\": \"An example description of the book.\", \"language\": \"EN\", \"isbn\": \"1234567890\" } The image URL:
+</string>
+
+</resources>
\ No newline at end of file
Index: app/src/main/java/com/android/bookswap/model/map/DefaultGeolocation.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/map/DefaultGeolocation.kt b/app/src/main/java/com/android/bookswap/model/map/DefaultGeolocation.kt
new file mode 100644
--- /dev/null	(date 1731615667000)
+++ b/app/src/main/java/com/android/bookswap/model/map/DefaultGeolocation.kt	(date 1731615667000)
@@ -0,0 +1,42 @@
+package com.android.bookswap.model.map
+
+import android.util.Log
+import androidx.compose.runtime.mutableStateOf
+import kotlinx.coroutines.flow.MutableStateFlow
+
+/**
+ * Mock implementation of [IGeolocation] for testing purposes.
+ *
+ * This class provides hardcoded latitude and longitude values and does not interact with real
+ * location services. It is useful for testing UI components that rely on geolocation data without
+ * requiring actual GPS hardware or permissions.
+ *
+ * Usage:
+ * - This can be passed as a dependency to classes or Composables expecting an [IGeolocation]
+ *   implementation, allowing the testing of location-dependent functionality in a controlled
+ *   environment.
+ */
+class DefaultGeolocation : IGeolocation {
+  override val latitude = MutableStateFlow(0.0)
+  override val longitude = MutableStateFlow(0.0)
+  private val isRunning = mutableStateOf(false)
+
+  override fun startLocationUpdates() {
+    isRunning.value = true
+    Log.d("DefaultGeolocation", "Using default geolocation start")
+  }
+
+  override fun stopLocationUpdates() {
+    isRunning.value = false
+    Log.d("DefaultGeolocation", "Using default geolocation stop")
+  }
+
+  fun moveLocation(latitude: Double, longitude: Double) {
+    if (isRunning.value) {
+      this.latitude.value = latitude
+      this.longitude.value = longitude
+    } else {
+      Log.d("DefaultGeolocation", "Location updates are not running")
+    }
+  }
+}
Index: app/src/main/res/xml/data_extraction_rules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/xml/data_extraction_rules.xml b/app/src/main/res/xml/data_extraction_rules.xml
new file mode 100644
--- /dev/null	(date 1730306755528)
+++ b/app/src/main/res/xml/data_extraction_rules.xml	(date 1730306755528)
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+   Sample data extraction rules file; uncomment and customize as necessary.
+   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
+   for details.
+-->
+<data-extraction-rules>
+    <cloud-backup>
+        <!-- TODO: Use <include> and <exclude> to control what is backed up.
+        <include .../>
+        <exclude .../>
+        -->
+    </cloud-backup>
+    <!--
+    <device-transfer>
+        <include .../>
+        <exclude .../>
+    </device-transfer>
+    -->
+</data-extraction-rules>
\ No newline at end of file
Index: app/src/main/res/xml/backup_rules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/xml/backup_rules.xml b/app/src/main/res/xml/backup_rules.xml
new file mode 100644
--- /dev/null	(date 1730306755527)
+++ b/app/src/main/res/xml/backup_rules.xml	(date 1730306755527)
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+   Sample backup rules file; uncomment and customize as necessary.
+   See https://developer.android.com/guide/topics/data/autobackup
+   for details.
+   Note: This file is ignored for devices older that API 31
+   See https://developer.android.com/about/versions/12/backup-restore
+-->
+<full-backup-content>
+    <!--
+   <include domain="sharedpref" path="."/>
+   <exclude domain="sharedpref" path="device.xml"/>
+-->
+</full-backup-content>
\ No newline at end of file
Index: app/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/.gitignore b/app/.gitignore
new file mode 100644
--- /dev/null	(date 1730306755517)
+++ b/app/.gitignore	(date 1730306755517)
@@ -0,0 +1,5 @@
+./idea
+
+/build
+/app/build
+local.properties
\ No newline at end of file
Index: app/src/test/java/com/android/bookswap/utils/BookUtils.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/utils/BookUtils.kt b/app/src/test/java/com/android/bookswap/utils/BookUtils.kt
new file mode 100644
--- /dev/null	(date 1731617426322)
+++ b/app/src/test/java/com/android/bookswap/utils/BookUtils.kt	(date 1731617426322)
@@ -0,0 +1,15 @@
+package com.android.bookswap.utils
+
+import com.android.bookswap.data.DataBook
+import org.junit.Assert.assertEquals
+
+/**
+ * Assert that two books are identical (uuid can be checked or not)
+ *
+ * @param expected the expected result
+ * @param result the result
+ * @param strict true if the two books should have the same UUID
+ */
+fun assertBookEquals(expected: DataBook, result: DataBook?, strict: Boolean = false) {
+  assertEquals(expected, if (strict) result else result?.copy(uuid = expected.uuid))
+}
Index: app/src/main/res/values/themes.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/values/themes.xml b/app/src/main/res/values/themes.xml
new file mode 100644
--- /dev/null	(date 1730306755527)
+++ b/app/src/main/res/values/themes.xml	(date 1730306755527)
@@ -0,0 +1,16 @@
+<resources xmlns:tools="http://schemas.android.com/tools">
+    <!-- Base application theme. -->
+    <style name="Theme.BookSwapApp" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
+        <!-- Primary brand color. -->
+        <item name="colorPrimary">@color/purple_500</item>
+        <item name="colorPrimaryVariant">@color/purple_700</item>
+        <item name="colorOnPrimary">@color/white</item>
+        <!-- Secondary brand color. -->
+        <item name="colorSecondary">@color/teal_200</item>
+        <item name="colorSecondaryVariant">@color/teal_700</item>
+        <item name="colorOnSecondary">@color/black</item>
+        <!-- Status bar color. -->
+        <item name="android:statusBarColor">?attr/colorPrimaryVariant</item>
+        <!-- Customize your theme here. -->
+    </style>
+</resources>
\ No newline at end of file
Index: app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreSourceTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreSourceTest.kt b/app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreSourceTest.kt
new file mode 100644
--- /dev/null	(date 1731617442893)
+++ b/app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreSourceTest.kt	(date 1731617442893)
@@ -0,0 +1,160 @@
+package com.android.bookswap.data.source.network
+
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.utils.assertBookEquals
+import com.google.android.gms.tasks.Tasks
+import com.google.firebase.firestore.CollectionReference
+import com.google.firebase.firestore.DocumentReference
+import com.google.firebase.firestore.DocumentSnapshot
+import com.google.firebase.firestore.FirebaseFirestore
+import com.google.firebase.firestore.QuerySnapshot
+import io.mockk.every
+import io.mockk.mockk
+import io.mockk.verify
+import java.util.UUID
+import org.junit.Assert.*
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.RobolectricTestRunner
+
+@RunWith(RobolectricTestRunner::class)
+class BooksFirestoreSourceTest {
+
+  private val mockFirestore: FirebaseFirestore = mockk()
+  private val mockCollectionReference: CollectionReference = mockk()
+  private val mockDocumentReference: DocumentReference = mockk()
+  private val mockDocumentSnapshot: DocumentSnapshot = mockk()
+  private val mockQuerySnapshot: QuerySnapshot = mockk()
+
+  private val testBook =
+      DataBook(
+          uuid = UUID.randomUUID(),
+          title = "Test Book",
+          author = "Test Author",
+          description = "Test Description",
+          rating = 5,
+          photo = "http://example.com/photo.jpg",
+          language = BookLanguages.ENGLISH,
+          isbn = "1234567890")
+
+  @Before
+  fun setUp() {
+    every { mockFirestore.collection(any()) }.returns(mockCollectionReference)
+    every { mockCollectionReference.document(any()) }.returns(mockDocumentReference)
+    every { mockCollectionReference.get() }.returns(Tasks.forResult(mockQuerySnapshot))
+
+    // Mock of snapshot
+    every { mockDocumentSnapshot.getString("title") }.returns(testBook.title)
+    every { mockDocumentSnapshot.getString("author") }.returns(testBook.author)
+    every { mockDocumentSnapshot.getString("description") }.returns(testBook.description)
+    every { mockDocumentSnapshot.getLong("rating") }.returns(testBook.rating?.toLong())
+    every { mockDocumentSnapshot.getString("photo") }.returns(testBook.photo)
+    every { mockDocumentSnapshot.getString("language") }.returns(testBook.language.name)
+    every { mockDocumentSnapshot.getString("isbn") }.returns(testBook.isbn)
+    every { mockDocumentSnapshot.get("genres") }.returns(emptyList<String>())
+    every { mockDocumentSnapshot.getLong("uuid.mostSignificantBits") }
+        .returns(testBook.uuid.mostSignificantBits)
+    every { mockDocumentSnapshot.getLong("uuid.leastSignificantBits") }
+        .returns(testBook.uuid.leastSignificantBits)
+  }
+
+  @Test
+  fun `book get returns correct result`() {
+    val bookSource = BooksFirestoreSource(mockFirestore)
+    bookSource.getBook(
+        callback = { result ->
+          assertTrue(result.isSuccess)
+          val books = result.getOrThrow()
+          // Assert that the fetched books match the expected values
+          assertTrue(books.isNotEmpty())
+          assertBookEquals(books.first(), testBook, true)
+        })
+
+    // Verify that Firestore collection was called
+    verify { mockCollectionReference.get() }
+  }
+
+  @Test
+  fun `delete call firestore delete`() {
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    // Arrange
+    every { mockDocumentReference.delete() }.returns(Tasks.forResult(null))
+
+    // Act
+    bookSource.deleteBooks(testBook.uuid, testBook) {}
+
+    // Assert
+    verify { mockDocumentReference.delete() }
+  }
+
+  @Test
+  fun `book set is success`() {
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    // Arrange
+    every { mockDocumentReference.set(testBook) }.returns(Tasks.forResult(null))
+
+    // Act
+    bookSource.addBook(testBook) { result -> assertTrue(result.isSuccess) }
+
+    // Verify Firestore set operation
+    verify { mockDocumentReference.set(testBook) }
+  }
+
+  @Test
+  fun `book update success`() {
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    // Arrange
+    every { mockDocumentReference.set(testBook) }.returns(Tasks.forResult(null))
+
+    // Act
+    bookSource.updateBook(testBook) { result -> assertTrue(result.isSuccess) }
+
+    // Verify Firestore update operation
+    verify { mockDocumentReference.set(testBook) }
+  }
+
+  @Test
+  fun `documentToBooks is valid`() {
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    // Act
+    val result = bookSource.documentToBooks(mockDocumentSnapshot)
+
+    // Assert
+    assertNotNull(result)
+    assertBookEquals(testBook, result)
+  }
+
+  @Test
+  fun `documentToBooks null when missing value`() {
+    // Arrange - Missing "Title"
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    every { mockDocumentSnapshot.getString("title") }.returns(null)
+
+    // Act
+    val result = bookSource.documentToBooks(mockDocumentSnapshot)
+
+    // Assert
+    assertNull(result)
+  }
+
+  @Test
+  fun `documentToBooks null when invalid value`() {
+    // Arrange - Invalid language value
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    every { mockDocumentSnapshot.getString("language") }.returns("INVALID_LANGUAGE")
+
+    // Act
+    val result = bookSource.documentToBooks(mockDocumentSnapshot)
+
+    // Assert
+    assertNull(result) // Should return null due to invalid language
+  }
+}
Index: app/src/main/java/com/android/bookswap/ui/profile/NewUser.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/profile/NewUser.kt b/app/src/main/java/com/android/bookswap/ui/profile/NewUser.kt
new file mode 100644
--- /dev/null	(date 1731617442892)
+++ b/app/src/main/java/com/android/bookswap/ui/profile/NewUser.kt	(date 1731617442892)
@@ -0,0 +1,272 @@
+package com.android.bookswap.ui.profile
+
+import android.widget.Toast
+import androidx.compose.foundation.background
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.PaddingValues
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.layout.width
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.foundation.text.KeyboardOptions
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.filled.AccountCircle
+import androidx.compose.material3.Button
+import androidx.compose.material3.ButtonDefaults
+import androidx.compose.material3.Card
+import androidx.compose.material3.Icon
+import androidx.compose.material3.IconButton
+import androidx.compose.material3.OutlinedTextField
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.platform.LocalContext
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.text.TextStyle
+import androidx.compose.ui.text.font.FontWeight
+import androidx.compose.ui.text.input.KeyboardType
+import androidx.compose.ui.text.style.TextAlign
+import androidx.compose.ui.unit.dp
+import androidx.compose.ui.unit.sp
+import com.android.bookswap.model.UserViewModel
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.navigation.Route
+import com.android.bookswap.ui.theme.ColorVariable
+import com.google.firebase.Firebase
+import com.google.firebase.auth.auth
+
+// Constants for magic numbers used in the UI layout
+private val CONTENT_PADDING = 16.dp
+private val ICON_SIZE = 80.dp
+private val TEXT_PADDING = PaddingValues(8.dp, 4.dp)
+private val BUTTON_WIDTH = 200.dp
+private val BUTTON_HEIGHT = 50.dp
+private val WELCOME_FONT_SIZE = 40.sp
+private val INFO_FONT_SIZE = 18.sp
+private val WELCOME_FONT_WEIGHT = FontWeight(600)
+private val INFO_FONT_WEIGHT = FontWeight(400)
+private val ERROR_FONT_SIZE = 12.sp
+
+/**
+ * NewUserScreen is the screen where the user can create a new account by filling in his personal
+ * information
+ *
+ * @param navigationActions: NavigationActions
+ */
+@Composable
+fun NewUserScreen(navigationActions: NavigationActions, userVM: UserViewModel) {
+  val context = LocalContext.current
+
+  // État des champs de saisie
+  val email = remember { mutableStateOf("") }
+  val phone = remember { mutableStateOf("") }
+  val greeting = remember { mutableStateOf("") }
+  val firstName = remember { mutableStateOf("") }
+  val lastName = remember { mutableStateOf("") }
+
+  // État des messages d'erreur pour chaque champ
+  val emailError = remember { mutableStateOf<String?>(null) }
+  val phoneError = remember { mutableStateOf<String?>(null) }
+  val firstNameError = remember { mutableStateOf<String?>(null) }
+  val lastNameError = remember { mutableStateOf<String?>(null) }
+
+  // Fonctions de validation
+  fun validateEmail(input: String): Boolean {
+    return android.util.Patterns.EMAIL_ADDRESS.matcher(input).matches()
+  }
+
+  fun validatePhone(input: String): Boolean {
+    return input.matches(
+        Regex("^\\+?\\d{10,15}$")) // Valide les numéros de téléphone de type +4122345678
+  }
+
+  fun validateNonEmpty(input: String): Boolean {
+    return input.isNotBlank()
+  }
+
+  // Fonction pour valider l'ensemble des champs
+  fun validateForm(): Boolean {
+    emailError.value = if (validateEmail(email.value)) null else "Invalid email format"
+    phoneError.value = if (validatePhone(phone.value)) null else "Invalid phone number"
+    firstNameError.value = if (validateNonEmpty(firstName.value)) null else "First name required"
+    lastNameError.value = if (validateNonEmpty(lastName.value)) null else "Last name required"
+
+    // Retourne `true` si tous les champs sont valides, sinon `false`
+    return emailError.value == null &&
+        phoneError.value == null &&
+        firstNameError.value == null &&
+        lastNameError.value == null
+  }
+
+  LazyColumn(
+      contentPadding = PaddingValues(CONTENT_PADDING),
+      modifier =
+          Modifier.fillMaxSize()
+              .background(color = ColorVariable.BackGround)
+              .testTag("NewUserScreen")) {
+        item {
+          Text(
+              "Welcome",
+              modifier = Modifier.testTag("welcomeTxt").fillMaxWidth(),
+              style =
+                  TextStyle(
+                      color = ColorVariable.Accent,
+                      fontWeight = WELCOME_FONT_WEIGHT,
+                      textAlign = TextAlign.Center,
+                      fontSize = WELCOME_FONT_SIZE,
+                  ))
+        }
+        item {
+          // The personal information text
+          Text(
+              "Please fill in your personal information to start BookSwapping",
+              modifier = Modifier.testTag("personalInfoTxt").fillMaxWidth(),
+              style =
+                  TextStyle(
+                      color = ColorVariable.Accent,
+                      fontWeight = INFO_FONT_WEIGHT,
+                      textAlign = TextAlign.Center,
+                      fontSize = INFO_FONT_SIZE,
+                  ))
+        }
+
+        item {
+          // Formulaire d'informations personnelles
+          Card(
+              Modifier.testTag("editProfileContainer").background(ColorVariable.BackGround),
+              colors =
+                  androidx.compose.material3.CardDefaults.cardColors()
+                      .copy(containerColor = ColorVariable.BackGround)) {
+                Column(
+                    Modifier.fillMaxWidth()
+                        .padding(CONTENT_PADDING)
+                        .background(ColorVariable.BackGround),
+                    Arrangement.Center,
+                    Alignment.CenterHorizontally) {
+                      IconButton(
+                          onClick = { /* TODO */},
+                          modifier = Modifier.size(ICON_SIZE).testTag("profilPics")) {
+                            Icon(
+                                imageVector = Icons.Default.AccountCircle,
+                                contentDescription = "profile picture",
+                                tint = ColorVariable.Accent,
+                                modifier = Modifier.size(ICON_SIZE))
+                          }
+                      OutlinedTextField(
+                          greeting.value,
+                          { greeting.value = it },
+                          Modifier.testTag("greetingTF").fillMaxWidth().padding(TEXT_PADDING),
+                          label = { Text("Greeting") },
+                          placeholder = { Text("Mr.", Modifier, Color.Gray) },
+                          keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Text),
+                          singleLine = true)
+
+                      OutlinedTextField(
+                          firstName.value,
+                          { firstName.value = it },
+                          Modifier.testTag("firstnameTF").fillMaxWidth().padding(TEXT_PADDING),
+                          label = { Text("Firstname") },
+                          placeholder = { Text("John", Modifier, Color.Gray) },
+                          keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Text),
+                          singleLine = true,
+                          isError = firstNameError.value != null)
+                      if (firstNameError.value != null) {
+                        Text(
+                            firstNameError.value!!,
+                            color = Color.Red,
+                            fontSize = ERROR_FONT_SIZE,
+                            modifier = Modifier.testTag("firstnameError"))
+                      }
+
+                      OutlinedTextField(
+                          lastName.value,
+                          { lastName.value = it },
+                          Modifier.testTag("lastnameTF").fillMaxWidth().padding(TEXT_PADDING),
+                          label = { Text("Lastname") },
+                          placeholder = { Text("Doe", Modifier, Color.Gray) },
+                          keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Text),
+                          singleLine = true,
+                          isError = lastNameError.value != null)
+                      if (lastNameError.value != null) {
+                        Text(
+                            lastNameError.value!!,
+                            color = Color.Red,
+                            fontSize = ERROR_FONT_SIZE,
+                            modifier = Modifier.testTag("lastnameError"))
+                      }
+
+                      OutlinedTextField(
+                          email.value,
+                          { email.value = it },
+                          Modifier.testTag("emailTF").fillMaxWidth().padding(TEXT_PADDING),
+                          label = { Text("Email") },
+                          placeholder = { Text("John.Doe@example.com", Modifier, Color.Gray) },
+                          keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),
+                          singleLine = true,
+                          isError = emailError.value != null)
+                      if (emailError.value != null) {
+                        Text(
+                            emailError.value!!,
+                            color = Color.Red,
+                            fontSize = ERROR_FONT_SIZE,
+                            modifier = Modifier.testTag("emailError"))
+                      }
+
+                      OutlinedTextField(
+                          phone.value,
+                          { phone.value = it },
+                          Modifier.testTag("phoneTF").fillMaxWidth().padding(TEXT_PADDING),
+                          label = { Text("Phone") },
+                          placeholder = { Text("+4122345678", Modifier, Color.Gray) },
+                          keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Phone),
+                          singleLine = true,
+                          isError = phoneError.value != null)
+                      if (phoneError.value != null) {
+                        Text(
+                            phoneError.value!!,
+                            color = Color.Red,
+                            fontSize = ERROR_FONT_SIZE,
+                            modifier = Modifier.testTag("phoneError"))
+                      }
+                    }
+              }
+        }
+
+        item {
+          Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
+            Button(
+                onClick = {
+                  if (validateForm()) {
+                    userVM.updateUser(
+                        greeting = greeting.value,
+                        firstName = firstName.value,
+                        lastName = lastName.value,
+                        email = email.value,
+                        phone = phone.value,
+                        googleUid = Firebase.auth.currentUser?.uid ?: "")
+                    navigationActions.navigateTo(Route.MAP)
+                  } else {
+                    Toast.makeText(context, "Please correct the errors", Toast.LENGTH_SHORT).show()
+                  }
+                },
+                colors = ButtonDefaults.buttonColors(ColorVariable.Primary),
+                modifier =
+                    Modifier.width(BUTTON_WIDTH).height(BUTTON_HEIGHT).testTag("CreateButton")) {
+                  Text(
+                      text = "Create",
+                      textAlign = TextAlign.Center,
+                      style = TextStyle(color = ColorVariable.BackGround))
+                }
+          }
+        }
+      }
+}
Index: app/src/main/res/values/colors.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/values/colors.xml b/app/src/main/res/values/colors.xml
new file mode 100644
--- /dev/null	(date 1730306755527)
+++ b/app/src/main/res/values/colors.xml	(date 1730306755527)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <color name="purple_200">#FFBB86FC</color>
+    <color name="purple_500">#FF6200EE</color>
+    <color name="purple_700">#FF3700B3</color>
+    <color name="teal_200">#FF03DAC5</color>
+    <color name="teal_700">#FF018786</color>
+    <color name="black">#FF000000</color>
+    <color name="white">#FFFFFFFF</color>
+</resources>
\ No newline at end of file
Index: app/src/main/java/com/android/bookswap/ui/components/BookDisplayComponent.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/components/BookDisplayComponent.kt b/app/src/main/java/com/android/bookswap/ui/components/BookDisplayComponent.kt
new file mode 100644
--- /dev/null	(date 1731617426319)
+++ b/app/src/main/java/com/android/bookswap/ui/components/BookDisplayComponent.kt	(date 1731617426319)
@@ -0,0 +1,146 @@
+package com.android.bookswap.ui.components
+
+import androidx.compose.foundation.background
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.heightIn
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.requiredWidth
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.layout.width
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.filled.Star
+import androidx.compose.material.icons.twotone.Star
+import androidx.compose.material3.Icon
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.draw.clipToBounds
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.text.style.TextOverflow
+import androidx.compose.ui.unit.dp
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.ui.theme.ColorVariable
+
+val PADDING_HORIZONTAL_DP = 4.dp
+val PADDING_VERTICAL_DP = 4.dp
+val IMAGE_HEIGHT_DP = 82.dp
+val IMAGE_WIDTH_DP = 72.dp
+val MAX_RATING = 5
+val STAR_SIZE_DP = 26.dp
+
+@Composable
+fun BookDisplayComponent(modifier: Modifier = Modifier, book: DataBook) {
+  Row(
+      modifier =
+          modifier
+              .fillMaxWidth()
+              .heightIn(
+                  min = IMAGE_HEIGHT_DP + PADDING_VERTICAL_DP * 2,
+                  max = IMAGE_HEIGHT_DP + PADDING_VERTICAL_DP * 2)
+              .padding(PADDING_HORIZONTAL_DP, PADDING_VERTICAL_DP),
+      horizontalArrangement = Arrangement.Start,
+      verticalAlignment = Alignment.CenterVertically) {
+        // Image Box
+        Box(
+            modifier =
+                Modifier.height(IMAGE_HEIGHT_DP)
+                    .width(IMAGE_WIDTH_DP)
+                    .testTag("mapDraggableMenuBookBoxImage"),
+            contentAlignment = Alignment.Center,
+        ) {
+          // Image of the books, will be added at a later date
+          // We didn't discussed about how we will store the image or how we
+          // will
+          // encode them
+          Box(
+              modifier = Modifier.fillMaxSize().background(Color.Gray) // Placeholder for the image
+              )
+        }
+        Row(verticalAlignment = Alignment.CenterVertically) {
+
+          // Column for Title and Author text components
+          Column(
+              modifier =
+                  Modifier.weight(1f, true)
+                      .padding(horizontal = PADDING_HORIZONTAL_DP)
+                      .heightIn(max = IMAGE_HEIGHT_DP + PADDING_VERTICAL_DP * 2)
+                      .testTag("mapDraggableMenuBookBoxMiddle")) {
+                Text(
+                    text = book.title,
+                    overflow = TextOverflow.Ellipsis,
+                    style = MaterialTheme.typography.titleLarge,
+                    color = ColorVariable.Accent,
+                    modifier =
+                        Modifier.weight(1f, true)
+                            // .padding(bottom = PADDING_VERTICAL_DP)
+                            .testTag("mapDraggableMenuBookBoxTitle"))
+                Text(
+                    text = book.author ?: "",
+                    overflow = TextOverflow.Ellipsis,
+                    color = ColorVariable.AccentSecondary,
+                    maxLines = 1,
+                    modifier = Modifier.testTag("mapDraggableMenuBookBoxAuthor"))
+              }
+
+          // Column for rating and genres
+          Column(
+              modifier =
+                  Modifier.requiredWidth(STAR_SIZE_DP * MAX_RATING + PADDING_HORIZONTAL_DP * 2)
+                      .width(STAR_SIZE_DP * MAX_RATING + PADDING_HORIZONTAL_DP * 2)
+                      .testTag("mapDraggableMenuBookRight"),
+              horizontalAlignment = Alignment.CenterHorizontally) {
+                Row(
+                    modifier = Modifier.fillMaxWidth().testTag("mapDraggableMenuBookBoxRating"),
+                    horizontalArrangement = Arrangement.Center) {
+                      // leave all stars empty if no rating
+                      DisplayStarReview(book.rating ?: 0)
+                    }
+                // text for the tags of the book, will be added at a later date
+                // It isn't decided how we will handle the tag for the books
+                Text(
+                    text = book.genres.joinToString(separator = ", ") { it.Genre },
+                    modifier =
+                        Modifier.fillMaxWidth()
+                            .clipToBounds()
+                            .testTag("mapDraggableMenuBookBoxTag"),
+                    overflow = TextOverflow.Ellipsis,
+                    color = ColorVariable.AccentSecondary)
+              }
+        }
+      }
+}
+
+@Composable
+private fun DisplayStarReview(rating: Int) {
+  for (i in 1..rating) {
+    Box(modifier = Modifier.width(STAR_SIZE_DP).testTag("mapDraggableMenuBookBoxStar")) {
+      Icon(
+          imageVector = Icons.Filled.Star,
+          contentDescription = "Star Icon",
+          tint =
+              MaterialTheme.colorScheme.outline.let {
+                it.copy(1f, it.red * 0.75f, it.green * 0.75f, it.blue * 0.75f)
+              },
+          modifier = Modifier.size(STAR_SIZE_DP))
+    }
+  }
+  for (i in rating + 1..MAX_RATING) {
+    // Hollow star
+    Box(modifier = Modifier.width(STAR_SIZE_DP).testTag("mapDraggableMenuBookBoxEmptyStar")) {
+      Icon(
+          imageVector = Icons.TwoTone.Star,
+          contentDescription = "Star Icon",
+          tint = MaterialTheme.colorScheme.outline,
+          modifier = Modifier.size(STAR_SIZE_DP))
+    }
+  }
+}
Index: app/src/main/java/com/android/bookswap/ui/components/BookListComponent.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/components/BookListComponent.kt b/app/src/main/java/com/android/bookswap/ui/components/BookListComponent.kt
new file mode 100644
--- /dev/null	(date 1731632554088)
+++ b/app/src/main/java/com/android/bookswap/ui/components/BookListComponent.kt	(date 1731632554088)
@@ -0,0 +1,48 @@
+package com.android.bookswap.ui.components
+
+import androidx.compose.foundation.gestures.ScrollableDefaults
+import androidx.compose.foundation.layout.PaddingValues
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.foundation.lazy.itemsIndexed
+import androidx.compose.foundation.lazy.rememberLazyListState
+import androidx.compose.material3.HorizontalDivider
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.unit.Dp
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.ui.books.BookProfileScreen
+
+val DIVIDER_THICKNESS_DP = Dp.Hairline
+
+@Composable
+fun BookListComponent(
+    modifier: Modifier = Modifier,
+    bookList: List<DataBook> = emptyList(),
+) {
+  LazyColumn(
+      modifier = modifier.fillMaxWidth().testTag("BookListColumn"),
+      state = rememberLazyListState(),
+      contentPadding = PaddingValues(PADDING_HORIZONTAL_DP, PADDING_VERTICAL_DP),
+      horizontalAlignment = Alignment.CenterHorizontally,
+      flingBehavior = ScrollableDefaults.flingBehavior(),
+      userScrollEnabled = true,
+  ) {
+    if (bookList.isEmpty()) {
+      item { Text(text = "No books to display", Modifier.testTag("mapDraggableMenuNoBook")) }
+    } else {
+      itemsIndexed(bookList) { i, book ->
+        BookDisplayComponent(Modifier.testTag("mapDraggableMenuBookBox${i}"), book = book)
+        if (i < bookList.size - 1) {
+          HorizontalDivider(
+              modifier = Modifier.testTag("mapDraggableMenuBookBoxDivider"),
+          )
+          BookProfileScreen(book,{}, {})
+        }
+      }
+    }
+  }
+}
Index: app/src/main/java/com/android/bookswap/model/chat/Chat.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/chat/Chat.kt b/app/src/main/java/com/android/bookswap/model/chat/Chat.kt
new file mode 100644
--- /dev/null	(date 1731617426316)
+++ b/app/src/main/java/com/android/bookswap/model/chat/Chat.kt	(date 1731617426316)
@@ -0,0 +1,4 @@
+package com.android.bookswap.model.chat
+
+/** Data class for the message box */
+data class MessageBox(val contactName: String, val message: String, val date: String)
Index: app/proguard-rules.pro
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/proguard-rules.pro b/app/proguard-rules.pro
new file mode 100644
--- /dev/null	(date 1730306755517)
+++ b/app/proguard-rules.pro	(date 1730306755517)
@@ -0,0 +1,21 @@
+# Add project specific ProGuard rules here.
+# You can control the set of applied configuration files using the
+# proguardFiles setting in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
\ No newline at end of file
Index: app/src/main/java/com/android/bookswap/data/UserBooksWithLocation.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/UserBooksWithLocation.kt b/app/src/main/java/com/android/bookswap/data/UserBooksWithLocation.kt
new file mode 100644
--- /dev/null	(date 1731617426314)
+++ b/app/src/main/java/com/android/bookswap/data/UserBooksWithLocation.kt	(date 1731617426314)
@@ -0,0 +1,18 @@
+package com.android.bookswap.data
+
+import java.util.UUID
+
+/**
+ * Represents a user's book collection along with their geographical location.
+ *
+ * @property userUUID Unique identifier for the user.
+ * @property longitude The user's longitude coordinate.
+ * @property latitude The user's latitude coordinate.
+ * @property books List of books associated with the user.
+ */
+data class UserBooksWithLocation(
+    val userUUID: UUID,
+    val longitude: Double,
+    val latitude: Double,
+    val books: List<DataBook>
+)
Index: app/src/androidTest/java/com/android/bookswap/ui/profile/NewUserScreenTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/profile/NewUserScreenTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/profile/NewUserScreenTest.kt
new file mode 100644
--- /dev/null	(date 1731617442889)
+++ b/app/src/androidTest/java/com/android/bookswap/ui/profile/NewUserScreenTest.kt	(date 1731617442889)
@@ -0,0 +1,149 @@
+package com.android.bookswap.ui.profile
+
+import androidx.compose.ui.test.assertHasClickAction
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.assertTextContains
+import androidx.compose.ui.test.assertTextEquals
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.compose.ui.test.performClick
+import androidx.compose.ui.test.performTextInput
+import com.android.bookswap.model.UserViewModel
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.navigation.Route
+import io.mockk.justRun
+import io.mockk.mockk
+import io.mockk.verify
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.mockito.kotlin.any
+
+class NewUserScreenTest {
+  @get:Rule val composeTestRule = createComposeRule()
+  private lateinit var navigationActions: NavigationActions
+  private lateinit var userVM: UserViewModel
+
+  @Before
+  fun setUp() {
+    navigationActions = mockk(relaxed = true)
+    userVM = mockk(relaxed = true)
+  }
+
+  @Test
+  fun allComponentsAreDisplayedWithCorrectTexts() {
+    composeTestRule.setContent { NewUserScreen(navigationActions, userVM) }
+    composeTestRule
+        .onNodeWithTag("welcomeTxt")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextEquals("Welcome")
+
+    composeTestRule
+        .onNodeWithTag("personalInfoTxt")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextEquals("Please fill in your personal information to start BookSwapping")
+
+    composeTestRule
+        .onNodeWithTag("profilPics")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertHasClickAction()
+
+    composeTestRule
+        .onNodeWithTag("greetingTF")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Greeting")
+
+    composeTestRule
+        .onNodeWithTag("firstnameTF")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Firstname")
+
+    composeTestRule
+        .onNodeWithTag("lastnameTF")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Lastname")
+
+    composeTestRule
+        .onNodeWithTag("emailTF")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Email")
+
+    composeTestRule
+        .onNodeWithTag("phoneTF")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Phone")
+
+    composeTestRule
+        .onNodeWithTag("CreateButton")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextEquals("Create")
+        .assertHasClickAction()
+  }
+
+  @Test
+  fun clickOnCreateButtonWithInvalidEmailDoesNotNavigate() {
+
+    composeTestRule.setContent { NewUserScreen(navigationActions, userVM) }
+
+    composeTestRule.onNodeWithTag("greetingTF").performTextInput("Mr.")
+    composeTestRule.onNodeWithTag("firstnameTF").performTextInput("John")
+    composeTestRule.onNodeWithTag("lastnameTF").performTextInput("Doe")
+    composeTestRule.onNodeWithTag("emailTF").performTextInput("john.doe.com") // Email invalide
+    composeTestRule.onNodeWithTag("phoneTF").performTextInput("+4122345678")
+
+    composeTestRule.onNodeWithTag("CreateButton").performClick()
+
+    verify(exactly = 0) { navigationActions.navigateTo(Route.MAP) }
+
+    composeTestRule
+        .onNodeWithTag("emailError")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Invalid email format")
+  }
+
+  @Test
+  fun clickOnCreateButtonWithEmptyFieldsShowsErrors() {
+    justRun {
+      userVM.updateUser(any(), any(), any(), any(), any(), any(), any(), any(), any(), any())
+    }
+    composeTestRule.setContent { NewUserScreen(navigationActions, userVM) }
+
+    composeTestRule.onNodeWithTag("greetingTF").performTextInput("")
+    composeTestRule.onNodeWithTag("firstnameTF").performTextInput("")
+    composeTestRule.onNodeWithTag("lastnameTF").performTextInput("")
+    composeTestRule.onNodeWithTag("emailTF").performTextInput("notanemail")
+    composeTestRule.onNodeWithTag("phoneTF").performTextInput("")
+
+    composeTestRule.onNodeWithTag("CreateButton").performClick()
+
+    verify(exactly = 0) { navigationActions.navigateTo(Route.MAP) }
+
+    composeTestRule
+        .onNodeWithTag("firstnameError")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("First name required")
+
+    composeTestRule
+        .onNodeWithTag("lastnameError")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Last name required")
+
+    composeTestRule
+        .onNodeWithTag("emailError")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Invalid email format")
+  }
+}
Index: app/src/main/res/values-night/themes.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/values-night/themes.xml b/app/src/main/res/values-night/themes.xml
new file mode 100644
--- /dev/null	(date 1730306755527)
+++ b/app/src/main/res/values-night/themes.xml	(date 1730306755527)
@@ -0,0 +1,16 @@
+<resources xmlns:tools="http://schemas.android.com/tools">
+    <!-- Base application theme. -->
+    <style name="Theme.BookSwapApp" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
+        <!-- Primary brand color. -->
+        <item name="colorPrimary">@color/purple_200</item>
+        <item name="colorPrimaryVariant">@color/purple_700</item>
+        <item name="colorOnPrimary">@color/black</item>
+        <!-- Secondary brand color. -->
+        <item name="colorSecondary">@color/teal_200</item>
+        <item name="colorSecondaryVariant">@color/teal_200</item>
+        <item name="colorOnSecondary">@color/black</item>
+        <!-- Status bar color. -->
+        <item name="android:statusBarColor">?attr/colorPrimaryVariant</item>
+        <!-- Customize your theme here. -->
+    </style>
+</resources>
\ No newline at end of file
Index: app/src/main/java/com/android/bookswap/model/map/IGeolocation.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/map/IGeolocation.kt b/app/src/main/java/com/android/bookswap/model/map/IGeolocation.kt
new file mode 100644
--- /dev/null	(date 1731615667000)
+++ b/app/src/main/java/com/android/bookswap/model/map/IGeolocation.kt	(date 1731615667000)
@@ -0,0 +1,21 @@
+package com.android.bookswap.model.map
+
+import kotlinx.coroutines.flow.MutableStateFlow
+
+/**
+ * Interface for providing geolocation data, with basic location management functionality.
+ *
+ * Classes implementing this interface should provide access to the user's current latitude and
+ * longitude, as well as functions to start and stop location updates.
+ *
+ * This interface allows different implementations for geolocation, facilitating testing by enabling
+ * the use of mock or fake data sources.
+ */
+interface IGeolocation {
+  val latitude: MutableStateFlow<Double>
+  val longitude: MutableStateFlow<Double>
+
+  fun startLocationUpdates()
+
+  fun stopLocationUpdates()
+}
Index: app/src/main/java/com/android/bookswap/ui/map/Map.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/map/Map.kt b/app/src/main/java/com/android/bookswap/ui/map/Map.kt
new file mode 100644
--- /dev/null	(date 1731617426000)
+++ b/app/src/main/java/com/android/bookswap/ui/map/Map.kt	(date 1731617426000)
@@ -0,0 +1,404 @@
+package com.android.bookswap.ui.map
+
+import androidx.compose.foundation.BorderStroke
+import androidx.compose.foundation.background
+import androidx.compose.foundation.border
+import androidx.compose.foundation.gestures.detectVerticalDragGestures
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.heightIn
+import androidx.compose.foundation.layout.offset
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.layout.width
+import androidx.compose.foundation.layout.wrapContentSize
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.foundation.lazy.itemsIndexed
+import androidx.compose.foundation.shape.RoundedCornerShape
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.filled.Star
+import androidx.compose.material3.Card
+import androidx.compose.material3.CardDefaults
+import androidx.compose.material3.HorizontalDivider
+import androidx.compose.material3.Icon
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.Text
+import androidx.compose.runtime.*
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.geometry.Offset
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.input.pointer.pointerInput
+import androidx.compose.ui.platform.LocalConfiguration
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.semantics.SemanticsPropertyKey
+import androidx.compose.ui.semantics.SemanticsPropertyReceiver
+import androidx.compose.ui.semantics.semantics
+import androidx.compose.ui.unit.IntOffset
+import androidx.compose.ui.unit.dp
+import androidx.compose.ui.unit.sp
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.model.map.BookFilter
+import com.android.bookswap.model.map.BookManagerViewModel
+import com.android.bookswap.model.map.DefaultGeolocation
+import com.android.bookswap.model.map.IGeolocation
+import com.android.bookswap.ui.components.BookListComponent
+import com.android.bookswap.ui.navigation.BOTTOM_NAV_HEIGHT
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.navigation.Screen
+import com.android.bookswap.ui.theme.ColorVariable
+import com.google.android.gms.maps.model.BitmapDescriptorFactory
+import com.google.android.gms.maps.model.CameraPosition
+import com.google.android.gms.maps.model.LatLng
+import com.google.maps.android.compose.*
+import com.google.maps.android.compose.GoogleMap
+import kotlin.math.roundToInt
+import kotlinx.coroutines.launch
+
+const val INIT_ZOOM = 10F
+const val NO_USER_SELECTED = -1
+
+val CameraPositionKey = SemanticsPropertyKey<CameraPositionState>("CameraPosition")
+var SemanticsPropertyReceiver.cameraPosition by CameraPositionKey
+
+/**
+ * Composable function to display a map with user locations and associated book information.
+ *
+ * This screen renders a GoogleMap that shows books locations as markers. Upon clicking a marker, it
+ * displays a custom info window with the list of books at this location.
+ *
+ * @param bookManagerViewModel the view model that give the mapScreen the list of books to display
+ * @param bookFilter An instance of [BookFilter] to filter the books displayed on the map.
+ * @param selectedUser An optional user, it will display the infoWindow related to this user. This
+ *   user’s info window will be shown if it is bigger or equal to 0.
+ * @param geolocation An instance of [IGeolocation] to get the user's current location.
+ */
+@Composable
+fun MapScreen(
+    bookManagerViewModel: BookManagerViewModel,
+    navigationActions: NavigationActions,
+    selectedUser: Int = NO_USER_SELECTED,
+    geolocation: IGeolocation = DefaultGeolocation(),
+    topAppBar: @Composable () -> Unit = {},
+    bottomAppBar: @Composable () -> Unit = {},
+) {
+  val cameraPositionState = rememberCameraPositionState()
+  // Get the user's current location
+  val latitude = geolocation.latitude.collectAsState()
+  val longitude = geolocation.longitude.collectAsState()
+  // Start location and books updates
+  LaunchedEffect(Unit) {
+    bookManagerViewModel.startUpdatingBooks()
+    geolocation.startLocationUpdates()
+    cameraPositionState.position =
+        CameraPosition.fromLatLngZoom(LatLng(latitude.value, longitude.value), INIT_ZOOM)
+  }
+  // Stop location and books updates when the screen is disposed
+  DisposableEffect(Unit) {
+    onDispose {
+      geolocation.stopLocationUpdates()
+      bookManagerViewModel.stopUpdatingBooks()
+    }
+  }
+
+  var mutableStateSelectedUser by remember { mutableStateOf(selectedUser) }
+  var markerScreenPosition by remember { mutableStateOf<Offset?>(null) }
+
+  val filteredBooks = bookManagerViewModel.filteredBooks.collectAsState()
+
+  val filteredUsers = bookManagerViewModel.filteredUsers.collectAsState()
+
+  // compute the position of the marker on the screen given the camera position and the marker's
+  // position on the map
+  fun computePositionOfMarker(cameraPositionState: CameraPositionState, markerLatLng: LatLng) {
+    val projection = cameraPositionState.projection
+    projection?.let {
+      val screenPosition = it.toScreenLocation(markerLatLng)
+      markerScreenPosition = Offset(screenPosition.x.toFloat(), screenPosition.y.toFloat())
+    }
+  }
+
+  if (mutableStateSelectedUser >= 0 && mutableStateSelectedUser < filteredUsers.value.size) {
+    computePositionOfMarker(
+        cameraPositionState,
+        LatLng(
+            filteredUsers.value[mutableStateSelectedUser].latitude,
+            filteredUsers.value[mutableStateSelectedUser].longitude))
+  }
+
+  val coroutineScope = rememberCoroutineScope()
+
+  // Recalculate marker screen position during camera movement
+  LaunchedEffect(cameraPositionState.position) {
+    if (mutableStateSelectedUser >= 0 && mutableStateSelectedUser < filteredUsers.value.size) {
+      computePositionOfMarker(
+          cameraPositionState,
+          LatLng(
+              filteredUsers.value[mutableStateSelectedUser].latitude,
+              filteredUsers.value[mutableStateSelectedUser].longitude))
+    }
+  }
+
+  Scaffold(
+      modifier = Modifier.testTag("mapScreen"),
+      topBar = topAppBar,
+      bottomBar = bottomAppBar,
+      content = { pd ->
+        Box(
+            Modifier.padding(
+                top = pd.calculateTopPadding(), bottom = pd.calculateBottomPadding())) {
+              GoogleMap(
+                  onMapClick = { mutableStateSelectedUser = NO_USER_SELECTED },
+                  modifier =
+                      Modifier.fillMaxSize().testTag("mapGoogleMap").semantics {
+                        cameraPosition = cameraPositionState
+                      },
+                  cameraPositionState = cameraPositionState,
+                  uiSettings = MapUiSettings(zoomControlsEnabled = false),
+              ) {
+                // Marker for user's current location
+                if (!latitude.value.isNaN() && !longitude.value.isNaN()) {
+                  Marker(
+                      state = MarkerState(position = LatLng(latitude.value, longitude.value)),
+                      title = "Your Location",
+                      icon =
+                          BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_BLUE))
+                }
+                filteredUsers.value
+                    .filter {
+                      !it.longitude.isNaN() && !it.latitude.isNaN() && it.books.isNotEmpty()
+                    }
+                    .forEachIndexed { index, item ->
+                      val markerState =
+                          MarkerState(position = LatLng(item.latitude, item.longitude))
+
+                      Marker(
+                          state = markerState,
+                          onClick = {
+                            mutableStateSelectedUser = index
+                            coroutineScope.launch {
+                              computePositionOfMarker(cameraPositionState, markerState.position)
+                            }
+                            false
+                          })
+                    }
+              }
+              FilterButton { navigationActions.navigateTo(Screen.FILTER) }
+
+              // Custom info window linked to the marker
+              markerScreenPosition?.let { screenPos ->
+                if (mutableStateSelectedUser >= 0 &&
+                    mutableStateSelectedUser < filteredUsers.value.size &&
+                    filteredUsers.value[mutableStateSelectedUser].books.isNotEmpty()) {
+                  CustomInfoWindow(
+                      modifier =
+                          Modifier.offset {
+                            IntOffset(screenPos.x.roundToInt(), screenPos.y.roundToInt())
+                          },
+                      userBooks = filteredUsers.value[mutableStateSelectedUser].books)
+                }
+              }
+              // Draggable Bottom List
+              DraggableMenu(filteredBooks.value)
+            }
+      })
+}
+
+const val PADDING_VERTICAL_DP = 4
+const val PADDING_HORIZONTAL_DP = 8
+const val DIVIDER_THICKNESS_DP = 1
+const val CARD_CORNER_RADIUS = 10
+const val CARD_WIDTH_DP = 200
+const val CARD_HEIGHT_DP = CARD_WIDTH_DP * 2
+
+const val PRIMARY_TEXT_FONT_SP = 20
+const val SECONDARY_TEXT_FONT_SP = 16
+
+/**
+ * Composable function to display a custom info window for a selected book's list marker on the map.
+ *
+ * This function creates a card that shows detailed information about a user's list of books when
+ * the corresponding map marker is clicked.
+ *
+ * @param modifier A [Modifier] to apply to the card containing the custom info window. It can be
+ *   used to modify the position, size, and appearance of the info window, but is mainly intended to
+ *   give the position of the CustomInfoWindow. Default is `Modifier`.
+ * @param user The `TempUser` object containing the list of books to be displayed inside the info
+ *   window.
+ */
+@Composable
+private fun CustomInfoWindow(modifier: Modifier = Modifier, userBooks: List<DataBook>) {
+  Card(
+      modifier =
+          modifier
+              .wrapContentSize()
+              .width(CARD_WIDTH_DP.dp)
+              .border(
+                  BorderStroke(width = DIVIDER_THICKNESS_DP.dp, color = ColorVariable.Accent),
+                  shape =
+                      RoundedCornerShape(
+                          0.dp,
+                          CARD_CORNER_RADIUS.dp,
+                          CARD_CORNER_RADIUS.dp,
+                          CARD_CORNER_RADIUS.dp))
+              .heightIn(max = CARD_HEIGHT_DP.dp)
+              .testTag("mapBoxMarker")
+              .background(Color.Transparent),
+      colors = CardDefaults.cardColors(containerColor = ColorVariable.Secondary),
+      shape =
+          RoundedCornerShape(
+              0.dp, CARD_CORNER_RADIUS.dp, CARD_CORNER_RADIUS.dp, CARD_CORNER_RADIUS.dp)) {
+        Spacer(modifier.height(CARD_CORNER_RADIUS.dp))
+        LazyColumn(modifier = Modifier.fillMaxWidth().testTag("mapBoxMarkerList")) {
+          itemsIndexed(userBooks) { index, book ->
+            Column(
+                modifier =
+                    Modifier.padding(horizontal = PADDING_HORIZONTAL_DP.dp)
+                        .testTag("mapBoxMarkerListBox")) {
+                  Text(
+                      text = book.title,
+                      color = ColorVariable.Accent,
+                      fontSize = PRIMARY_TEXT_FONT_SP.sp,
+                      modifier = Modifier.testTag("mapBoxMarkerListBoxTitle"))
+                  Spacer(modifier = Modifier.height(PADDING_VERTICAL_DP.dp))
+                  Text(
+                      text = book.author ?: "",
+                      color = ColorVariable.AccentSecondary,
+                      fontSize = SECONDARY_TEXT_FONT_SP.sp,
+                      modifier = Modifier.testTag("mapBoxMarkerListBoxAuthor"))
+                }
+            if (index < userBooks.size - 1)
+                HorizontalDivider(
+                    modifier =
+                        Modifier.fillMaxWidth()
+                            .height(PADDING_VERTICAL_DP.dp)
+                            .testTag("mapBoxMarkerListDivider"),
+                    thickness = DIVIDER_THICKNESS_DP.dp,
+                    color = ColorVariable.Accent)
+          }
+        }
+        Spacer(modifier.height(PADDING_VERTICAL_DP.dp))
+      }
+}
+
+const val HEIGHT_RETRACTED_DRAGGABLE_MENU_DP = 50
+const val MIN_BOX_BOOK_HEIGHT_DP = 90
+const val IMAGE_HEIGHT_DP = MIN_BOX_BOOK_HEIGHT_DP - PADDING_VERTICAL_DP * 2
+// 1.5:1 ratio + the padding
+const val IMAGE_WIDTH_DP = MIN_BOX_BOOK_HEIGHT_DP * 2 / 3 + PADDING_HORIZONTAL_DP * 2
+const val HANDLE_WIDTH_DP = 120
+const val HANDLE_HEIGHT_DP = 15
+const val HANDLE_CORNER_RADIUS_DP = 10
+const val SPACER_HEIGHT_DP = 20
+const val STAR_HEIGHT_DP = 30
+const val STAR_SIZE_DP = 26
+const val STAR_INNER_SIZE_DP = STAR_SIZE_DP / 2
+const val WIDTH_TITLE_BOX_DP = 150
+const val MAX_RATING = 5
+
+/**
+ * Composable function to display a draggable menu containing all the nearest books available.
+ *
+ * @param listAllBooks A [List] of all [DataBook] sorted with the nearest book at the first position
+ *   and the furthest one at the last position.
+ */
+@Composable
+private fun DraggableMenu(listAllBooks: List<DataBook>) {
+
+  // State for menu drag offset
+  val configuration = LocalConfiguration.current
+  val maxSheetOffsetY = configuration.screenHeightDp.dp - BOTTOM_NAV_HEIGHT * 2
+  var sheetOffsetY by remember {
+    mutableStateOf((maxSheetOffsetY - HEIGHT_RETRACTED_DRAGGABLE_MENU_DP.dp) / 3 * 2)
+  }
+
+  Box(
+      modifier =
+          Modifier.offset {
+                IntOffset(
+                    0,
+                    sheetOffsetY
+                        .toPx()
+                        .roundToInt()
+                        .coerceIn(
+                            0,
+                            (maxSheetOffsetY - HEIGHT_RETRACTED_DRAGGABLE_MENU_DP.dp)
+                                .toPx()
+                                .toInt()))
+              }
+              .fillMaxWidth()
+              .height(
+                  (maxSheetOffsetY - sheetOffsetY).coerceIn(maxSheetOffsetY / 10, maxSheetOffsetY))
+              .pointerInput(Unit) {
+                detectVerticalDragGestures { change, dragAmount ->
+                  change.consume()
+                  val dragAmountInDp = dragAmount / density
+                  sheetOffsetY = (sheetOffsetY + dragAmountInDp.dp)
+                }
+              }
+              .background(
+                  color = ColorVariable.BackGround,
+                  shape =
+                      RoundedCornerShape(
+                          topStart = HEIGHT_RETRACTED_DRAGGABLE_MENU_DP.dp,
+                          topEnd = HEIGHT_RETRACTED_DRAGGABLE_MENU_DP.dp))
+              .testTag("mapDraggableMenu")) {
+        Column(modifier = Modifier.fillMaxWidth().testTag("mapDraggableMenuStructure")) {
+          // draggable handle
+          Spacer(modifier = Modifier.height(HANDLE_HEIGHT_DP.dp))
+          Box(
+              modifier =
+                  Modifier.align(Alignment.CenterHorizontally)
+                      .width(HANDLE_WIDTH_DP.dp)
+                      .height(HANDLE_HEIGHT_DP.dp)
+                      .background(
+                          color = ColorVariable.AccentSecondary,
+                          shape = RoundedCornerShape(HANDLE_CORNER_RADIUS_DP.dp))
+                      .testTag("mapDraggableMenuHandle"))
+          Spacer(modifier = Modifier.height(SPACER_HEIGHT_DP.dp))
+          HorizontalDivider(
+              modifier = Modifier.fillMaxWidth().testTag("mapDraggableMenuHandleDivider"),
+              thickness = DIVIDER_THICKNESS_DP.dp,
+              color = ColorVariable.Accent)
+          BookListComponent(Modifier, listAllBooks)
+        }
+      }
+}
+
+/**
+ * Composable function that displays a row of 5 stars, the n first are filled then the rest are
+ * empty stars.
+ *
+ * @param rating A [Int] from 1 to 5, used to know how many filled star should be displayed
+ */
+@Composable
+private fun DisplayStarReview(rating: Int) {
+  for (i in 1..rating) {
+    Icon(
+        imageVector = Icons.Filled.Star,
+        contentDescription = "Star Icon",
+        tint = Color.Black,
+        modifier = Modifier.size(STAR_SIZE_DP.dp).testTag("mapDraggableMenuBookBoxStar"))
+  }
+  for (i in rating + 1..MAX_RATING) {
+    // Hollow star
+    // Icons.Outlined.Star doesn't work, it displays the
+    // Icons.Filled.Star
+    Box(modifier = Modifier.width(STAR_SIZE_DP.dp).testTag("mapDraggableMenuBookBoxEmptyStar")) {
+      Icon(
+          imageVector = Icons.Filled.Star,
+          contentDescription = "Star Icon",
+          tint = Color.Black,
+          modifier = Modifier.size(STAR_SIZE_DP.dp))
+      Icon(
+          imageVector = Icons.Filled.Star,
+          contentDescription = "Star Icon",
+          tint = ColorVariable.BackGround,
+          modifier = Modifier.size(STAR_INNER_SIZE_DP.dp).align(Alignment.Center))
+    }
+  }
+}
Index: app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreRepositoryTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreRepositoryTest.kt b/app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreRepositoryTest.kt
new file mode 100644
--- /dev/null	(date 1731600939000)
+++ b/app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreRepositoryTest.kt	(date 1731600939000)
@@ -0,0 +1,1 @@
+
Index: app/src/test/java/com/android/bookswap/data/source/network/PhotoFirebaseStorageSourceTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/source/network/PhotoFirebaseStorageSourceTest.kt b/app/src/test/java/com/android/bookswap/data/source/network/PhotoFirebaseStorageSourceTest.kt
new file mode 100644
--- /dev/null	(date 1731617442893)
+++ b/app/src/test/java/com/android/bookswap/data/source/network/PhotoFirebaseStorageSourceTest.kt	(date 1731617442893)
@@ -0,0 +1,132 @@
+package com.android.bookswap.data.source.network
+
+import android.content.Context
+import android.graphics.BitmapFactory
+import android.net.Uri
+import android.os.Looper
+import androidx.test.core.app.ApplicationProvider
+import com.android.bookswap.R
+import com.google.android.gms.tasks.OnFailureListener
+import com.google.android.gms.tasks.OnSuccessListener
+import com.google.android.gms.tasks.Tasks
+import com.google.firebase.FirebaseApp
+import com.google.firebase.storage.FirebaseStorage
+import com.google.firebase.storage.StorageReference
+import com.google.firebase.storage.UploadTask
+import io.mockk.MockKAnnotations
+import io.mockk.every
+import io.mockk.impl.annotations.MockK
+import io.mockk.mockk
+import io.mockk.slot
+import io.mockk.verify
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.RobolectricTestRunner
+import org.robolectric.Shadows.shadowOf
+
+@RunWith(RobolectricTestRunner::class)
+class PhotoFirebaseStorageSourceTest {
+  @MockK private lateinit var mockFirebaseStorage: FirebaseStorage
+  @MockK private lateinit var mockStorageReference: StorageReference
+
+  private lateinit var photoStorageSource: PhotoFirebaseStorageSource
+  private val photoId = "etranger_test"
+
+  @Before
+  fun setup() {
+    MockKAnnotations.init(this)
+
+    // Initialize Firebase if necessary
+    FirebaseApp.initializeApp(ApplicationProvider.getApplicationContext())
+
+    // Set up Firebase storage mocks
+    every { mockFirebaseStorage.reference } returns mockStorageReference
+    photoStorageSource = PhotoFirebaseStorageSource(mockFirebaseStorage)
+  }
+
+  @Test
+  fun `addPhotoToStorage uploads photo and returns URL on success`() {
+    // Load a real bitmap from resources
+    val context = ApplicationProvider.getApplicationContext<Context>()
+    val testBitmap = BitmapFactory.decodeResource(context.resources, R.drawable.etranger_test)
+
+    val mockDownloadUrl = "https://mockurl.com/test_photo.jpg" // url we expect to receive
+    val callback = mockk<(Result<String>) -> Unit>(relaxed = true)
+
+    // Mock storage reference behavior
+    val photoStorageReference = mockk<StorageReference>()
+    every { mockStorageReference.child("images/$photoId.jpg") } returns photoStorageReference
+
+    // Mock successful upload task with both listeners
+    val mockUploadTask = mockk<UploadTask>()
+    every { photoStorageReference.putBytes(any()) } returns mockUploadTask
+    val successListenerSlot = slot<OnSuccessListener<UploadTask.TaskSnapshot>>()
+    val failureListenerSlot = slot<OnFailureListener>()
+
+    every { mockUploadTask.addOnSuccessListener(capture(successListenerSlot)) } answers
+        {
+          successListenerSlot.captured.onSuccess(mockk())
+          mockUploadTask
+        }
+    every { mockUploadTask.addOnFailureListener(capture(failureListenerSlot)) } answers
+        {
+          mockUploadTask
+        }
+
+    // Mock successful download URL retrieval
+    every { photoStorageReference.downloadUrl } returns Tasks.forResult(Uri.parse(mockDownloadUrl))
+
+    // Add photo to storage
+    photoStorageSource.addPhotoToStorage(photoId, testBitmap, callback)
+
+    // Force Robolectric to process any pending tasks on the main thread
+    shadowOf(Looper.getMainLooper()).idle()
+
+    verify { callback(Result.success(mockDownloadUrl)) }
+  }
+
+  @Test
+  fun `addPhotoToStorage returns failure on upload error`() {
+    // Load a real bitmap from resources
+    val context = ApplicationProvider.getApplicationContext<Context>()
+    val testBitmap = BitmapFactory.decodeResource(context.resources, R.drawable.etranger_test)
+
+    val callback = mockk<(Result<String>) -> Unit>(relaxed = true)
+    val exception = Exception("Upload failed")
+
+    // Mock storage reference behavior
+    val photoStorageReference = mockk<StorageReference>()
+    every { mockStorageReference.child("images/$photoId.jpg") } returns photoStorageReference
+
+    // Mock upload failure task with both listeners
+    val mockUploadTask = mockk<UploadTask>()
+    every { photoStorageReference.putBytes(any()) } returns mockUploadTask
+    val successListenerSlot = slot<OnSuccessListener<UploadTask.TaskSnapshot>>()
+    val failureListenerSlot = slot<OnFailureListener>()
+
+    every { mockUploadTask.addOnSuccessListener(capture(successListenerSlot)) } answers
+        {
+          mockUploadTask
+        }
+    every { mockUploadTask.addOnFailureListener(capture(failureListenerSlot)) } answers
+        {
+          failureListenerSlot.captured.onFailure(exception)
+          mockUploadTask
+        }
+
+    // Add photo to storage
+    photoStorageSource.addPhotoToStorage(photoId, testBitmap, callback)
+
+    verify { callback(Result.failure(exception)) }
+  }
+
+  @Test
+  fun `init calls callback with success`() {
+    val callback = mockk<(Result<Unit>) -> Unit>(relaxed = true)
+
+    photoStorageSource.init(callback)
+
+    verify { callback(Result.success(Unit)) }
+  }
+}
Index: app/src/test/java/com/android/bookswap/ui/navigation/NavigationCurrentLocation.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/ui/navigation/NavigationCurrentLocation.kt b/app/src/test/java/com/android/bookswap/ui/navigation/NavigationCurrentLocation.kt
new file mode 100644
--- /dev/null	(date 1731617442893)
+++ b/app/src/test/java/com/android/bookswap/ui/navigation/NavigationCurrentLocation.kt	(date 1731617442893)
@@ -0,0 +1,56 @@
+package com.android.bookswap.ui.navigation
+
+import androidx.navigation.NavBackStackEntry
+import androidx.navigation.NavDestination
+import androidx.navigation.NavHostController
+import androidx.navigation.NavOptionsBuilder
+import io.mockk.*
+import org.junit.Before
+import org.junit.Test
+
+class NavigationCurrentLocation {
+
+  private lateinit var navController: NavHostController
+  private lateinit var navigationActions: NavigationActions
+
+  @Before
+  fun setup() {
+    navController = mockk(relaxed = true)
+    navigationActions = NavigationActions(navController)
+
+    val currentBackStackEntry = mockk<NavBackStackEntry>()
+    every { navController.currentBackStackEntry } returns currentBackStackEntry
+
+    val destination = mockk<NavDestination>()
+    every { currentBackStackEntry.destination } returns destination
+  }
+
+  @Test
+  fun `navigateTo does not navigate when already on destination`() {
+    // Arrange: Set up the current route to match the target destination
+    every { navController.currentBackStackEntry?.destination?.route } returns
+        TopLevelDestinations.MAP.route
+
+    // Act: Try to navigate to the MAP screen
+    navigationActions.navigateTo(TopLevelDestinations.MAP)
+
+    // Assert: Verify that navigate is not called since we are already on MAP
+    verify(exactly = 0) { navController.navigate(any<String>()) }
+  }
+
+  @Test
+  fun `navigateTo navigates when not on destination`() {
+    // Arrange: Set up the current route to be different from the target destination
+    every { navController.currentBackStackEntry?.destination?.route } returns
+        TopLevelDestinations.CHAT.route
+
+    // Act: Try to navigate to the MAP screen
+    navigationActions.navigateTo(TopLevelDestinations.MAP)
+
+    // Assert: Verify that navigate is called since we are not on MAP
+    verify(exactly = 1) {
+      navController.navigate(
+          eq(TopLevelDestinations.MAP.route), any<NavOptionsBuilder.() -> Unit>())
+    }
+  }
+}
Index: app/src/main/java/com/android/bookswap/data/DataMessage.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/DataMessage.kt b/app/src/main/java/com/android/bookswap/data/DataMessage.kt
new file mode 100644
--- /dev/null	(date 1731615667844)
+++ b/app/src/main/java/com/android/bookswap/data/DataMessage.kt	(date 1731615667844)
@@ -0,0 +1,17 @@
+package com.android.bookswap.data
+
+import java.util.UUID
+
+data class DataMessage(
+    val messageType: MessageType = MessageType.TEXT,
+    val uuid: UUID = UUID.randomUUID(),
+    val text: String = "",
+    val senderUUID: UUID,
+    val receiverUUID: UUID,
+    val timestamp: Long = 0L
+)
+
+enum class MessageType {
+  TEXT,
+  IMAGE
+}
Index: app/src/main/java/com/android/bookswap/data/source/network/PhotoFirebaseStorageSource.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/source/network/PhotoFirebaseStorageSource.kt b/app/src/main/java/com/android/bookswap/data/source/network/PhotoFirebaseStorageSource.kt
new file mode 100644
--- /dev/null	(date 1731617442890)
+++ b/app/src/main/java/com/android/bookswap/data/source/network/PhotoFirebaseStorageSource.kt	(date 1731617442890)
@@ -0,0 +1,70 @@
+package com.android.bookswap.data.source.network
+
+import android.graphics.Bitmap
+import android.util.Log
+import com.android.bookswap.data.repository.PhotoFirebaseStorageRepository
+import com.google.firebase.storage.FirebaseStorage
+import java.io.ByteArrayOutputStream
+
+/** Constants : */
+/** Quality of the compressed image */
+const val QUALITY_COMPRESSION = 100
+
+/**
+ * A class that implements the PhotoFirebaseStorageRepository interface using Firebase Storage as
+ * the data source.
+ *
+ * @property storage The Firebase Storage instance.
+ */
+class PhotoFirebaseStorageSource(private val storage: FirebaseStorage) :
+    PhotoFirebaseStorageRepository {
+
+  /**
+   * Initializes the PhotoFirebaseStorageSource.
+   *
+   * @param callback A callback function that receives Result.success(Unit) on success or
+   *   Result.failure(exception) on failure.
+   */
+  override fun init(callback: (Result<Unit>) -> Unit) {
+    try {
+      callback(Result.success(Unit))
+    } catch (e: Exception) {
+      Log.e("PhotoSource", "Initialization failed: ${e.message}")
+      callback(Result.failure(e))
+    }
+  }
+
+  /**
+   * Adds a photo to Firebase Storage.
+   *
+   * @param photoId The ID of the photo to add.
+   * @param bitmap The photo to add.
+   * @param callback A callback function that receives Result.success(String) with the URL of the
+   *   photo on success or Result.failure(exception) on failure.
+   */
+  override fun addPhotoToStorage(
+      photoId: String,
+      bitmap: Bitmap,
+      callback: (Result<String>) -> Unit
+  ) {
+    // Convert Bitmap to a JPEG Byte Array
+    val baos = ByteArrayOutputStream()
+    bitmap.compress(Bitmap.CompressFormat.JPEG, QUALITY_COMPRESSION, baos)
+    val imageData = baos.toByteArray()
+
+    // Define a storage reference with a unique photoId
+    val storageRef = storage.reference.child("images/$photoId.jpg")
+
+    storageRef
+        .putBytes(imageData)
+        .addOnSuccessListener {
+          // Get the download URL after successful upload
+          storageRef.downloadUrl
+              .addOnSuccessListener { url ->
+                callback(Result.success(url.toString())) // Return the URL
+              }
+              .addOnFailureListener { e -> callback(Result.failure(e)) }
+        }
+        .addOnFailureListener { e -> callback(Result.failure(e)) }
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/endtoend/ChatEndToEnd.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/endtoend/ChatEndToEnd.kt b/app/src/androidTest/java/com/android/bookswap/endtoend/ChatEndToEnd.kt
new file mode 100644
--- /dev/null	(date 1731617442887)
+++ b/app/src/androidTest/java/com/android/bookswap/endtoend/ChatEndToEnd.kt	(date 1731617442887)
@@ -0,0 +1,367 @@
+package com.android.bookswap.endtoend
+
+import android.content.Context
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.ui.geometry.Offset
+import androidx.compose.ui.semantics.SemanticsActions
+import androidx.compose.ui.semantics.SemanticsProperties
+import androidx.compose.ui.semantics.getOrNull
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.assertTextEquals
+import androidx.compose.ui.test.down
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.moveBy
+import androidx.compose.ui.test.onAllNodesWithTag
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.compose.ui.test.performClick
+import androidx.compose.ui.test.performGesture
+import androidx.compose.ui.test.performSemanticsAction
+import androidx.compose.ui.test.performTextClearance
+import androidx.compose.ui.test.performTextInput
+import androidx.compose.ui.test.up
+import com.android.bookswap.data.DataMessage
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.MessageBox
+import com.android.bookswap.data.MessageType
+import com.android.bookswap.data.repository.MessageRepository
+import com.android.bookswap.ui.chat.ChatScreen
+import com.android.bookswap.ui.chat.ListChatScreen
+import com.android.bookswap.ui.chat.imageTestMessageUUID
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.navigation.TopLevelDestination
+import com.google.firebase.firestore.ListenerRegistration
+import io.mockk.every
+import io.mockk.mockk
+import java.util.UUID
+import org.junit.Assert.assertEquals
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+class ChatEndToEnd {
+  @get:Rule val composeTestRule = createComposeRule()
+
+  private lateinit var mockNavigationActions: NavigationActions
+  private lateinit var mockMessageRepository: MockMessageRepository
+  private val navigateToChatScreen = mutableStateOf(false)
+  private val currentUserUUID = UUID.fromString("550e8400-e29b-41d4-a716-446655440002") // John Doe
+  private val otherUserUUID = UUID.fromString("550e8400-e29b-41d4-a716-446655440001") // Other user
+
+  @Before
+  fun setup() {
+    // Initialize the mock message repository with placeholder messages
+    mockMessageRepository = MockMessageRepository()
+
+    // Initialize mock navigation actions
+    mockNavigationActions = mockk(relaxed = true)
+
+    // Mock the `navigateTo(destination: TopLevelDestination)` method
+    every { mockNavigationActions.navigateTo(any<TopLevelDestination>()) } answers
+        {
+          // Update the navigation state to switch screens
+          navigateToChatScreen.value = true
+        }
+
+    // Mock the `navigateTo(screen: String, otherUserUUID: String)` method
+    every { mockNavigationActions.navigateTo(any<String>(), any<String>()) } answers
+        {
+          navigateToChatScreen.value = true
+        }
+
+    // Mock the `navigateTo(screen: String)` method
+    every { mockNavigationActions.navigateTo(any<String>()) } answers
+        {
+          navigateToChatScreen.value = true
+        }
+
+    // Mock `goBack()` to update the state to simulate going back to the previous screen
+    every { mockNavigationActions.goBack() } answers { navigateToChatScreen.value = false }
+
+    val placeholderMessages =
+        listOf(
+            DataMessage(
+                messageType = MessageType.TEXT,
+                uuid = UUID.randomUUID(),
+                senderUUID = otherUserUUID,
+                receiverUUID = currentUserUUID,
+                text = "Welcome to the chat!",
+                timestamp = System.currentTimeMillis() - 100000),
+            DataMessage(
+                messageType = MessageType.TEXT,
+                uuid = UUID.randomUUID(),
+                senderUUID = currentUserUUID,
+                receiverUUID = otherUserUUID,
+                text = "Thank you!",
+                timestamp = System.currentTimeMillis() - 50000),
+            DataMessage(
+                messageType = MessageType.IMAGE,
+                uuid = imageTestMessageUUID,
+                senderUUID = otherUserUUID,
+                receiverUUID = currentUserUUID,
+                text = "Image Message",
+                timestamp = System.currentTimeMillis()))
+
+    placeholderMessages.forEach { mockMessageRepository.sendMessage(it) { /* No-op */} }
+  }
+
+  @Test
+  fun testChatNavigationAndMessageManipulation() {
+
+    composeTestRule.setContent {
+      if (navigateToChatScreen.value) {
+        ChatScreen(
+            messageRepository = mockMessageRepository,
+            currentUser =
+                DataUser(
+                    userUUID = currentUserUUID,
+                    greeting = "Mr.",
+                    firstName = "John",
+                    lastName = "Doe",
+                    email = "",
+                    phoneNumber = "",
+                    longitude = 0.0,
+                    latitude = 0.0,
+                    profilePictureUrl = "",
+                    bookList = emptyList(),
+                    googleUid = ""),
+            otherUser =
+                DataUser(
+                    userUUID = otherUserUUID,
+                    greeting = "Mr.",
+                    firstName = "Tester",
+                    lastName = "User",
+                    email = "",
+                    phoneNumber = "",
+                    longitude = 0.0,
+                    latitude = 0.0,
+                    profilePictureUrl = "",
+                    bookList = emptyList(),
+                    googleUid = ""),
+            navController = mockNavigationActions)
+      } else {
+        ListChatScreen(
+            placeHolderData =
+                listOf(
+                    MessageBox(
+                        contact =
+                            DataUser(
+                                userUUID = currentUserUUID,
+                                greeting = "Mr.",
+                                firstName = "John",
+                                lastName = "Doe",
+                                email = "",
+                                phoneNumber = "",
+                                longitude = 0.0,
+                                latitude = 0.0,
+                                profilePictureUrl = "",
+                                bookList = emptyList(),
+                                googleUid = ""),
+                        message = "Hello",
+                        date = "Today")),
+            navigationActions = mockNavigationActions,
+            topAppBar = {},
+            bottomAppBar = {})
+      }
+    }
+    // Simulate navigating to the chat screen by clicking on John Doe's message box
+    composeTestRule.onNodeWithTag("chat_messageBox").assertExists().performClick()
+
+    // Wait until placeholder messages appear
+    val firstPlaceholderUUID = mockMessageRepository.messages[0].uuid
+    val secondPlaceholderUUID = mockMessageRepository.messages[1].uuid
+
+    composeTestRule.waitUntil(timeoutMillis = 5000) {
+      composeTestRule
+          .onAllNodesWithTag("message_text $firstPlaceholderUUID", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isNotEmpty()
+    }
+
+    // Assert that ChatScreen is displayed by checking for placeholder messages
+    composeTestRule
+        .onNodeWithTag("message_text $firstPlaceholderUUID", useUnmergedTree = true)
+        .assertExists()
+    composeTestRule
+        .onNodeWithTag("message_text $secondPlaceholderUUID", useUnmergedTree = true)
+        .assertExists()
+
+    composeTestRule.waitUntil(timeoutMillis = 5001) {
+      composeTestRule
+          .onAllNodesWithTag("hobbit", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isNotEmpty()
+    }
+    composeTestRule.onNodeWithTag("hobbit", useUnmergedTree = true).assertExists()
+
+    // Send a new text message
+    val newMessage = "Hello, World!"
+    composeTestRule.onNodeWithTag("message_input_field").performTextInput(newMessage)
+    composeTestRule.onNodeWithTag("send_button").performClick()
+
+    // Wait until the new message appears
+    val newMessageUUID = mockMessageRepository.messages.first().uuid
+    // **DATA LAYER CHECK**: Verify that the message was added to the mockMessageRepository
+    composeTestRule.runOnIdle {
+      val addedMessage = mockMessageRepository.messages.lastOrNull()
+      assertEquals(newMessage, addedMessage?.text)
+      assertEquals(currentUserUUID.toString(), addedMessage?.senderUUID.toString())
+      assertEquals(otherUserUUID.toString(), addedMessage?.receiverUUID.toString())
+    }
+
+    // **EDIT STEP**: Long-press to edit the message
+    composeTestRule
+        .onNodeWithTag("message_item $newMessageUUID", useUnmergedTree = true)
+        .performSemanticsAction(SemanticsActions.OnLongClick)
+
+    // Click on the edit button, modify the message text, and save
+    composeTestRule.onNodeWithTag("editButton", useUnmergedTree = true).performClick()
+    val editedMessage = "Updated Message"
+    composeTestRule
+        .onNodeWithTag("message_input_field", useUnmergedTree = true)
+        .performTextClearance()
+    composeTestRule
+        .onNodeWithTag("message_input_field", useUnmergedTree = true)
+        .performTextInput(editedMessage)
+    composeTestRule.onNodeWithTag("send_button", useUnmergedTree = true).performClick()
+
+    // Wait for the edited message to appear
+    composeTestRule.waitUntil(timeoutMillis = 5003) {
+      composeTestRule
+          .onAllNodesWithTag("message_text $newMessageUUID", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .any {
+            it.config.getOrNull(SemanticsProperties.Text)?.firstOrNull()?.text == editedMessage
+          }
+    }
+
+    // Assert the message text is updated
+    composeTestRule
+        .onNodeWithTag("message_text $newMessageUUID", useUnmergedTree = true)
+        .assertExists()
+        .assertTextEquals(editedMessage)
+
+    // **DELETE STEP**: Long-press to delete the edited message
+    composeTestRule
+        .onNodeWithTag("message_item $newMessageUUID", useUnmergedTree = true)
+        .performSemanticsAction(SemanticsActions.OnLongClick)
+
+    // Click on the delete button
+    composeTestRule.onNodeWithTag("deleteButton", useUnmergedTree = true).performClick()
+
+    // Wait until the message is deleted
+    composeTestRule.waitUntil(timeoutMillis = 5004) {
+      composeTestRule
+          .onAllNodesWithTag("message_text $newMessageUUID", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isEmpty()
+    }
+
+    // Assert the message no longer exists
+    composeTestRule
+        .onNodeWithTag("message_text $newMessageUUID", useUnmergedTree = true)
+        .assertDoesNotExist()
+
+    // **IMAGE INTERACTION STEP**: Locate and click on the image message
+    val imageMessageUUID =
+        mockMessageRepository.messages[2].uuid // Assuming this is the image message's UUID
+    composeTestRule.onNodeWithTag("hobbit", useUnmergedTree = true).assertExists().performClick()
+
+    // Wait for the popup to appear
+    composeTestRule.waitUntil(timeoutMillis = 5005) {
+      composeTestRule
+          .onAllNodesWithTag("popupImage", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isNotEmpty()
+    }
+    composeTestRule.onNodeWithTag("popupImage", useUnmergedTree = true).assertIsDisplayed()
+
+    // **SIMULATED ZOOM STEP**: Perform scaling on the image popup to simulate zoom
+    composeTestRule.onNodeWithTag("popupImage", useUnmergedTree = true).performGesture {
+      down(Offset(150f, 150f)) // Simulate a finger press at the center of the image
+      moveBy(Offset(50f, 50f)) // Simulate a drag to increase the scale
+      up() // Release the finger to end the gesture
+    }
+
+    // Wait until the popup is closed
+    composeTestRule.waitUntil(timeoutMillis = 5006) {
+      composeTestRule
+          .onAllNodesWithTag("popupImage", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isEmpty()
+    }
+    composeTestRule.onNodeWithTag("popupImage", useUnmergedTree = true).assertDoesNotExist()
+
+    // Go back to the chat list screen
+    composeTestRule.onNodeWithTag("backIcon", useUnmergedTree = true).performClick()
+    composeTestRule.onNodeWithTag("chat_listScreen", useUnmergedTree = true).assertExists()
+  }
+
+  class MockMessageRepository : MessageRepository {
+    val messages = mutableListOf<DataMessage>()
+    private var nextUUID = UUID.randomUUID()
+
+    override fun getNewUUID(): UUID {
+      val currentUUID = nextUUID
+      nextUUID = UUID.randomUUID()
+      return currentUUID
+    }
+
+    override fun init(callback: (Result<Unit>) -> Unit) {
+      callback(Result.success(Unit)) // Simulates successful initialization
+    }
+
+    override fun getMessages(callback: (Result<List<DataMessage>>) -> Unit) {
+      callback(Result.success(messages))
+    }
+
+    override fun sendMessage(message: DataMessage, callback: (Result<Unit>) -> Unit) {
+      messages.add(message)
+      callback(Result.success(Unit))
+    }
+
+    override fun deleteMessage(
+        messageUUID: UUID,
+        callback: (Result<Unit>) -> Unit,
+        context: Context
+    ) {
+      messages.removeIf { it.uuid == messageUUID }
+      callback(Result.success(Unit))
+    }
+
+    override fun deleteAllMessages(
+        user1UUID: UUID,
+        user2UUID: UUID,
+        callback: (Result<Unit>) -> Unit
+    ) {
+      messages.removeIf {
+        (it.senderUUID == user1UUID && it.receiverUUID == user2UUID) ||
+            (it.senderUUID == user2UUID && it.receiverUUID == user1UUID)
+      }
+      callback(Result.success(Unit))
+    }
+
+    override fun updateMessage(
+        message: DataMessage,
+        callback: (Result<Unit>) -> Unit,
+        context: Context
+    ) {
+      val index = messages.indexOfFirst { it.uuid == message.uuid }
+      if (index != -1) {
+        messages[index] = message.copy(text = message.text) // Update the message text
+        callback(Result.success(Unit))
+      } else {
+        callback(Result.failure(Exception("Message not found")))
+      }
+    }
+
+    override fun addMessagesListener(
+        otherUserUUID: UUID,
+        currentUserUUID: UUID,
+        callback: (Result<List<DataMessage>>) -> Unit
+    ): ListenerRegistration {
+      // Immediately provide the existing messages for testing
+      callback(Result.success(messages))
+      return mockk() // Return a mock ListenerRegistration
+    }
+  }
+}
Index: app/src/main/java/com/android/bookswap/ui/navigation/NavigationActions.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/navigation/NavigationActions.kt b/app/src/main/java/com/android/bookswap/ui/navigation/NavigationActions.kt
new file mode 100644
--- /dev/null	(date 1731617442000)
+++ b/app/src/main/java/com/android/bookswap/ui/navigation/NavigationActions.kt	(date 1731617442000)
@@ -0,0 +1,132 @@
+package com.android.bookswap.ui.navigation
+
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.filled.MailOutline
+import androidx.compose.material.icons.outlined.AccountCircle
+import androidx.compose.material.icons.outlined.AddCircle
+import androidx.compose.material.icons.outlined.Place
+import androidx.compose.ui.graphics.vector.ImageVector
+import androidx.navigation.NavGraph.Companion.findStartDestination
+import androidx.navigation.NavHostController
+
+object Route {
+  const val CHAT = "Chat"
+  const val PROFILE = "Profile"
+  const val MAP = "Map"
+  const val NEWBOOK = "NewBook"
+  const val AUTH = "Auth"
+}
+
+object Screen {
+  const val AUTH = "Auth Screen"
+  const val CHATLIST = "ChatList Screen"
+  const val CHAT = "Chat Screen"
+  const val MAP = "Map Screen"
+  const val NEWBOOK = "NewBook Screen"
+  const val ADD_BOOK_MANUALLY = "AddBookManually Screen"
+  const val ADD_BOOK_SCAN = "AddBookScan Screen"
+  const val ADD_BOOK_ISBN = "AddBookISBN Screen"
+  const val SETTINGS = "Settings Screen"
+  const val FILTER = "Filter Screen"
+  const val PROFILE = "Profile Screen"
+  const val NEW_USER = "New User Screen"
+}
+
+data class TopLevelDestination(val route: String, val icon: ImageVector, val textId: String)
+
+object TopLevelDestinations {
+  val CHAT =
+      TopLevelDestination(route = Route.CHAT, icon = Icons.Filled.MailOutline, textId = "Chat")
+  val MAP = TopLevelDestination(route = Route.MAP, icon = Icons.Outlined.Place, textId = "Map")
+  val NEW_BOOK =
+      TopLevelDestination(
+          route = Route.NEWBOOK, icon = Icons.Outlined.AddCircle, textId = "New Book")
+  val PROFILE =
+      TopLevelDestination(
+          route = Route.PROFILE, icon = Icons.Outlined.AccountCircle, textId = "Profile")
+}
+/** List of top level destinations that are shown in the bottom navigation bar */
+val List_Navigation_Bar_Destinations =
+    listOf(TopLevelDestinations.CHAT, TopLevelDestinations.NEW_BOOK, TopLevelDestinations.MAP)
+
+open class NavigationActions(
+    private val navController: NavHostController,
+) {
+  /**
+   * Navigate to the specified [TopLevelDestination]
+   *
+   * @param destination The top level destination to navigate to Clear the back stack when
+   *   navigating to a new destination This is useful when navigating to a new screen from the
+   *   bottom navigation bar as we don't want to keep the previous screen in the back stack
+   */
+  open fun navigateTo(destination: TopLevelDestination) {
+
+    // Only navigate if the route is different from the current route
+    if (!isCurrentDestination(destination.route)) {
+      navController.navigate(destination.route) {
+        // Pop up to the start destination of the graph to
+        // avoid building up a large stack of destinations
+        popUpTo(navController.graph.findStartDestination().id) {
+          saveState = true
+          inclusive = true
+        }
+
+        // Avoid multiple copies of the same destination when reelecting same item
+        launchSingleTop = true
+
+        // Restore state when reelecting a previously selected item
+        if (destination.route != Route.AUTH) {
+          restoreState = true
+        }
+      }
+    }
+  }
+
+  /**
+   * Navigate to the specified screen with optional parameters.
+   *
+   * @param screen The screen to navigate to
+   * @param user1 The first user to pass to the screen
+   * @param user2 The second user to pass to the screen
+   */
+  open fun navigateTo(screen: String, otherUserUUID: String) {
+    val route = "$screen/$otherUserUUID"
+    // Only navigate if the route is different from the current route
+    if (!isCurrentDestination(route)) {
+      navController.navigate(route)
+    }
+  }
+
+  /**
+   * Navigate to the specified screen.
+   *
+   * @param screen The screen to navigate to
+   */
+  open fun navigateTo(screen: String) {
+    // Only navigate if the route is different from the current route
+    if (!isCurrentDestination(screen)) {
+      navController.navigate(screen)
+    }
+  }
+
+  /** Navigate back to the previous screen. */
+  open fun goBack() {
+    navController.popBackStack()
+  }
+
+  /**
+   * Get the current route of the navigation controller.
+   *
+   * @return The current route
+   */
+  open fun currentRoute(): String {
+    return navController.currentDestination?.route ?: ""
+  }
+
+  private fun isCurrentDestination(route: String): Boolean {
+    // Retrieve the current route and check if it starts with the same route name (as checking
+    // equality of the route name didn't worked)
+    val currentRoute = currentRoute()
+    return currentRoute.startsWith(route)
+  }
+}
Index: app/src/main/java/com/android/bookswap/data/repository/PhotoFirebaseStorageRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/repository/PhotoFirebaseStorageRepository.kt b/app/src/main/java/com/android/bookswap/data/repository/PhotoFirebaseStorageRepository.kt
new file mode 100644
--- /dev/null	(date 1731617442889)
+++ b/app/src/main/java/com/android/bookswap/data/repository/PhotoFirebaseStorageRepository.kt	(date 1731617442889)
@@ -0,0 +1,11 @@
+package com.android.bookswap.data.repository
+
+import android.graphics.Bitmap
+
+interface PhotoFirebaseStorageRepository {
+
+  fun init(callback: (Result<Unit>) -> Unit)
+
+  fun addPhotoToStorage(photoId: String, bitmap: Bitmap, callback: (Result<String>) -> Unit)
+  // getphoto is useless (as we can use the url to directly retrieve the picture and show it )
+}
Index: app/src/main/java/com/android/bookswap/ui/theme/Theme.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/theme/Theme.kt b/app/src/main/java/com/android/bookswap/ui/theme/Theme.kt
new file mode 100644
--- /dev/null	(date 1731615667000)
+++ b/app/src/main/java/com/android/bookswap/ui/theme/Theme.kt	(date 1731615667000)
@@ -0,0 +1,291 @@
+package com.android.bookswap.ui.theme
+
+import android.app.Activity
+import android.os.Build
+import androidx.compose.foundation.isSystemInDarkTheme
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.darkColorScheme
+import androidx.compose.material3.dynamicDarkColorScheme
+import androidx.compose.material3.dynamicLightColorScheme
+import androidx.compose.material3.lightColorScheme
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.Immutable
+import androidx.compose.runtime.SideEffect
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.graphics.toArgb
+import androidx.compose.ui.platform.LocalContext
+import androidx.compose.ui.platform.LocalView
+import androidx.core.view.WindowCompat
+
+private val lightScheme =
+    lightColorScheme(
+        primary = primaryLight,
+        onPrimary = onPrimaryLight,
+        primaryContainer = primaryContainerLight,
+        onPrimaryContainer = onPrimaryContainerLight,
+        secondary = secondaryLight,
+        onSecondary = onSecondaryLight,
+        secondaryContainer = secondaryContainerLight,
+        onSecondaryContainer = onSecondaryContainerLight,
+        tertiary = tertiaryLight,
+        onTertiary = onTertiaryLight,
+        tertiaryContainer = tertiaryContainerLight,
+        onTertiaryContainer = onTertiaryContainerLight,
+        error = errorLight,
+        onError = onErrorLight,
+        errorContainer = errorContainerLight,
+        onErrorContainer = onErrorContainerLight,
+        background = backgroundLight,
+        onBackground = onBackgroundLight,
+        surface = surfaceLight,
+        onSurface = onSurfaceLight,
+        surfaceVariant = surfaceVariantLight,
+        onSurfaceVariant = onSurfaceVariantLight,
+        outline = outlineLight,
+        outlineVariant = outlineVariantLight,
+        scrim = scrimLight,
+        inverseSurface = inverseSurfaceLight,
+        inverseOnSurface = inverseOnSurfaceLight,
+        inversePrimary = inversePrimaryLight,
+        surfaceDim = surfaceDimLight,
+        surfaceBright = surfaceBrightLight,
+        surfaceContainerLowest = surfaceContainerLowestLight,
+        surfaceContainerLow = surfaceContainerLowLight,
+        surfaceContainer = surfaceContainerLight,
+        surfaceContainerHigh = surfaceContainerHighLight,
+        surfaceContainerHighest = surfaceContainerHighestLight,
+    )
+
+private val darkScheme =
+    darkColorScheme(
+        primary = primaryDark,
+        onPrimary = onPrimaryDark,
+        primaryContainer = primaryContainerDark,
+        onPrimaryContainer = onPrimaryContainerDark,
+        secondary = secondaryDark,
+        onSecondary = onSecondaryDark,
+        secondaryContainer = secondaryContainerDark,
+        onSecondaryContainer = onSecondaryContainerDark,
+        tertiary = tertiaryDark,
+        onTertiary = onTertiaryDark,
+        tertiaryContainer = tertiaryContainerDark,
+        onTertiaryContainer = onTertiaryContainerDark,
+        error = errorDark,
+        onError = onErrorDark,
+        errorContainer = errorContainerDark,
+        onErrorContainer = onErrorContainerDark,
+        background = backgroundDark,
+        onBackground = onBackgroundDark,
+        surface = surfaceDark,
+        onSurface = onSurfaceDark,
+        surfaceVariant = surfaceVariantDark,
+        onSurfaceVariant = onSurfaceVariantDark,
+        outline = outlineDark,
+        outlineVariant = outlineVariantDark,
+        scrim = scrimDark,
+        inverseSurface = inverseSurfaceDark,
+        inverseOnSurface = inverseOnSurfaceDark,
+        inversePrimary = inversePrimaryDark,
+        surfaceDim = surfaceDimDark,
+        surfaceBright = surfaceBrightDark,
+        surfaceContainerLowest = surfaceContainerLowestDark,
+        surfaceContainerLow = surfaceContainerLowDark,
+        surfaceContainer = surfaceContainerDark,
+        surfaceContainerHigh = surfaceContainerHighDark,
+        surfaceContainerHighest = surfaceContainerHighestDark,
+    )
+
+private val mediumContrastLightColorScheme =
+    lightColorScheme(
+        primary = primaryLightMediumContrast,
+        onPrimary = onPrimaryLightMediumContrast,
+        primaryContainer = primaryContainerLightMediumContrast,
+        onPrimaryContainer = onPrimaryContainerLightMediumContrast,
+        secondary = secondaryLightMediumContrast,
+        onSecondary = onSecondaryLightMediumContrast,
+        secondaryContainer = secondaryContainerLightMediumContrast,
+        onSecondaryContainer = onSecondaryContainerLightMediumContrast,
+        tertiary = tertiaryLightMediumContrast,
+        onTertiary = onTertiaryLightMediumContrast,
+        tertiaryContainer = tertiaryContainerLightMediumContrast,
+        onTertiaryContainer = onTertiaryContainerLightMediumContrast,
+        error = errorLightMediumContrast,
+        onError = onErrorLightMediumContrast,
+        errorContainer = errorContainerLightMediumContrast,
+        onErrorContainer = onErrorContainerLightMediumContrast,
+        background = backgroundLightMediumContrast,
+        onBackground = onBackgroundLightMediumContrast,
+        surface = surfaceLightMediumContrast,
+        onSurface = onSurfaceLightMediumContrast,
+        surfaceVariant = surfaceVariantLightMediumContrast,
+        onSurfaceVariant = onSurfaceVariantLightMediumContrast,
+        outline = outlineLightMediumContrast,
+        outlineVariant = outlineVariantLightMediumContrast,
+        scrim = scrimLightMediumContrast,
+        inverseSurface = inverseSurfaceLightMediumContrast,
+        inverseOnSurface = inverseOnSurfaceLightMediumContrast,
+        inversePrimary = inversePrimaryLightMediumContrast,
+        surfaceDim = surfaceDimLightMediumContrast,
+        surfaceBright = surfaceBrightLightMediumContrast,
+        surfaceContainerLowest = surfaceContainerLowestLightMediumContrast,
+        surfaceContainerLow = surfaceContainerLowLightMediumContrast,
+        surfaceContainer = surfaceContainerLightMediumContrast,
+        surfaceContainerHigh = surfaceContainerHighLightMediumContrast,
+        surfaceContainerHighest = surfaceContainerHighestLightMediumContrast,
+    )
+
+private val highContrastLightColorScheme =
+    lightColorScheme(
+        primary = primaryLightHighContrast,
+        onPrimary = onPrimaryLightHighContrast,
+        primaryContainer = primaryContainerLightHighContrast,
+        onPrimaryContainer = onPrimaryContainerLightHighContrast,
+        secondary = secondaryLightHighContrast,
+        onSecondary = onSecondaryLightHighContrast,
+        secondaryContainer = secondaryContainerLightHighContrast,
+        onSecondaryContainer = onSecondaryContainerLightHighContrast,
+        tertiary = tertiaryLightHighContrast,
+        onTertiary = onTertiaryLightHighContrast,
+        tertiaryContainer = tertiaryContainerLightHighContrast,
+        onTertiaryContainer = onTertiaryContainerLightHighContrast,
+        error = errorLightHighContrast,
+        onError = onErrorLightHighContrast,
+        errorContainer = errorContainerLightHighContrast,
+        onErrorContainer = onErrorContainerLightHighContrast,
+        background = backgroundLightHighContrast,
+        onBackground = onBackgroundLightHighContrast,
+        surface = surfaceLightHighContrast,
+        onSurface = onSurfaceLightHighContrast,
+        surfaceVariant = surfaceVariantLightHighContrast,
+        onSurfaceVariant = onSurfaceVariantLightHighContrast,
+        outline = outlineLightHighContrast,
+        outlineVariant = outlineVariantLightHighContrast,
+        scrim = scrimLightHighContrast,
+        inverseSurface = inverseSurfaceLightHighContrast,
+        inverseOnSurface = inverseOnSurfaceLightHighContrast,
+        inversePrimary = inversePrimaryLightHighContrast,
+        surfaceDim = surfaceDimLightHighContrast,
+        surfaceBright = surfaceBrightLightHighContrast,
+        surfaceContainerLowest = surfaceContainerLowestLightHighContrast,
+        surfaceContainerLow = surfaceContainerLowLightHighContrast,
+        surfaceContainer = surfaceContainerLightHighContrast,
+        surfaceContainerHigh = surfaceContainerHighLightHighContrast,
+        surfaceContainerHighest = surfaceContainerHighestLightHighContrast,
+    )
+
+private val mediumContrastDarkColorScheme =
+    darkColorScheme(
+        primary = primaryDarkMediumContrast,
+        onPrimary = onPrimaryDarkMediumContrast,
+        primaryContainer = primaryContainerDarkMediumContrast,
+        onPrimaryContainer = onPrimaryContainerDarkMediumContrast,
+        secondary = secondaryDarkMediumContrast,
+        onSecondary = onSecondaryDarkMediumContrast,
+        secondaryContainer = secondaryContainerDarkMediumContrast,
+        onSecondaryContainer = onSecondaryContainerDarkMediumContrast,
+        tertiary = tertiaryDarkMediumContrast,
+        onTertiary = onTertiaryDarkMediumContrast,
+        tertiaryContainer = tertiaryContainerDarkMediumContrast,
+        onTertiaryContainer = onTertiaryContainerDarkMediumContrast,
+        error = errorDarkMediumContrast,
+        onError = onErrorDarkMediumContrast,
+        errorContainer = errorContainerDarkMediumContrast,
+        onErrorContainer = onErrorContainerDarkMediumContrast,
+        background = backgroundDarkMediumContrast,
+        onBackground = onBackgroundDarkMediumContrast,
+        surface = surfaceDarkMediumContrast,
+        onSurface = onSurfaceDarkMediumContrast,
+        surfaceVariant = surfaceVariantDarkMediumContrast,
+        onSurfaceVariant = onSurfaceVariantDarkMediumContrast,
+        outline = outlineDarkMediumContrast,
+        outlineVariant = outlineVariantDarkMediumContrast,
+        scrim = scrimDarkMediumContrast,
+        inverseSurface = inverseSurfaceDarkMediumContrast,
+        inverseOnSurface = inverseOnSurfaceDarkMediumContrast,
+        inversePrimary = inversePrimaryDarkMediumContrast,
+        surfaceDim = surfaceDimDarkMediumContrast,
+        surfaceBright = surfaceBrightDarkMediumContrast,
+        surfaceContainerLowest = surfaceContainerLowestDarkMediumContrast,
+        surfaceContainerLow = surfaceContainerLowDarkMediumContrast,
+        surfaceContainer = surfaceContainerDarkMediumContrast,
+        surfaceContainerHigh = surfaceContainerHighDarkMediumContrast,
+        surfaceContainerHighest = surfaceContainerHighestDarkMediumContrast,
+    )
+
+private val highContrastDarkColorScheme =
+    darkColorScheme(
+        primary = primaryDarkHighContrast,
+        onPrimary = onPrimaryDarkHighContrast,
+        primaryContainer = primaryContainerDarkHighContrast,
+        onPrimaryContainer = onPrimaryContainerDarkHighContrast,
+        secondary = secondaryDarkHighContrast,
+        onSecondary = onSecondaryDarkHighContrast,
+        secondaryContainer = secondaryContainerDarkHighContrast,
+        onSecondaryContainer = onSecondaryContainerDarkHighContrast,
+        tertiary = tertiaryDarkHighContrast,
+        onTertiary = onTertiaryDarkHighContrast,
+        tertiaryContainer = tertiaryContainerDarkHighContrast,
+        onTertiaryContainer = onTertiaryContainerDarkHighContrast,
+        error = errorDarkHighContrast,
+        onError = onErrorDarkHighContrast,
+        errorContainer = errorContainerDarkHighContrast,
+        onErrorContainer = onErrorContainerDarkHighContrast,
+        background = backgroundDarkHighContrast,
+        onBackground = onBackgroundDarkHighContrast,
+        surface = surfaceDarkHighContrast,
+        onSurface = onSurfaceDarkHighContrast,
+        surfaceVariant = surfaceVariantDarkHighContrast,
+        onSurfaceVariant = onSurfaceVariantDarkHighContrast,
+        outline = outlineDarkHighContrast,
+        outlineVariant = outlineVariantDarkHighContrast,
+        scrim = scrimDarkHighContrast,
+        inverseSurface = inverseSurfaceDarkHighContrast,
+        inverseOnSurface = inverseOnSurfaceDarkHighContrast,
+        inversePrimary = inversePrimaryDarkHighContrast,
+        surfaceDim = surfaceDimDarkHighContrast,
+        surfaceBright = surfaceBrightDarkHighContrast,
+        surfaceContainerLowest = surfaceContainerLowestDarkHighContrast,
+        surfaceContainerLow = surfaceContainerLowDarkHighContrast,
+        surfaceContainer = surfaceContainerDarkHighContrast,
+        surfaceContainerHigh = surfaceContainerHighDarkHighContrast,
+        surfaceContainerHighest = surfaceContainerHighestDarkHighContrast,
+    )
+
+@Immutable
+data class ColorFamily(
+    val color: Color,
+    val onColor: Color,
+    val colorContainer: Color,
+    val onColorContainer: Color
+)
+
+val unspecified_scheme =
+    ColorFamily(Color.Unspecified, Color.Unspecified, Color.Unspecified, Color.Unspecified)
+
+@Composable
+fun BookSwapAppTheme(
+    darkTheme: Boolean = isSystemInDarkTheme(),
+    // Dynamic color is available on Android 12+
+    dynamicColor: Boolean = false,
+    content: @Composable () -> Unit
+) {
+  val colorScheme =
+      when {
+        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
+          val context = LocalContext.current
+          if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
+        }
+        darkTheme -> darkScheme
+        else -> lightScheme
+      }
+  val view = LocalView.current
+  if (!view.isInEditMode) {
+    SideEffect {
+      val window = (view.context as Activity).window
+      window.statusBarColor = colorScheme.primary.toArgb()
+      WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = darkTheme
+    }
+  }
+
+  MaterialTheme(colorScheme = colorScheme, typography = BookSwapTypography, content = content)
+}
Index: app/src/main/java/com/android/bookswap/ui/theme/Type.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/theme/Type.kt b/app/src/main/java/com/android/bookswap/ui/theme/Type.kt
new file mode 100644
--- /dev/null	(date 1731615667852)
+++ b/app/src/main/java/com/android/bookswap/ui/theme/Type.kt	(date 1731615667852)
@@ -0,0 +1,23 @@
+package com.android.bookswap.ui.theme
+
+import androidx.compose.material3.Typography
+
+// Set of Material typography styles to start with
+val BookSwapTypography =
+    Typography(
+        displayLarge = Typography().displayLarge.copy(),
+        displayMedium = Typography().displayMedium.copy(),
+        displaySmall = Typography().displaySmall.copy(),
+        headlineLarge = Typography().headlineLarge.copy(),
+        headlineMedium = Typography().headlineMedium.copy(),
+        headlineSmall = Typography().headlineSmall.copy(),
+        titleLarge = Typography().titleLarge.copy(),
+        titleMedium = Typography().titleMedium.copy(),
+        titleSmall = Typography().titleSmall.copy(),
+        bodyLarge = Typography().bodyLarge.copy(),
+        bodyMedium = Typography().bodyMedium.copy(),
+        bodySmall = Typography().bodySmall.copy(),
+        labelLarge = Typography().labelLarge.copy(),
+        labelMedium = Typography().labelMedium.copy(),
+        labelSmall = Typography().labelSmall.copy(),
+    )
Index: app/src/main/java/com/android/bookswap/ui/theme/Color.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/theme/Color.kt b/app/src/main/java/com/android/bookswap/ui/theme/Color.kt
new file mode 100644
--- /dev/null	(date 1731615667000)
+++ b/app/src/main/java/com/android/bookswap/ui/theme/Color.kt	(date 1731615667000)
@@ -0,0 +1,236 @@
+package com.android.bookswap.ui.theme
+
+import androidx.compose.ui.graphics.Color
+
+object ColorVariable {
+  val Purple80 = Color(0xFFD0BCFF)
+  val PurpleGrey80 = Color(0xFFCCC2DC)
+  val Pink80 = Color(0xFFEFB8C8)
+
+  val Purple40 = Color(0xFF6650a4)
+  val PurpleGrey40 = Color(0xFF625b71)
+  val Pink40 = Color(0xFF7D5260)
+
+  val BackGround = Color(0xFFF0EAD2)
+  val Accent = Color(0xFF6C584C)
+  val Primary = Color(0xFFADC178)
+  val AccentSecondary = Color(0xFFA98467)
+  val Secondary = Color(0xFFDDE5B6)
+  val Green = Color(0xFFADC178)
+}
+
+val primaryLight = Color(0xFF536525)
+val onPrimaryLight = Color(0xFFFFFFFF)
+val primaryContainerLight = Color(0xFFD6EB9C)
+val onPrimaryContainerLight = Color(0xFF151F00)
+val secondaryLight = Color(0xFF5A6147)
+val onSecondaryLight = Color(0xFFFFFFFF)
+val secondaryContainerLight = Color(0xFFDFE6C4)
+val onSecondaryContainerLight = Color(0xFF181E09)
+val tertiaryLight = Color(0xFF39665F)
+val onTertiaryLight = Color(0xFFFFFFFF)
+val tertiaryContainerLight = Color(0xFFBCECE3)
+val onTertiaryContainerLight = Color(0xFF00201C)
+val errorLight = Color(0xFFBA1A1A)
+val onErrorLight = Color(0xFFFFFFFF)
+val errorContainerLight = Color(0xFFFFDAD6)
+val onErrorContainerLight = Color(0xFF410002)
+val backgroundLight = Color(0xFFFAFAEE)
+val onBackgroundLight = Color(0xFF1B1C15)
+val surfaceLight = Color(0xFFFAFAEE)
+val onSurfaceLight = Color(0xFF1B1C15)
+val surfaceVariantLight = Color(0xFFE2E4D4)
+val onSurfaceVariantLight = Color(0xFF45483C)
+val outlineLight = Color(0xFFA98467)
+val outlineVariantLight = Color(0xFFC6C8B8)
+val scrimLight = Color(0xFF000000)
+val inverseSurfaceLight = Color(0xFF303129)
+val inverseOnSurfaceLight = Color(0xFFF2F1E5)
+val inversePrimaryLight = Color(0xFFBACF82)
+val surfaceDimLight = Color(0xFFDBDBCF)
+val surfaceBrightLight = Color(0xFFFAFAEE)
+val surfaceContainerLowestLight = Color(0xFFFFFFFF)
+val surfaceContainerLowLight = Color(0xFFF5F4E8)
+val surfaceContainerLight = Color(0xFFEFEFE2)
+val surfaceContainerHighLight = Color(0xFFE9E9DD)
+val surfaceContainerHighestLight = Color(0xFFE3E3D7)
+
+val primaryLightMediumContrast = Color(0xFF38480A)
+val onPrimaryLightMediumContrast = Color(0xFFFFFFFF)
+val primaryContainerLightMediumContrast = Color(0xFF697C39)
+val onPrimaryContainerLightMediumContrast = Color(0xFFFFFFFF)
+val secondaryLightMediumContrast = Color(0xFF3F452D)
+val onSecondaryLightMediumContrast = Color(0xFFFFFFFF)
+val secondaryContainerLightMediumContrast = Color(0xFF71785C)
+val onSecondaryContainerLightMediumContrast = Color(0xFFFFFFFF)
+val tertiaryLightMediumContrast = Color(0xFF1C4A43)
+val onTertiaryLightMediumContrast = Color(0xFFFFFFFF)
+val tertiaryContainerLightMediumContrast = Color(0xFF507D75)
+val onTertiaryContainerLightMediumContrast = Color(0xFFFFFFFF)
+val errorLightMediumContrast = Color(0xFF8C0009)
+val onErrorLightMediumContrast = Color(0xFFFFFFFF)
+val errorContainerLightMediumContrast = Color(0xFFDA342E)
+val onErrorContainerLightMediumContrast = Color(0xFFFFFFFF)
+val backgroundLightMediumContrast = Color(0xFFFAFAEE)
+val onBackgroundLightMediumContrast = Color(0xFF1B1C15)
+val surfaceLightMediumContrast = Color(0xFFFAFAEE)
+val onSurfaceLightMediumContrast = Color(0xFF1B1C15)
+val surfaceVariantLightMediumContrast = Color(0xFFE2E4D4)
+val onSurfaceVariantLightMediumContrast = Color(0xFF424438)
+val outlineLightMediumContrast = Color(0xFF5E6054)
+val outlineVariantLightMediumContrast = Color(0xFF7A7C6E)
+val scrimLightMediumContrast = Color(0xFF000000)
+val inverseSurfaceLightMediumContrast = Color(0xFF303129)
+val inverseOnSurfaceLightMediumContrast = Color(0xFFF2F1E5)
+val inversePrimaryLightMediumContrast = Color(0xFFBACF82)
+val surfaceDimLightMediumContrast = Color(0xFFDBDBCF)
+val surfaceBrightLightMediumContrast = Color(0xFFFAFAEE)
+val surfaceContainerLowestLightMediumContrast = Color(0xFFFFFFFF)
+val surfaceContainerLowLightMediumContrast = Color(0xFFF5F4E8)
+val surfaceContainerLightMediumContrast = Color(0xFFEFEFE2)
+val surfaceContainerHighLightMediumContrast = Color(0xFFE9E9DD)
+val surfaceContainerHighestLightMediumContrast = Color(0xFFE3E3D7)
+
+val primaryLightHighContrast = Color(0xFF1B2600)
+val onPrimaryLightHighContrast = Color(0xFFFFFFFF)
+val primaryContainerLightHighContrast = Color(0xFF38480A)
+val onPrimaryContainerLightHighContrast = Color(0xFFFFFFFF)
+val secondaryLightHighContrast = Color(0xFF1F240F)
+val onSecondaryLightHighContrast = Color(0xFFFFFFFF)
+val secondaryContainerLightHighContrast = Color(0xFF3F452D)
+val onSecondaryContainerLightHighContrast = Color(0xFFFFFFFF)
+val tertiaryLightHighContrast = Color(0xFF002823)
+val onTertiaryLightHighContrast = Color(0xFFFFFFFF)
+val tertiaryContainerLightHighContrast = Color(0xFF1C4A43)
+val onTertiaryContainerLightHighContrast = Color(0xFFFFFFFF)
+val errorLightHighContrast = Color(0xFF4E0002)
+val onErrorLightHighContrast = Color(0xFFFFFFFF)
+val errorContainerLightHighContrast = Color(0xFF8C0009)
+val onErrorContainerLightHighContrast = Color(0xFFFFFFFF)
+val backgroundLightHighContrast = Color(0xFFFAFAEE)
+val onBackgroundLightHighContrast = Color(0xFF1B1C15)
+val surfaceLightHighContrast = Color(0xFFFAFAEE)
+val onSurfaceLightHighContrast = Color(0xFF000000)
+val surfaceVariantLightHighContrast = Color(0xFFE2E4D4)
+val onSurfaceVariantLightHighContrast = Color(0xFF22251B)
+val outlineLightHighContrast = Color(0xFF424438)
+val outlineVariantLightHighContrast = Color(0xFF424438)
+val scrimLightHighContrast = Color(0xFF000000)
+val inverseSurfaceLightHighContrast = Color(0xFF303129)
+val inverseOnSurfaceLightHighContrast = Color(0xFFFFFFFF)
+val inversePrimaryLightHighContrast = Color(0xFFDFF5A5)
+val surfaceDimLightHighContrast = Color(0xFFDBDBCF)
+val surfaceBrightLightHighContrast = Color(0xFFFAFAEE)
+val surfaceContainerLowestLightHighContrast = Color(0xFFFFFFFF)
+val surfaceContainerLowLightHighContrast = Color(0xFFF5F4E8)
+val surfaceContainerLightHighContrast = Color(0xFFEFEFE2)
+val surfaceContainerHighLightHighContrast = Color(0xFFE9E9DD)
+val surfaceContainerHighestLightHighContrast = Color(0xFFE3E3D7)
+
+val primaryDark = Color(0xFFBACF82)
+val onPrimaryDark = Color(0xFF273500)
+val primaryContainerDark = Color(0xFF3C4D0E)
+val onPrimaryContainerDark = Color(0xFFD6EB9C)
+val secondaryDark = Color(0xFFC3CAAA)
+val onSecondaryDark = Color(0xFF2D331C)
+val secondaryContainerDark = Color(0xFF434931)
+val onSecondaryContainerDark = Color(0xFFDFE6C4)
+val tertiaryDark = Color(0xFFA1D0C7)
+val onTertiaryDark = Color(0xFF023731)
+val tertiaryContainerDark = Color(0xFF204E47)
+val onTertiaryContainerDark = Color(0xFFBCECE3)
+val errorDark = Color(0xFFFFB4AB)
+val onErrorDark = Color(0xFF690005)
+val errorContainerDark = Color(0xFF93000A)
+val onErrorContainerDark = Color(0xFFFFDAD6)
+val backgroundDark = Color(0xFF12140D)
+val onBackgroundDark = Color(0xFFE3E3D7)
+val surfaceDark = Color(0xFF12140D)
+val onSurfaceDark = Color(0xFFE3E3D7)
+val surfaceVariantDark = Color(0xFF45483C)
+val onSurfaceVariantDark = Color(0xFFC6C8B8)
+val outlineDark = Color(0xFF909284)
+val outlineVariantDark = Color(0xFF45483C)
+val scrimDark = Color(0xFF000000)
+val inverseSurfaceDark = Color(0xFFE3E3D7)
+val inverseOnSurfaceDark = Color(0xFF303129)
+val inversePrimaryDark = Color(0xFF536525)
+val surfaceDimDark = Color(0xFF12140D)
+val surfaceBrightDark = Color(0xFF383A32)
+val surfaceContainerLowestDark = Color(0xFF0D0F08)
+val surfaceContainerLowDark = Color(0xFF1B1C15)
+val surfaceContainerDark = Color(0xFF1F2019)
+val surfaceContainerHighDark = Color(0xFF292B23)
+val surfaceContainerHighestDark = Color(0xFF34362D)
+
+val primaryDarkMediumContrast = Color(0xFFBED386)
+val onPrimaryDarkMediumContrast = Color(0xFF111900)
+val primaryContainerDarkMediumContrast = Color(0xFF859852)
+val onPrimaryContainerDarkMediumContrast = Color(0xFF000000)
+val secondaryDarkMediumContrast = Color(0xFFC7CEAE)
+val onSecondaryDarkMediumContrast = Color(0xFF131805)
+val secondaryContainerDarkMediumContrast = Color(0xFF8D9476)
+val onSecondaryContainerDarkMediumContrast = Color(0xFF000000)
+val tertiaryDarkMediumContrast = Color(0xFFA5D4CB)
+val onTertiaryDarkMediumContrast = Color(0xFF001A17)
+val tertiaryContainerDarkMediumContrast = Color(0xFF6C9991)
+val onTertiaryContainerDarkMediumContrast = Color(0xFF000000)
+val errorDarkMediumContrast = Color(0xFFFFBAB1)
+val onErrorDarkMediumContrast = Color(0xFF370001)
+val errorContainerDarkMediumContrast = Color(0xFFFF5449)
+val onErrorContainerDarkMediumContrast = Color(0xFF000000)
+val backgroundDarkMediumContrast = Color(0xFF12140D)
+val onBackgroundDarkMediumContrast = Color(0xFFE3E3D7)
+val surfaceDarkMediumContrast = Color(0xFF12140D)
+val onSurfaceDarkMediumContrast = Color(0xFFFCFBEF)
+val surfaceVariantDarkMediumContrast = Color(0xFF45483C)
+val onSurfaceVariantDarkMediumContrast = Color(0xFFCACCBC)
+val outlineDarkMediumContrast = Color(0xFFA2A495)
+val outlineVariantDarkMediumContrast = Color(0xFF828477)
+val scrimDarkMediumContrast = Color(0xFF000000)
+val inverseSurfaceDarkMediumContrast = Color(0xFFE3E3D7)
+val inverseOnSurfaceDarkMediumContrast = Color(0xFF292B23)
+val inversePrimaryDarkMediumContrast = Color(0xFF3D4E0F)
+val surfaceDimDarkMediumContrast = Color(0xFF12140D)
+val surfaceBrightDarkMediumContrast = Color(0xFF383A32)
+val surfaceContainerLowestDarkMediumContrast = Color(0xFF0D0F08)
+val surfaceContainerLowDarkMediumContrast = Color(0xFF1B1C15)
+val surfaceContainerDarkMediumContrast = Color(0xFF1F2019)
+val surfaceContainerHighDarkMediumContrast = Color(0xFF292B23)
+val surfaceContainerHighestDarkMediumContrast = Color(0xFF34362D)
+
+val primaryDarkHighContrast = Color(0xFFF6FFD7)
+val onPrimaryDarkHighContrast = Color(0xFF000000)
+val primaryContainerDarkHighContrast = Color(0xFFBED386)
+val onPrimaryContainerDarkHighContrast = Color(0xFF000000)
+val secondaryDarkHighContrast = Color(0xFFF7FEDC)
+val onSecondaryDarkHighContrast = Color(0xFF000000)
+val secondaryContainerDarkHighContrast = Color(0xFFC7CEAE)
+val onSecondaryContainerDarkHighContrast = Color(0xFF000000)
+val tertiaryDarkHighContrast = Color(0xFFEBFFFA)
+val onTertiaryDarkHighContrast = Color(0xFF000000)
+val tertiaryContainerDarkHighContrast = Color(0xFFA5D4CB)
+val onTertiaryContainerDarkHighContrast = Color(0xFF000000)
+val errorDarkHighContrast = Color(0xFFFFF9F9)
+val onErrorDarkHighContrast = Color(0xFF000000)
+val errorContainerDarkHighContrast = Color(0xFFFFBAB1)
+val onErrorContainerDarkHighContrast = Color(0xFF000000)
+val backgroundDarkHighContrast = Color(0xFF12140D)
+val onBackgroundDarkHighContrast = Color(0xFFE3E3D7)
+val surfaceDarkHighContrast = Color(0xFF12140D)
+val onSurfaceDarkHighContrast = Color(0xFFFFFFFF)
+val surfaceVariantDarkHighContrast = Color(0xFF45483C)
+val onSurfaceVariantDarkHighContrast = Color(0xFFFBFCEB)
+val outlineDarkHighContrast = Color(0xFFCACCBC)
+val outlineVariantDarkHighContrast = Color(0xFFCACCBC)
+val scrimDarkHighContrast = Color(0xFF000000)
+val inverseSurfaceDarkHighContrast = Color(0xFFE3E3D7)
+val inverseOnSurfaceDarkHighContrast = Color(0xFF000000)
+val inversePrimaryDarkHighContrast = Color(0xFF222E00)
+val surfaceDimDarkHighContrast = Color(0xFF12140D)
+val surfaceBrightDarkHighContrast = Color(0xFF383A32)
+val surfaceContainerLowestDarkHighContrast = Color(0xFF0D0F08)
+val surfaceContainerLowDarkHighContrast = Color(0xFF1B1C15)
+val surfaceContainerDarkHighContrast = Color(0xFF1F2019)
+val surfaceContainerHighDarkHighContrast = Color(0xFF292B23)
+val surfaceContainerHighestDarkHighContrast = Color(0xFF34362D)
Index: app/src/main/java/com/android/bookswap/resources/C.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/resources/C.kt b/app/src/main/java/com/android/bookswap/resources/C.kt
new file mode 100644
--- /dev/null	(date 1730306755521)
+++ b/app/src/main/java/com/android/bookswap/resources/C.kt	(date 1730306755521)
@@ -0,0 +1,12 @@
+package com.android.bookswap.resources
+
+// Like R, but C
+object C {
+  object Tag {
+    const val greeting = "main_screen_greeting"
+    const val greeting_robo = "second_screen_greeting"
+
+    const val main_screen_container = "main_screen_container"
+    const val second_screen_container = "second_screen_container"
+  }
+}
Index: app/src/main/java/com/android/bookswap/utils/JSONUtils.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/utils/JSONUtils.kt b/app/src/main/java/com/android/bookswap/utils/JSONUtils.kt
new file mode 100644
--- /dev/null	(date 1731615499706)
+++ b/app/src/main/java/com/android/bookswap/utils/JSONUtils.kt	(date 1731615499706)
@@ -0,0 +1,20 @@
+package com.android.bookswap.utils
+
+import org.json.JSONArray
+import org.json.JSONObject
+
+fun JSONObject.getJSONObjectOrNull(name: String): JSONObject? {
+  return if (this.has(name)) this.getJSONObject(name) else null
+}
+
+fun JSONObject.getJSONArrayOrNull(name: String): JSONArray? {
+  return if (this.has(name)) this.getJSONArray(name) else null
+}
+
+fun JSONObject.getStringOrNull(name: String): String? {
+  return if (this.has(name)) this.getString(name) else null
+}
+
+fun JSONArray.getStringOrNull(index: Int): String? {
+  return if (!this.isNull(index)) this.getString(index) else null
+}
Index: app/src/main/java/com/android/bookswap/model/map/Geolocation.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/map/Geolocation.kt b/app/src/main/java/com/android/bookswap/model/map/Geolocation.kt
new file mode 100644
--- /dev/null	(date 1731615667000)
+++ b/app/src/main/java/com/android/bookswap/model/map/Geolocation.kt	(date 1731615667000)
@@ -0,0 +1,118 @@
+package com.android.bookswap.model.map
+
+import android.Manifest
+import android.annotation.SuppressLint
+import android.app.Activity
+import android.content.pm.PackageManager
+import android.os.Build
+import android.os.Looper
+import androidx.annotation.RequiresApi
+import androidx.compose.runtime.mutableStateOf
+import androidx.core.app.ActivityCompat
+import com.google.android.gms.location.FusedLocationProviderClient
+import com.google.android.gms.location.LocationCallback
+import com.google.android.gms.location.LocationRequest
+import com.google.android.gms.location.LocationResult
+import com.google.android.gms.location.LocationServices
+import kotlinx.coroutines.flow.MutableStateFlow
+
+const val REQUEST_LOCATION_PERMISSION = 1
+const val BACKGROUND_LOCATION_PERMISSION_REQUEST_CODE = 2
+
+/**
+ * Geolocation class manages the geolocation functionality and handles the required permissions for
+ * accessing location data.
+ * - To start receiving location updates, call startLocationUpdates().
+ * - To stop receiving updates, call stopLocationUpdates().
+ * - The current user's location can be checked using the latitude and longitude variables.
+ * - The current state of location updates can be checked using the isRunning variable.
+ *
+ * This class requires appropriate location permissions to function, including both foreground and
+ * optionally background location access.
+ */
+class Geolocation(private val activity: Activity) : IGeolocation {
+  private val fusedLocationClient: FusedLocationProviderClient =
+      LocationServices.getFusedLocationProviderClient(activity)
+  val isRunning = mutableStateOf(false)
+  override val latitude = MutableStateFlow(Double.NaN)
+  override val longitude = MutableStateFlow(Double.NaN)
+
+  /** Location request settings */
+  private val locationRequest: LocationRequest =
+      LocationRequest.create().apply {
+        interval = 10000 // Update interval in milliseconds
+        fastestInterval = 5000 // Fastest update interval in milliseconds
+        priority = LocationRequest.PRIORITY_HIGH_ACCURACY
+      }
+
+  private val locationCallback =
+      object : LocationCallback() {
+        override fun onLocationResult(p0: LocationResult) {
+          p0.lastLocation.let { location ->
+            // Handle the updated location here
+            latitude.value = location.latitude
+            longitude.value = location.longitude
+            // You can save this location or notify other parts of your app
+          }
+        }
+      }
+
+  /** Request location permissions */
+  private fun requestLocationPermissions() {
+    val permissions =
+        arrayOf(
+            Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION)
+    ActivityCompat.requestPermissions(activity, permissions, REQUEST_LOCATION_PERMISSION)
+  }
+
+  /** Check if permissions are granted */
+  private fun hasLocationPermissions(): Boolean {
+    return ActivityCompat.checkSelfPermission(activity, Manifest.permission.ACCESS_FINE_LOCATION) ==
+        PackageManager.PERMISSION_GRANTED &&
+        ActivityCompat.checkSelfPermission(activity, Manifest.permission.ACCESS_COARSE_LOCATION) ==
+            PackageManager.PERMISSION_GRANTED
+  }
+
+  @RequiresApi(Build.VERSION_CODES.Q)
+  private fun requestBackgroundPermissions() {
+    val permissions = arrayOf(Manifest.permission.ACCESS_BACKGROUND_LOCATION)
+    ActivityCompat.requestPermissions(
+        activity, permissions, BACKGROUND_LOCATION_PERMISSION_REQUEST_CODE)
+  }
+
+  @RequiresApi(Build.VERSION_CODES.Q)
+  private fun hasBackgroundPermissions(): Boolean {
+    return ActivityCompat.checkSelfPermission(
+        activity, Manifest.permission.ACCESS_BACKGROUND_LOCATION) ==
+        PackageManager.PERMISSION_GRANTED
+  }
+
+  /** Start location updates */
+  @SuppressLint("MissingPermission")
+  override fun startLocationUpdates() {
+    if (!isRunning.value) {
+      if (hasLocationPermissions()) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && !hasBackgroundPermissions()) {
+          requestBackgroundPermissions()
+        }
+        // can run without ACCESS_BACKGROUND_LOCATION but it is better if we have the permission
+        fusedLocationClient.requestLocationUpdates(
+            locationRequest, locationCallback, Looper.getMainLooper())
+        isRunning.value = true
+      } else {
+        requestLocationPermissions()
+        // need to check here for the permission, as otherwise the startLocationUpdates would just
+        // loop indefinitely if the user refuse to give the permission
+        if (hasLocationPermissions()) {
+          startLocationUpdates()
+        }
+      }
+    }
+  }
+
+  /** Stop location updates */
+  override fun stopLocationUpdates() {
+    fusedLocationClient.removeLocationUpdates(locationCallback)
+    isRunning.value = false
+  }
+}
Index: app/src/main/java/com/android/bookswap/data/repository/MessageRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/repository/MessageRepository.kt b/app/src/main/java/com/android/bookswap/data/repository/MessageRepository.kt
new file mode 100644
--- /dev/null	(date 1731615667845)
+++ b/app/src/main/java/com/android/bookswap/data/repository/MessageRepository.kt	(date 1731615667845)
@@ -0,0 +1,80 @@
+package com.android.bookswap.data.repository
+
+import android.content.Context
+import com.android.bookswap.data.DataMessage
+import com.google.firebase.firestore.ListenerRegistration
+import java.util.UUID
+
+interface MessageRepository {
+
+  /** Generates a new unique id for a message */
+  fun getNewUUID(): UUID
+
+  /**
+   * Initialize the repository
+   *
+   * @param callback callback function that receives Result.success() when operation succeed of
+   *   Result.failure(exception) if error
+   */
+  fun init(callback: (Result<Unit>) -> Unit)
+
+  /**
+   * Get all messages as a list
+   *
+   * @param callback callback function that receives list of messages if success
+   */
+  fun getMessages(
+      callback: (Result<List<DataMessage>>) -> Unit,
+  )
+
+  /**
+   * Add a message to the repository
+   *
+   * @param message message to be added
+   * @param callback callback function that receives Result.success() when operation succeed of
+   *   Result.failure(exception) if error
+   */
+  fun sendMessage(message: DataMessage, callback: (Result<Unit>) -> Unit)
+
+  /**
+   * Delete a message from the repository
+   *
+   * @param messageUUID UUID of message to be deleted
+   * @param callback callback function that receives Result.success() when operation succeed of
+   *   Result.failure(exception) if error
+   */
+  fun deleteMessage(messageUUID: UUID, callback: (Result<Unit>) -> Unit, context: Context)
+
+  /**
+   * Delete all messages of this chat from the repository
+   *
+   * @param user1UUID uuid of the first user
+   * @param user2UUID uuid of the second user
+   * @param callback callback function that receives Result.success() when operation succeed of
+   *   Result.failure(exception) if error
+   */
+  fun deleteAllMessages(user1UUID: UUID, user2UUID: UUID, callback: (Result<Unit>) -> Unit)
+
+  /**
+   * Update a message in the repository
+   *
+   * @param message message to be updated
+   * @param callback callback function that receives Result.success() when operation succeed of
+   *   Result.failure(exception) if error
+   */
+  fun updateMessage(message: DataMessage, callback: (Result<Unit>) -> Unit, context: Context)
+
+  /**
+   * Add a listener to the repository to get messages in real-time
+   *
+   * @param otherUserUUID UUID of the other user
+   * @param currentUserUUID UUID of the current user
+   * @param callback callback function that receives list of messages if success
+   * @return ListenerRegistration object that can be used to remove the listener
+   */
+  fun addMessagesListener(
+      otherUserUUID: UUID,
+      currentUserUUID: UUID,
+      callback: (Result<List<DataMessage>>) -> Unit
+  ): ListenerRegistration
+}
Index: app/src/main/java/com/android/bookswap/data/source/network/MessageFirestoreSource.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/source/network/MessageFirestoreSource.kt b/app/src/main/java/com/android/bookswap/data/source/network/MessageFirestoreSource.kt
new file mode 100644
--- /dev/null	(date 1731615667000)
+++ b/app/src/main/java/com/android/bookswap/data/source/network/MessageFirestoreSource.kt	(date 1731615667000)
@@ -0,0 +1,256 @@
+package com.android.bookswap.data.source.network
+
+import android.content.Context
+import android.util.Log
+import android.widget.Toast
+import com.android.bookswap.data.DataMessage
+import com.android.bookswap.data.MessageType
+import com.android.bookswap.data.repository.MessageRepository
+import com.google.firebase.firestore.DocumentSnapshot
+import com.google.firebase.firestore.FirebaseFirestore
+import com.google.firebase.firestore.ListenerRegistration
+import java.util.UUID
+
+const val COLLECTION_PATH = "messages"
+
+class MessageFirestoreSource(private val db: FirebaseFirestore) : MessageRepository {
+  override fun getNewUUID(): UUID {
+    return UUID.randomUUID()
+  }
+
+  override fun init(callback: (Result<Unit>) -> Unit) {
+    try {
+      callback(Result.success(Unit))
+    } catch (e: Exception) {
+      Log.e("MessageSource", "Initialization failed: ${e.message}")
+      callback(Result.failure(e))
+    }
+  }
+
+  override fun getMessages(callback: (Result<List<DataMessage>>) -> Unit) {
+    db.collection(COLLECTION_PATH).get().addOnCompleteListener { task ->
+      if (task.isSuccessful) {
+        val documents = task.result?.documents
+        if (!documents.isNullOrEmpty()) {
+          val messages = documents.mapNotNull { documentToMessage(it).getOrNull() }
+          callback(Result.success(messages))
+        } else {
+          callback(Result.success(emptyList()))
+        }
+      } else {
+        callback(Result.failure(task.exception ?: Exception("Unknown error fetching messages")))
+      }
+    }
+  }
+
+  override fun sendMessage(message: DataMessage, callback: (Result<Unit>) -> Unit) {
+    val messageMap =
+        mapOf(
+            "uuid" to message.uuid.toString(),
+            "text" to message.text,
+            "senderUUID" to message.senderUUID.toString(),
+            "receiverUUID" to message.receiverUUID.toString(),
+            "timestamp" to message.timestamp,
+            "messageType" to message.messageType.name)
+
+    db.collection(COLLECTION_PATH)
+        .document(message.uuid.toString())
+        .set(messageMap)
+        .addOnCompleteListener { result ->
+          if (result.isSuccessful) {
+            callback(Result.success(Unit))
+          } else {
+            callback(Result.failure(result.exception ?: Exception("Unknown error sending message")))
+          }
+        }
+  }
+
+  override fun deleteMessage(
+      messageUUID: UUID,
+      callback: (Result<Unit>) -> Unit,
+      context: Context
+  ) {
+    val fifteenMinutesInMillis = 15 * 60 * 1000
+    val currentTime = System.currentTimeMillis()
+
+    db.collection(COLLECTION_PATH).document(messageUUID.toString()).get().addOnCompleteListener {
+        task ->
+      if (task.isSuccessful) {
+        val document = task.result
+        if (document != null && document.exists()) {
+          val existingMessage = documentToMessage(document).getOrNull()
+          if (existingMessage != null) {
+            if (currentTime - existingMessage.timestamp <= fifteenMinutesInMillis) {
+              db.collection(COLLECTION_PATH)
+                  .document(messageUUID.toString())
+                  .delete()
+                  .addOnCompleteListener { deleteTask ->
+                    if (deleteTask.isSuccessful) {
+                      callback(Result.success(Unit))
+                    } else {
+                      callback(
+                          Result.failure(
+                              deleteTask.exception ?: Exception("Unknown error deleting message")))
+                    }
+                  }
+            } else {
+              Toast.makeText(
+                      context,
+                      "Message can only be deleted within 15 minutes of being sent",
+                      Toast.LENGTH_LONG)
+                  .show()
+              callback(
+                  Result.failure(
+                      Exception("Message can only be deleted within 15 minutes of being sent")))
+            }
+          } else {
+            callback(Result.failure(Exception("Message not found")))
+          }
+        } else {
+          callback(Result.failure(Exception("Message not found")))
+        }
+      } else {
+        callback(Result.failure(task.exception ?: Exception("Unknown error fetching message")))
+      }
+    }
+  }
+
+  override fun deleteAllMessages(
+      user1UUID: UUID,
+      user2UUID: UUID,
+      callback: (Result<Unit>) -> Unit
+  ) {
+    db.collection(COLLECTION_PATH)
+        .whereIn("senderUUID", listOf(user1UUID, user2UUID))
+        .whereIn("receiverUUID", listOf(user1UUID, user2UUID))
+        .whereNotEqualTo("senderUUID", "receiverUUID")
+        .get()
+        .addOnCompleteListener { task ->
+          if (task.isSuccessful) {
+            val documents = task.result
+            if (documents != null && !documents.isEmpty) {
+              val batch = db.batch()
+              documents.documents.forEach { document -> batch.delete(document.reference) }
+              batch.commit().addOnCompleteListener { deleteTask ->
+                if (deleteTask.isSuccessful) {
+                  callback(Result.success(Unit))
+                } else {
+                  callback(
+                      Result.failure(
+                          deleteTask.exception ?: Exception("Unknown error deleting messages")))
+                }
+              }
+            } else {
+              callback(Result.success(Unit))
+            }
+          } else {
+            callback(Result.failure(task.exception ?: Exception("Unknown error fetching messages")))
+          }
+        }
+  }
+
+  override fun updateMessage(
+      message: DataMessage,
+      callback: (Result<Unit>) -> Unit,
+      context: Context
+  ) {
+    val fifteenMinutesInMillis = 15 * 60 * 1000
+    val currentTime = System.currentTimeMillis()
+
+    db.collection(COLLECTION_PATH).document(message.uuid.toString()).get().addOnCompleteListener {
+        task ->
+      if (task.isSuccessful) {
+        val document = task.result
+        if (document != null && document.exists()) {
+          val existingMessage = documentToMessage(document).getOrNull()
+          if (existingMessage != null) {
+            if (currentTime - existingMessage.timestamp <= fifteenMinutesInMillis) {
+              val messageMap =
+                  mapOf(
+                      "text" to message.text,
+                      "timestamp" to currentTime,
+                      "messageType" to message.messageType.name)
+              db.collection(COLLECTION_PATH)
+                  .document(message.uuid.toString())
+                  .update(messageMap)
+                  .addOnCompleteListener { updateTask ->
+                    if (updateTask.isSuccessful) {
+                      callback(Result.success(Unit))
+                    } else {
+                      callback(
+                          Result.failure(
+                              updateTask.exception ?: Exception("Unknown error updating message")))
+                    }
+                  }
+            } else {
+              Toast.makeText(
+                      context,
+                      "Message can only be updated within 15 minutes of being sent",
+                      Toast.LENGTH_LONG)
+                  .show()
+              callback(
+                  Result.failure(
+                      Exception("Message can only be updated within 15 minutes of being sent")))
+            }
+          } else {
+            callback(Result.failure(Exception("Message not found")))
+          }
+        } else {
+          callback(Result.failure(Exception("Message not found")))
+        }
+      } else {
+        callback(Result.failure(task.exception ?: Exception("Unknown error fetching message")))
+      }
+    }
+  }
+
+  override fun addMessagesListener(
+      otherUserUUID: UUID,
+      currentUserUUID: UUID,
+      callback: (Result<List<DataMessage>>) -> Unit
+  ): ListenerRegistration {
+    return db.collection("messages")
+        .whereIn("senderId", listOf(currentUserUUID, otherUserUUID))
+        .whereIn("receiverId", listOf(currentUserUUID, otherUserUUID))
+        .whereNotEqualTo("senderId", "receiverId")
+        .addSnapshotListener { snapshot, e ->
+          if (e != null) {
+            callback(Result.failure(e))
+            return@addSnapshotListener
+          }
+
+          if (snapshot != null && !snapshot.isEmpty) {
+            val messages =
+                snapshot.documents
+                    .mapNotNull { document ->
+                      try {
+                        document.toObject(DataMessage::class.java)
+                      } catch (ex: Exception) {
+                        Log.e(
+                            "MessageSource", "Error converting document to Message: ${ex.message}")
+                        null
+                      }
+                    }
+                    .sortedBy { it.timestamp } // Sort messages by timestamp
+            callback(Result.success(messages))
+          } else {
+            callback(Result.success(emptyList()))
+          }
+        }
+  }
+}
+
+fun documentToMessage(document: DocumentSnapshot): Result<DataMessage> {
+  return try {
+    val type = MessageType.valueOf(document.getString("messageType")!!)
+    val uuid = UUID.fromString(document.getString("uuid")!!)
+    val text = document.getString("text")!!
+    val senderUUID = UUID.fromString(document.getString("senderUUID")!!)
+    val receiverUUID = UUID.fromString(document.getString("receiverUUID")!!)
+    val timestamp = document.getLong("timestamp")!!
+    Result.success(DataMessage(type, uuid, text, senderUUID, receiverUUID, timestamp))
+  } catch (e: Exception) {
+    Log.e("MessageSource", "Error converting document to Message: ${e.message}")
+    Result.failure(e)
+  }
+}
Index: app/src/main/java/com/android/bookswap/data/source/network/BookFirestoreSource.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/source/network/BookFirestoreSource.kt b/app/src/main/java/com/android/bookswap/data/source/network/BookFirestoreSource.kt
new file mode 100644
--- /dev/null	(date 1731617442000)
+++ b/app/src/main/java/com/android/bookswap/data/source/network/BookFirestoreSource.kt	(date 1731617442000)
@@ -0,0 +1,161 @@
+package com.android.bookswap.data.source.network
+
+import android.util.Log
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.repository.BooksRepository
+import com.google.android.gms.tasks.Task
+import com.google.firebase.Firebase
+import com.google.firebase.auth.auth
+import com.google.firebase.firestore.DocumentSnapshot
+import com.google.firebase.firestore.FirebaseFirestore
+import java.util.UUID
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.flow.asStateFlow
+
+// A class that implements the BooksRepository interface using Firebase Firestore as the data source
+class BooksFirestoreSource(private val db: FirebaseFirestore) : BooksRepository {
+
+  // Name of the Firestore collection that stores books
+  private val collectionBooks = "Books"
+
+  private val books_ = MutableStateFlow<List<DataBook>>(emptyList())
+  val books: StateFlow<List<DataBook>> = books_.asStateFlow()
+
+  // Selected todo, i.e the todo for the detail view
+  private val selectedBook_ = MutableStateFlow<DataBook?>(null)
+  val selectedBook: StateFlow<DataBook?> = selectedBook_.asStateFlow()
+  // Use this code in editBookScreen and modify the editBookScreen structure if needed when
+  // incorporating in the app navigation
+
+  override fun init(onSuccess: () -> Unit) {
+    Firebase.auth.addAuthStateListener {
+      if (it.currentUser != null) {
+        onSuccess()
+      }
+    }
+  }
+
+  override fun getNewUUID(): UUID {
+    return UUID.randomUUID()
+  }
+
+  override fun getBook(callback: (Result<List<DataBook>>) -> Unit) {
+    db.collection(collectionBooks).get().addOnCompleteListener { task ->
+      if (task.isSuccessful) {
+        // Maps Firestore documents to DataBook objects or returns an empty list
+        val books = task.result?.mapNotNull { document -> documentToBooks(document) } ?: emptyList()
+        callback(Result.success(books))
+      } else {
+        task.exception?.let { e -> callback(Result.failure(e)) }
+      }
+    }
+  }
+
+  override fun addBook(dataBook: DataBook, callback: (Result<Unit>) -> Unit) {
+    // Check if essential fields are non-null before attempting to save
+    if (dataBook.title.isBlank() ||
+        dataBook.author.isNullOrBlank() ||
+        dataBook.isbn.isNullOrBlank()) {
+      val exception = IllegalArgumentException("Missing required book fields.")
+      Log.e("BooksFirestoreRepository", "Failed to add book: ${exception.message}")
+      callback(Result.failure(exception))
+      return
+    }
+
+    Log.d("BooksFirestoreRepository", "Attempting to add book: ${dataBook.title}")
+
+    // Attempt to add book to Firestore
+    performFirestoreOperation(
+        db.collection(collectionBooks).document(dataBook.uuid.toString()).set(dataBook)) { result ->
+          if (result.isSuccess)
+              Log.d("BooksFirestoreRepository", "Book added successfully: ${dataBook.title}")
+          else {
+            val error = result.exceptionOrNull()!!
+            Log.e("BooksFirestoreRepository", "Failed to add book: ${error.message}", error)
+          }
+          callback(result)
+        }
+  }
+
+  override fun updateBook(dataBook: DataBook, callback: (Result<Unit>) -> Unit) {
+    performFirestoreOperation(
+        db.collection(collectionBooks).document(dataBook.uuid.toString()).set(dataBook), callback)
+  }
+
+  override fun deleteBooks(uuid: UUID, dataBook: DataBook, callback: (Result<Unit>) -> Unit) {
+    performFirestoreOperation(
+        db.collection(collectionBooks).document(dataBook.uuid.toString()).delete(), callback)
+  }
+
+  override fun getBooksList(
+      bookList: List<UUID>,
+      callback: (Result<Unit>) -> Unit
+  ): List<DataBook> {
+    val books = mutableListOf<DataBook>()
+    bookList.forEach { uuid ->
+      db.collection(collectionBooks).document(uuid.toString()).get().addOnCompleteListener { task ->
+        if (task.isSuccessful) {
+          task.result?.let { document ->
+            documentToBooks(document)?.let { book -> books.add(book) }
+          }
+        } else {
+          task.exception?.let { e -> callback(Result.failure(e)) }
+        }
+      }
+    }
+    return books
+  }
+
+  // Maps a Firestore document to a DataBook object
+  // If any required field is missing, returns null to avoid incomplete objects
+  fun documentToBooks(document: DocumentSnapshot): DataBook? {
+    return try {
+      val mostSignificantBits = document.getLong("uuid.mostSignificantBits") ?: return null
+      val leastSignificantBits = document.getLong("uuid.leastSignificantBits") ?: return null
+      val title = document.getString("title") ?: return null
+      val author = document.getString("author")
+      val description = document.getString("description")
+      val rating = document.getLong("rating")
+      val photo = document.getString("photo")
+      val isbn = document.getString("isbn")
+      val languageBook = BookLanguages.valueOf(document.getString("language") ?: return null)
+      val genres = document.get("genres") as? List<String> ?: emptyList()
+      val bookGenres =
+          genres.mapNotNull { genre ->
+            try {
+              BookGenres.valueOf(genre)
+            } catch (e: IllegalArgumentException) {
+              null
+            }
+          }
+      DataBook(
+          UUID(mostSignificantBits, leastSignificantBits),
+          title,
+          author,
+          description,
+          rating?.toInt(),
+          photo,
+          languageBook,
+          isbn,
+          bookGenres)
+    } catch (e: Exception) {
+      null // Return null in case of any exception during the conversion
+    }
+  }
+  /**
+   * Helper function to perform Firestore operations (add, update, delete) Executes the provided
+   * Firestore task and triggers success or failure callbacks
+   */
+  private fun performFirestoreOperation(task: Task<Void>, callback: (Result<Unit>) -> Unit) {
+    task.addOnCompleteListener { result ->
+      if (result.isSuccessful) {
+        callback(Result.success(Unit))
+      } else {
+        result.exception?.let { e -> callback(Result.failure(e)) }
+      }
+    }
+  }
+}
Index: app/src/test/java/com/android/bookswap/model/chat/DataMessageFirestoreSourceTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/model/chat/DataMessageFirestoreSourceTest.kt b/app/src/test/java/com/android/bookswap/model/chat/DataMessageFirestoreSourceTest.kt
new file mode 100644
--- /dev/null	(date 1731615667000)
+++ b/app/src/test/java/com/android/bookswap/model/chat/DataMessageFirestoreSourceTest.kt	(date 1731615667000)
@@ -0,0 +1,590 @@
+package com.android.bookswap.model.chat
+
+import android.content.Context
+import android.os.Looper
+import androidx.test.core.app.ApplicationProvider
+import com.android.bookswap.data.DataMessage
+import com.android.bookswap.data.MessageType
+import com.android.bookswap.data.source.network.COLLECTION_PATH
+import com.android.bookswap.data.source.network.MessageFirestoreSource
+import com.android.bookswap.data.source.network.documentToMessage
+import com.google.android.gms.tasks.Tasks
+import com.google.firebase.FirebaseApp
+import com.google.firebase.firestore.CollectionReference
+import com.google.firebase.firestore.DocumentReference
+import com.google.firebase.firestore.DocumentSnapshot
+import com.google.firebase.firestore.FirebaseFirestore
+import com.google.firebase.firestore.FirebaseFirestoreSettings
+import com.google.firebase.firestore.QuerySnapshot
+import com.google.firebase.firestore.WriteBatch
+import java.util.UUID
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.ArgumentMatchers
+import org.mockito.Mock
+import org.mockito.Mockito.mock
+import org.mockito.Mockito.verify
+import org.mockito.Mockito.`when`
+import org.mockito.MockitoAnnotations
+import org.robolectric.RobolectricTestRunner
+import org.robolectric.Shadows.shadowOf
+
+@RunWith(RobolectricTestRunner::class)
+class DataMessageFirestoreSourceTest {
+
+  @Mock private lateinit var mockFirestore: FirebaseFirestore
+  @Mock private lateinit var mockCollectionReference: CollectionReference
+  @Mock private lateinit var mockDocumentReference: DocumentReference
+  @Mock private lateinit var mockDocumentSnapshot: DocumentSnapshot
+  @Mock private lateinit var mockQuerySnapshot: QuerySnapshot
+  @Mock private lateinit var mockContext: Context
+
+  private lateinit var firestore: FirebaseFirestore
+  private lateinit var messageRepository: MessageFirestoreSource
+  private lateinit var messageFirestoreSource: MessageFirestoreSource
+
+  private val testMessage =
+      DataMessage(
+          messageType = MessageType.TEXT,
+          uuid = UUID.randomUUID(),
+          text = "Test message",
+          senderUUID = UUID.randomUUID(),
+          receiverUUID = UUID.randomUUID(),
+          timestamp = System.currentTimeMillis())
+
+  @Before
+  fun setUp() {
+    MockitoAnnotations.openMocks(this)
+
+    // Initialize Firebase if necessary
+    if (FirebaseApp.getApps(ApplicationProvider.getApplicationContext()).isEmpty()) {
+      FirebaseApp.initializeApp(ApplicationProvider.getApplicationContext())
+    }
+
+    firestore = FirebaseFirestore.getInstance()
+    firestore.useEmulator("localhost", 8080)
+    firestore.firestoreSettings =
+        FirebaseFirestoreSettings.Builder().setPersistenceEnabled(false).build()
+
+    messageFirestoreSource = MessageFirestoreSource(mockFirestore)
+    messageRepository = MessageFirestoreSource(firestore)
+
+    `when`(mockFirestore.collection(ArgumentMatchers.anyString()))
+        .thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(ArgumentMatchers.anyString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
+  }
+
+  // Init Tests
+  @Test
+  fun init_invokesCallbackOnSuccess() {
+    messageFirestoreSource.init { result -> assert(result.isSuccess) }
+  }
+
+  // GetMessages Tests
+  @Test
+  fun getMessages_returnsMessagesOnSuccess() {
+    // Arrange
+    val documents = listOf(mockDocumentSnapshot)
+    val expectedMessage = testMessage
+    `when`(mockQuerySnapshot.documents).thenReturn(documents)
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(expectedMessage.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("text")).thenReturn(expectedMessage.text)
+    `when`(mockDocumentSnapshot.getString("senderUUID"))
+        .thenReturn(expectedMessage.senderUUID.toString())
+    `when`(mockDocumentSnapshot.getString("receiverUUID"))
+        .thenReturn(expectedMessage.receiverUUID.toString())
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(expectedMessage.timestamp)
+
+    // Act
+    messageFirestoreSource.getMessages { result ->
+      // Assert
+      assert(result.isSuccess)
+      val messages = result.getOrNull()
+      assert(messages?.size == 1)
+      assert(messages?.first() == expectedMessage)
+    }
+  }
+
+  @Test
+  fun getMessages_returnsFailureOnException() {
+    val exception = RuntimeException("Firestore error")
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.get()).thenReturn(Tasks.forException(exception))
+
+    messageFirestoreSource.getMessages { result ->
+      assert(result.isFailure)
+      assert(result.exceptionOrNull() == exception)
+    }
+  }
+
+  @Test
+  fun getMessages_returnsEmptyListOnEmptyResult() {
+    `when`(mockQuerySnapshot.documents).thenReturn(emptyList())
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
+
+    messageFirestoreSource.getMessages { result ->
+      assert(result.isSuccess)
+      val messages = result.getOrNull()
+      assert(messages?.isEmpty() == true)
+    }
+  }
+
+  // SendMessage Tests
+  @Test
+  fun sendMessage_callsFirestoreSet_onSuccess() {
+    val messageMap =
+        mapOf(
+            "uuid" to testMessage.uuid.toString(),
+            "text" to testMessage.text,
+            "senderUUID" to testMessage.senderUUID.toString(),
+            "receiverUUID" to testMessage.receiverUUID.toString(),
+            "timestamp" to testMessage.timestamp,
+            "messageType" to testMessage.messageType.name)
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(testMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.set(messageMap)).thenReturn(Tasks.forResult(null))
+
+    messageFirestoreSource.sendMessage(testMessage) { result -> assert(result.isSuccess) }
+
+    verify(mockDocumentReference).set(messageMap)
+  }
+
+  @Test
+  fun sendMessage_callsFirestoreSet_onFailure() {
+    val exception = RuntimeException("Firestore error")
+    val messageMap =
+        mapOf(
+            "uuid" to testMessage.uuid.toString(),
+            "text" to testMessage.text,
+            "senderUUID" to testMessage.senderUUID.toString(),
+            "receiverUUID" to testMessage.receiverUUID.toString(),
+            "timestamp" to testMessage.timestamp,
+            "messageType" to testMessage.messageType.name)
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(testMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.set(messageMap)).thenReturn(Tasks.forException(exception))
+
+    messageFirestoreSource.sendMessage(testMessage) { result ->
+      assert(result.isFailure)
+      assert(result.exceptionOrNull() == exception)
+    }
+  }
+
+  // DeleteMessage Tests
+  @Test
+  fun deleteMessage_deletesMessageOnSuccess() {
+    val fifteenMinutesInMillis = 15 * 60 * 1000
+    val recentMessage =
+        testMessage.copy(timestamp = System.currentTimeMillis() - (fifteenMinutesInMillis - 1000))
+
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(recentMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
+    `when`(mockDocumentSnapshot.exists()).thenReturn(true) // Ensure document exists
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(recentMessage.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("text")).thenReturn(recentMessage.text)
+    `when`(mockDocumentSnapshot.getString("senderUUID"))
+        .thenReturn(recentMessage.senderUUID.toString())
+    `when`(mockDocumentSnapshot.getString("receiverUUID"))
+        .thenReturn(recentMessage.receiverUUID.toString())
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(recentMessage.timestamp)
+    `when`(mockDocumentSnapshot.getString("messageType")).thenReturn(recentMessage.messageType.name)
+    `when`(mockDocumentReference.delete()).thenReturn(Tasks.forResult(null))
+
+    messageFirestoreSource.deleteMessage(
+        recentMessage.uuid, { result -> assert(result.isSuccess) }, mockContext)
+
+    shadowOf(Looper.getMainLooper()).idle()
+
+    verify(mockDocumentReference).delete()
+  }
+
+  @Test
+  fun deleteMessage_failsWhenMessageNotFound() {
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(testMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
+    `when`(mockDocumentSnapshot.exists()).thenReturn(false) // Message does not exist
+
+    messageFirestoreSource.deleteMessage(
+        testMessage.uuid,
+        { result ->
+          assert(result.isFailure)
+          assert(result.exceptionOrNull()?.message == "Message not found")
+        },
+        mockContext)
+  }
+
+  @Test
+  fun deleteMessage_failsWhenMessageTooOld() {
+    val oldMessage =
+        testMessage.copy(
+            timestamp =
+                System.currentTimeMillis() -
+                    (15 * 60 * 1000 + 1000)) // Sent more than 15 minutes ago
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(oldMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
+    `when`(mockDocumentSnapshot.exists()).thenReturn(true)
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(oldMessage.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("text")).thenReturn(oldMessage.text)
+    `when`(mockDocumentSnapshot.getString("senderUUID"))
+        .thenReturn(oldMessage.senderUUID.toString())
+    `when`(mockDocumentSnapshot.getString("receiverUUID"))
+        .thenReturn(oldMessage.receiverUUID.toString())
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(oldMessage.timestamp)
+
+    messageFirestoreSource.deleteMessage(
+        oldMessage.uuid,
+        { result ->
+          assert(result.isFailure)
+          assert(
+              result.exceptionOrNull()?.message ==
+                  "Message can only be deleted within 15 minutes of being sent")
+        },
+        mockContext)
+  }
+
+  @Test
+  fun deleteMessage_failsOnFirestoreRetrievalError() {
+    val exception = RuntimeException("Firestore retrieval error")
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(testMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forException(exception))
+
+    messageFirestoreSource.deleteMessage(
+        testMessage.uuid,
+        { result ->
+          assert(result.isFailure)
+          assert(result.exceptionOrNull() == exception)
+        },
+        mockContext)
+  }
+
+  @Test
+  fun deleteMessage_failsOnFirestoreDeleteError() {
+    val exception = RuntimeException("Firestore delete error")
+    val recentMessage =
+        testMessage.copy(
+            timestamp =
+                System.currentTimeMillis() - (15 * 60 * 1000 - 1000)) // Sent within 15 minutes
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(recentMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
+    `when`(mockDocumentSnapshot.exists()).thenReturn(true)
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(recentMessage.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("text")).thenReturn(recentMessage.text)
+    `when`(mockDocumentSnapshot.getString("senderUUID"))
+        .thenReturn(recentMessage.senderUUID.toString())
+    `when`(mockDocumentSnapshot.getString("receiverUUID"))
+        .thenReturn(recentMessage.receiverUUID.toString())
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(recentMessage.timestamp)
+    `when`(mockDocumentReference.delete()).thenReturn(Tasks.forException(exception))
+
+    messageFirestoreSource.deleteMessage(
+        recentMessage.uuid,
+        { result ->
+          assert(result.isFailure)
+          assert(result.exceptionOrNull() == exception)
+        },
+        mockContext)
+  }
+
+  @Test
+  fun deleteMessage_failsWhenConversionFails() {
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(testMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
+    `when`(mockDocumentSnapshot.exists()).thenReturn(true)
+    `when`(mockDocumentSnapshot.getString("uuid"))
+        .thenReturn(null) // Missing field causes conversion failure
+
+    messageFirestoreSource.deleteMessage(
+        testMessage.uuid,
+        { result ->
+          assert(result.isFailure)
+          assert(result.exceptionOrNull()?.message == "Message not found")
+        },
+        mockContext)
+  }
+
+  // DeleteAllMessages Tests
+  @Test
+  fun deleteAllMessages_deletesMessagesSuccessfully() {
+    val documents = listOf(mockDocumentSnapshot)
+    val mockBatch = mock(WriteBatch::class.java)
+
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(
+            mockCollectionReference.whereIn(
+                "senderUUID", listOf(testMessage.senderUUID, testMessage.receiverUUID)))
+        .thenReturn(mockCollectionReference)
+
+    `when`(
+            mockCollectionReference.whereIn(
+                "receiverUUID", listOf(testMessage.senderUUID, testMessage.receiverUUID)))
+        .thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.whereNotEqualTo("senderUUID", "receiverUUID"))
+        .thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
+    `when`(mockQuerySnapshot.documents).thenReturn(documents)
+
+    `when`(mockFirestore.batch()).thenReturn(mockBatch)
+    documents.forEach { `when`(mockBatch.delete(it.reference)).thenReturn(mockBatch) }
+    `when`(mockBatch.commit()).thenReturn(Tasks.forResult(null))
+
+    messageFirestoreSource.deleteAllMessages(testMessage.senderUUID, testMessage.receiverUUID) {
+        result ->
+      assert(result.isSuccess)
+    }
+
+    shadowOf(Looper.getMainLooper()).idle()
+
+    verify(mockBatch).commit()
+  }
+
+  @Test
+  fun deleteAllMessages_returnsSuccessWhenNoMessagesToDelete() {
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(
+            mockCollectionReference.whereIn(
+                "senderUUID", listOf(testMessage.senderUUID, testMessage.receiverUUID)))
+        .thenReturn(mockCollectionReference)
+    `when`(
+            mockCollectionReference.whereIn(
+                "receiverUUID", listOf(testMessage.senderUUID, testMessage.receiverUUID)))
+        .thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.whereNotEqualTo("senderUUID", "receiverUUID"))
+        .thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
+    `when`(mockQuerySnapshot.documents).thenReturn(emptyList()) // No messages found
+
+    messageFirestoreSource.deleteAllMessages(testMessage.senderUUID, testMessage.receiverUUID) {
+        result ->
+      assert(result.isSuccess)
+    }
+  }
+
+  @Test
+  fun deleteAllMessages_failsWhenFirestoreRetrievalError() {
+    val exception = RuntimeException("Firestore retrieval error")
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(
+            mockCollectionReference.whereIn(
+                "senderUUID", listOf(testMessage.senderUUID, testMessage.receiverUUID)))
+        .thenReturn(mockCollectionReference)
+    `when`(
+            mockCollectionReference.whereIn(
+                "receiverUUID", listOf(testMessage.senderUUID, testMessage.receiverUUID)))
+        .thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.whereNotEqualTo("senderUUID", "receiverUUID"))
+        .thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.get()).thenReturn(Tasks.forException(exception))
+
+    messageFirestoreSource.deleteAllMessages(testMessage.senderUUID, testMessage.receiverUUID) {
+        result ->
+      assert(result.isFailure)
+      assert(result.exceptionOrNull() == exception)
+    }
+  }
+
+  @Test
+  fun deleteAllMessages_failsWhenBatchCommitError() {
+    val documents = listOf(mockDocumentSnapshot)
+    val exception = RuntimeException("Batch commit error")
+    val mockBatch = mock(WriteBatch::class.java)
+
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(
+            mockCollectionReference.whereIn(
+                "senderUUID", listOf(testMessage.senderUUID, testMessage.receiverUUID)))
+        .thenReturn(mockCollectionReference)
+    `when`(
+            mockCollectionReference.whereIn(
+                "receiverUUID", listOf(testMessage.senderUUID, testMessage.receiverUUID)))
+        .thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.whereNotEqualTo("senderUUID", "receiverUUID"))
+        .thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
+    `when`(mockQuerySnapshot.documents).thenReturn(documents)
+
+    `when`(mockFirestore.batch()).thenReturn(mockBatch)
+    documents.forEach { `when`(mockBatch.delete(it.reference)).thenReturn(mockBatch) }
+    `when`(mockBatch.commit()).thenReturn(Tasks.forException(exception))
+
+    messageFirestoreSource.deleteAllMessages(testMessage.senderUUID, testMessage.receiverUUID) {
+        result ->
+      assert(result.isFailure)
+      assert(result.exceptionOrNull() == exception)
+    }
+  }
+
+  // UpdateMessage Tests
+  @Test
+  fun updateMessage_failsWhenMessageNotFound() {
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(testMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
+    `when`(mockDocumentSnapshot.exists()).thenReturn(false)
+
+    messageFirestoreSource.updateMessage(
+        testMessage,
+        { result ->
+          assert(result.isFailure)
+          assert(result.exceptionOrNull()?.message == "Message not found")
+        },
+        mockContext)
+  }
+
+  @Test
+  fun updateMessage_failsWhenMessageTooOld() {
+    val oldMessage =
+        testMessage.copy(
+            timestamp =
+                System.currentTimeMillis() -
+                    (15 * 60 * 1000 + 1000)) // Sent more than 15 minutes ago
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(oldMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
+    `when`(mockDocumentSnapshot.exists()).thenReturn(true)
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(oldMessage.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("text")).thenReturn(oldMessage.text)
+    `when`(mockDocumentSnapshot.getString("senderUUID"))
+        .thenReturn(oldMessage.senderUUID.toString())
+    `when`(mockDocumentSnapshot.getString("receiverUUID"))
+        .thenReturn(oldMessage.receiverUUID.toString())
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(oldMessage.timestamp)
+
+    messageFirestoreSource.updateMessage(
+        oldMessage,
+        { result ->
+          assert(result.isFailure)
+          assert(
+              result.exceptionOrNull()?.message ==
+                  "Message can only be updated within 15 minutes of being sent")
+        },
+        mockContext)
+  }
+
+  @Test
+  fun updateMessage_failsOnFirestoreRetrievalError() {
+    val exception = RuntimeException("Firestore retrieval error")
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(testMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forException(exception))
+
+    messageFirestoreSource.updateMessage(
+        testMessage,
+        { result ->
+          assert(result.isFailure)
+          assert(result.exceptionOrNull() == exception)
+        },
+        mockContext)
+  }
+
+  @Test
+  fun updateMessage_failsOnFirestoreUpdateError() {
+    val exception = RuntimeException("Firestore update error")
+    val recentMessage =
+        testMessage.copy(timestamp = System.currentTimeMillis() - (15 * 60 * 1000 - 1000))
+    val updatedText = "Updated text"
+    val messageMap = mapOf("text" to updatedText, "timestamp" to System.currentTimeMillis())
+
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(recentMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
+    `when`(mockDocumentSnapshot.exists()).thenReturn(true)
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(recentMessage.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("text")).thenReturn(recentMessage.text)
+    `when`(mockDocumentSnapshot.getString("senderUUID"))
+        .thenReturn(recentMessage.senderUUID.toString())
+    `when`(mockDocumentSnapshot.getString("receiverUUID"))
+        .thenReturn(recentMessage.receiverUUID.toString())
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(recentMessage.timestamp)
+    `when`(mockDocumentReference.update(messageMap)).thenReturn(Tasks.forException(exception))
+
+    messageFirestoreSource.updateMessage(
+        recentMessage.copy(text = updatedText),
+        { result ->
+          assert(result.isFailure)
+          assert(result.exceptionOrNull() == exception)
+        },
+        mockContext)
+  }
+
+  @Test
+  fun updateMessage_failsWhenConversionFails() {
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(testMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
+    `when`(mockDocumentSnapshot.exists()).thenReturn(true)
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(null)
+
+    messageFirestoreSource.updateMessage(
+        testMessage,
+        { result ->
+          assert(result.isFailure)
+          assert(result.exceptionOrNull()?.message == "Message not found")
+        },
+        mockContext)
+  }
+
+  @Test
+  fun documentToMessage_returnsDataMessageOnSuccess() {
+    val definedUUID = UUID.randomUUID()
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(definedUUID.toString())
+    `when`(mockDocumentSnapshot.getString("text")).thenReturn("Test message")
+    `when`(mockDocumentSnapshot.getString("senderUUID"))
+        .thenReturn(testMessage.senderUUID.toString())
+    `when`(mockDocumentSnapshot.getString("receiverUUID"))
+        .thenReturn(testMessage.receiverUUID.toString())
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(1634567890L)
+    `when`(mockDocumentSnapshot.getString("messageType")).thenReturn("TEXT")
+
+    val result = documentToMessage(mockDocumentSnapshot)
+
+    assert(result.isSuccess)
+    val message = result.getOrNull()
+    assert(message != null)
+    assert(message?.uuid == definedUUID)
+    assert(message?.text == "Test message")
+    assert(message?.senderUUID == testMessage.senderUUID)
+    assert(message?.receiverUUID == testMessage.receiverUUID)
+    assert(message?.timestamp == 1634567890L)
+    assert(message?.messageType == MessageType.TEXT)
+  }
+
+  @Test
+  fun documentToMessage_returnsFailureWhenFieldIsMissing() {
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(UUID.randomUUID().toString())
+    `when`(mockDocumentSnapshot.getString("text")).thenReturn(null) // Missing field
+    `when`(mockDocumentSnapshot.getString("senderUUID")).thenReturn("sender1")
+    `when`(mockDocumentSnapshot.getString("receiverUUID")).thenReturn("receiver1")
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(1634567890L)
+    `when`(mockDocumentSnapshot.getString("messageType")).thenReturn("TEXT")
+
+    val result = documentToMessage(mockDocumentSnapshot)
+
+    assert(result.isFailure)
+    assert(result.exceptionOrNull() is Exception)
+  }
+}
Index: app/src/test/java/com/android/bookswap/model/map/GeolocationTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/model/map/GeolocationTest.kt b/app/src/test/java/com/android/bookswap/model/map/GeolocationTest.kt
new file mode 100644
--- /dev/null	(date 1730306755529)
+++ b/app/src/test/java/com/android/bookswap/model/map/GeolocationTest.kt	(date 1730306755529)
@@ -0,0 +1,197 @@
+package com.android.bookswap.model.map
+
+import android.Manifest
+import android.app.Activity
+import android.content.pm.PackageManager
+import android.os.Looper
+import androidx.core.app.ActivityCompat
+import com.google.android.gms.location.FusedLocationProviderClient
+import com.google.android.gms.location.LocationCallback
+import com.google.android.gms.location.LocationRequest
+import com.google.android.gms.location.LocationServices
+import io.mockk.Runs
+import io.mockk.every
+import io.mockk.just
+import io.mockk.mockk
+import io.mockk.mockkObject
+import io.mockk.mockkStatic
+import io.mockk.slot
+import io.mockk.verify
+import org.junit.Assert.assertEquals
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mockito.*
+import org.robolectric.RobolectricTestRunner
+import org.robolectric.annotation.Config
+
+@RunWith(RobolectricTestRunner::class)
+class GeolocationTest {
+
+  private lateinit var mockActivity: Activity
+  private lateinit var mockFusedLocationClient: FusedLocationProviderClient
+  private lateinit var geolocation: Geolocation
+
+  @Before
+  fun setup() {
+    mockFusedLocationClient = mock(FusedLocationProviderClient::class.java)
+    mockActivity = mock(Activity::class.java)
+
+    // Mock static method for FusedLocationProviderClient
+    mockkStatic(LocationServices::class)
+    every { LocationServices.getFusedLocationProviderClient(mockActivity) } returns
+        mockFusedLocationClient
+
+    geolocation = Geolocation(mockActivity)
+  }
+
+  @Test
+  fun `startLocationUpdates should request location updates if permissions are granted`() {
+    // Mock the permission check to return true
+    `when`(mockActivity.checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION))
+        .thenReturn(PackageManager.PERMISSION_GRANTED)
+
+    geolocation.startLocationUpdates()
+
+    verify(mockFusedLocationClient)
+        .requestLocationUpdates(
+            any(LocationRequest::class.java),
+            any(LocationCallback::class.java),
+            eq(Looper.getMainLooper()))
+    assertEquals(true, geolocation.isRunning.value)
+  }
+
+  @Config(sdk = [30])
+  @Test
+  fun `startLocationUpdates should request permissions if not granted`() {
+    `when`(
+            ActivityCompat.checkSelfPermission(
+                mockActivity, Manifest.permission.ACCESS_FINE_LOCATION))
+        .thenReturn(PackageManager.PERMISSION_DENIED)
+    `when`(
+            ActivityCompat.checkSelfPermission(
+                mockActivity, Manifest.permission.ACCESS_BACKGROUND_LOCATION))
+        .thenReturn(PackageManager.PERMISSION_DENIED)
+
+    // Mock ActivityCompat.requestPermissions (static method)
+    mockkStatic(ActivityCompat::class)
+
+    every { ActivityCompat.requestPermissions(any(), any(), any()) } just Runs
+
+    geolocation.startLocationUpdates()
+
+    // Define the expected permissions array
+    val expectedLocationPermissions =
+        arrayOf(
+            Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION)
+
+    // Verify that ActivityCompat.requestPermissions is called with the correct arguments
+    verify {
+      ActivityCompat.requestPermissions(eq(mockActivity), eq(expectedLocationPermissions), eq(1))
+    }
+    assertEquals(false, geolocation.isRunning.value)
+  }
+
+  @Config(sdk = [30])
+  @Test
+  fun `startLocationUpdates should request background permissions if not granted`() {
+    `when`(
+            ActivityCompat.checkSelfPermission(
+                mockActivity, Manifest.permission.ACCESS_BACKGROUND_LOCATION))
+        .thenReturn(PackageManager.PERMISSION_DENIED)
+
+    // Mock ActivityCompat.requestPermissions (static method)
+    mockkStatic(ActivityCompat::class)
+
+    every { ActivityCompat.requestPermissions(any(), any(), any()) } just Runs
+
+    geolocation.startLocationUpdates()
+
+    val expectedBackgroundPermissions = arrayOf(Manifest.permission.ACCESS_BACKGROUND_LOCATION)
+
+    // Verify that ActivityCompat.requestPermissions is called with the correct arguments
+    verify {
+      ActivityCompat.requestPermissions(eq(mockActivity), eq(expectedBackgroundPermissions), eq(2))
+    }
+    assertEquals(true, geolocation.isRunning.value)
+  }
+
+  @Config(sdk = [28])
+  @Test
+  fun `startLocationUpdates should request permissions If not granted API 28`() {
+    `when`(
+            ActivityCompat.checkSelfPermission(
+                mockActivity, Manifest.permission.ACCESS_FINE_LOCATION))
+        .thenReturn(PackageManager.PERMISSION_DENIED)
+    `when`(
+            ActivityCompat.checkSelfPermission(
+                mockActivity, Manifest.permission.ACCESS_BACKGROUND_LOCATION))
+        .thenReturn(PackageManager.PERMISSION_DENIED)
+
+    // Mock ActivityCompat.requestPermissions (static method)
+    mockkStatic(ActivityCompat::class)
+
+    every { ActivityCompat.requestPermissions(any(), any(), any()) } just Runs
+
+    geolocation.startLocationUpdates()
+
+    // Define the expected permissions array
+    val expectedLocationPermissions =
+        arrayOf(
+            Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION)
+
+    val expectedBackgroundPermissions = arrayOf(Manifest.permission.ACCESS_BACKGROUND_LOCATION)
+
+    // Verify that ActivityCompat.requestPermissions is called with the correct arguments
+    verify {
+      ActivityCompat.requestPermissions(eq(mockActivity), eq(expectedLocationPermissions), eq(1))
+    }
+    verify(exactly = 0) {
+      ActivityCompat.requestPermissions(any(), eq(expectedBackgroundPermissions), any())
+    }
+    assertEquals(false, geolocation.isRunning.value)
+  }
+
+  @Test
+  fun `stopLocationUpdates should remove location updates`() {
+    geolocation.startLocationUpdates()
+    geolocation.stopLocationUpdates()
+
+    // Verify that removeLocationUpdates was called with the correct callback
+    verify(mockFusedLocationClient).removeLocationUpdates(any(LocationCallback::class.java))
+    assertEquals(false, geolocation.isRunning.value)
+  }
+
+  @Test
+  fun `latitude and longitude should initially be NaN`() {
+    assertEquals(Double.NaN, geolocation.latitude.value, 0.0)
+    assertEquals(Double.NaN, geolocation.longitude.value, 0.0)
+  }
+
+  @Test
+  fun `latitude and longitude should be updated in location callback`() {
+    val mockLocation = mock(android.location.Location::class.java)
+    `when`(mockLocation.latitude).thenReturn(37.7749)
+    `when`(mockLocation.longitude).thenReturn(-122.4194)
+
+    // Mock LocationResult to return the mock location
+    val mockLocationResult = mock(com.google.android.gms.location.LocationResult::class.java)
+    `when`(mockLocationResult.lastLocation).thenReturn(mockLocation)
+
+    val locationCallbackSlot = slot<LocationCallback>()
+    mockkObject(mockFusedLocationClient)
+    every {
+      mockFusedLocationClient.requestLocationUpdates(
+          any<LocationRequest>(), capture(locationCallbackSlot), any<Looper>())
+    } returns mockk()
+
+    geolocation.startLocationUpdates()
+
+    locationCallbackSlot.captured.onLocationResult(mockLocationResult)
+
+    // Verify that the latitude and longitude states are updated correctly
+    assertEquals(37.7749, geolocation.latitude.value, 0.0)
+    assertEquals(-122.4194, geolocation.longitude.value, 0.0)
+    assertEquals(true, geolocation.isRunning.value)
+  }
+}
Index: app/src/test/java/com/android/bookswap/data/source/api/GoogleBookDataSourceTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/source/api/GoogleBookDataSourceTest.kt b/app/src/test/java/com/android/bookswap/data/source/api/GoogleBookDataSourceTest.kt
new file mode 100644
--- /dev/null	(date 1731617426000)
+++ b/app/src/test/java/com/android/bookswap/data/source/api/GoogleBookDataSourceTest.kt	(date 1731617426000)
@@ -0,0 +1,237 @@
+package com.android.bookswap.data.source.api
+
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.utils.assertBookEquals
+import java.util.UUID
+import org.junit.After
+import org.junit.Assert.assertTrue
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.ArgumentCaptor
+import org.mockito.ArgumentMatchers
+import org.mockito.Captor
+import org.mockito.Mockito.anyString
+import org.mockito.Mockito.`when`
+import org.mockito.MockitoAnnotations
+import org.mockito.kotlin.capture
+import org.mockito.kotlin.mock
+import org.mockito.kotlin.times
+import org.mockito.kotlin.verify
+import org.robolectric.RobolectricTestRunner
+
+@RunWith(RobolectricTestRunner::class)
+class GoogleBookDataSourceTest {
+
+  private lateinit var mockitoClosable: AutoCloseable
+  @Captor private lateinit var resultDataBookCaptor: ArgumentCaptor<Result<DataBook>>
+
+  @Before
+  fun init() {
+    mockitoClosable = MockitoAnnotations.openMocks(this)
+  }
+
+  @After
+  fun close() {
+    mockitoClosable.close()
+  }
+
+  @Test
+  fun `ISBN input validation`() {
+    val mockGoogleBookDataSource: GoogleBookDataSource = mock()
+
+    val callback: (Result<DataBook>) -> Unit = mock()
+    `when`(
+            mockGoogleBookDataSource.getBookFromISBN(
+                anyString(), ArgumentMatchers.any(callback::class.java) ?: callback))
+        .thenCallRealMethod()
+
+    mockGoogleBookDataSource.getBookFromISBN("01a3456789", callback)
+    mockGoogleBookDataSource.getBookFromISBN("01234567890", callback)
+    verify(callback, times(2)).invoke(capture(resultDataBookCaptor))
+
+    assert(resultDataBookCaptor.value.isFailure)
+  }
+
+  @Test
+  fun `parseISBNResponse correctly parse`() {
+    val jsonBook =
+        """
+      {
+        "kind": "books#volumes",
+        "totalItems": 1,
+        "items": [
+          {
+            "id": "JLunPwAACAAJ",
+            "volumeInfo": {
+              "title": "Flowers for Algernon",
+              "authors": [
+                "Daniel Keyes"
+              ],
+              "description": "Example desc",
+              "industryIdentifiers": [
+                {
+                  "type": "ISBN_10",
+                  "identifier": "0435123432"
+                },
+                {
+                  "type": "ISBN_13",
+                  "identifier": "9780435123437"
+                }
+              ],
+              "imageLinks": {
+                "smallThumbnail": "image1",
+                "thumbnail": "image2"
+              },
+              "language": "en"
+            }
+          }
+        ]
+      }
+    """
+            .trimIndent()
+    val dataBook =
+        DataBook(
+            uuid = UUID.randomUUID(),
+            title = "Flowers for Algernon",
+            author = "Daniel Keyes",
+            description = "Example desc",
+            rating = null,
+            photo = "image2",
+            language = BookLanguages.ENGLISH,
+            isbn = "9780435123437")
+
+    val mockGoogleBookDataSource: GoogleBookDataSource = mock()
+    `when`(mockGoogleBookDataSource.parseISBNResponse(jsonBook)).thenCallRealMethod()
+
+    assertBookEquals(dataBook, mockGoogleBookDataSource.parseISBNResponse(jsonBook).getOrNull())
+  }
+
+  @Test
+  fun `parseISBNResponse fail when json is wrong`() {
+    val brokenJSON = "BROKEN JSON"
+
+    val mockGoogleBookDataSource: GoogleBookDataSource = mock()
+    `when`(mockGoogleBookDataSource.parseISBNResponse(brokenJSON)).thenCallRealMethod()
+
+    assertTrue(mockGoogleBookDataSource.parseISBNResponse(brokenJSON).isFailure)
+  }
+
+  @Test
+  fun `parseISBNResponse fail when title is not available`() {
+    val missingTitleJson =
+        """
+      {
+        "kind": "books#volumes",
+        "totalItems": 1,
+        "items": [
+          {
+            "id": "JLunPwAACAAJ",
+            "volumeInfo": {
+              "authors": [
+                "Daniel Keyes"
+              ],
+              "description": "Example desc",
+              "industryIdentifiers": [
+                {
+                  "type": "ISBN_10",
+                  "identifier": "0435123432"
+                },
+                {
+                  "type": "ISBN_13",
+                  "identifier": "9780435123437"
+                }
+              ],
+              "imageLinks": {
+                "smallThumbnail": "image1",
+                "thumbnail": "image2"
+              },
+              "language": "en"
+            }
+          }
+        ]
+      }
+    """
+            .trimIndent()
+
+    val mockGoogleBookDataSource: GoogleBookDataSource = mock()
+    `when`(mockGoogleBookDataSource.parseISBNResponse(missingTitleJson)).thenCallRealMethod()
+
+    assertTrue(mockGoogleBookDataSource.parseISBNResponse(missingTitleJson).isFailure)
+  }
+
+  @Test
+  fun `parseISBNResponse valid when partially empty`() {
+    val fieldsEmpty =
+        """
+      {
+        "kind": "books#volumes",
+        "totalItems": 1,
+        "items": [
+          {
+            "id": "JLunPwAACAAJ",
+            "volumeInfo": {
+              "title": "Flowers for Algernon",
+              "industryIdentifiers": [
+                {
+                  "type": "ISBN_10",
+                  "identifier": "0435123432"
+                },
+                {
+                  "type": "ISBN_13",
+                  "identifier": "9780435123437"
+                }
+              ]
+            }
+          }
+        ]
+      }
+    """
+            .trimIndent()
+    val listEmpty =
+        """
+      {
+        "kind": "books#volumes",
+        "totalItems": 1,
+        "items": [
+          {
+            "id": "JLunPwAACAAJ",
+            "volumeInfo": {
+              "title": "Flowers for Algernon",
+              "authors": [],
+              "industryIdentifiers": [
+                {
+                  "type": "ISBN_10",
+                  "identifier": "0435123432"
+                },
+                {
+                  "type": "ISBN_13",
+                  "identifier": "9780435123437"
+                }
+              ],
+              "imageLinks": {}
+            }
+          }
+        ]
+      }
+    """
+            .trimIndent()
+    val dataBook =
+        DataBook(
+            uuid = UUID.randomUUID(),
+            title = "Flowers for Algernon",
+            author = null,
+            description = null,
+            rating = null,
+            photo = null,
+            language = BookLanguages.OTHER,
+            isbn = "9780435123437")
+
+    val mockGoogleBookDataSource: GoogleBookDataSource = mock()
+    `when`(mockGoogleBookDataSource.parseISBNResponse(anyString())).thenCallRealMethod()
+
+    assertBookEquals(dataBook, mockGoogleBookDataSource.parseISBNResponse(fieldsEmpty).getOrNull())
+    assertBookEquals(dataBook, mockGoogleBookDataSource.parseISBNResponse(listEmpty).getOrNull())
+  }
+}
Index: app/src/test/java/com/android/bookswap/ui/navigation/NavigationActionsTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/ui/navigation/NavigationActionsTest.kt b/app/src/test/java/com/android/bookswap/ui/navigation/NavigationActionsTest.kt
new file mode 100644
--- /dev/null	(date 1731615667000)
+++ b/app/src/test/java/com/android/bookswap/ui/navigation/NavigationActionsTest.kt	(date 1731615667000)
@@ -0,0 +1,99 @@
+package com.android.bookswap.ui.navigation
+
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.filled.MailOutline
+import androidx.compose.material.icons.outlined.AccountCircle
+import androidx.compose.material.icons.outlined.AddCircle
+import androidx.compose.material.icons.outlined.Place
+import androidx.navigation.NavDestination
+import androidx.navigation.NavHostController
+import androidx.navigation.NavOptionsBuilder
+import org.hamcrest.CoreMatchers.`is`
+import org.hamcrest.MatcherAssert.assertThat
+import org.junit.Before
+import org.junit.Test
+import org.mockito.Mockito.mock
+import org.mockito.Mockito.verify
+import org.mockito.Mockito.`when`
+import org.mockito.kotlin.any
+import org.mockito.kotlin.eq
+
+class NavigationActionsTest {
+  private lateinit var navigationDestination: NavDestination
+  private lateinit var navHostController: NavHostController
+  private lateinit var navigationActions: NavigationActions
+
+  @Before
+  fun setUp() {
+    navigationDestination = mock(NavDestination::class.java)
+    navHostController = mock(NavHostController::class.java)
+    navigationActions = NavigationActions(navHostController)
+  }
+
+  @Test
+  fun navigateToTopLevelDestination() {
+    navigationActions.navigateTo(TopLevelDestinations.CHAT)
+    verify(navHostController).navigate(eq(Route.CHAT), any<(NavOptionsBuilder) -> Unit>())
+
+    navigationActions.navigateTo(TopLevelDestinations.MAP)
+    verify(navHostController).navigate(eq(Route.MAP), any<(NavOptionsBuilder) -> Unit>())
+
+    navigationActions.navigateTo(TopLevelDestinations.PROFILE)
+    verify(navHostController).navigate(eq(Route.PROFILE), any<(NavOptionsBuilder) -> Unit>())
+
+    navigationActions.navigateTo(TopLevelDestinations.NEW_BOOK)
+    verify(navHostController).navigate(eq(Route.NEWBOOK), any<(NavOptionsBuilder) -> Unit>())
+  }
+
+  @Test
+  fun navigateToScreen() {
+    navigationActions.navigateTo(Screen.MAP)
+    verify(navHostController).navigate(Screen.MAP)
+
+    navigationActions.navigateTo(Screen.CHAT)
+    verify(navHostController).navigate(Screen.CHAT)
+
+    navigationActions.navigateTo(Screen.NEWBOOK)
+    verify(navHostController).navigate(Screen.NEWBOOK)
+
+    navigationActions.navigateTo(Screen.ADD_BOOK_ISBN)
+    verify(navHostController).navigate(Screen.ADD_BOOK_ISBN)
+
+    navigationActions.navigateTo(Screen.ADD_BOOK_SCAN)
+    verify(navHostController).navigate(Screen.ADD_BOOK_SCAN)
+  }
+
+  @Test
+  fun currentRouteAreCorrect() {
+    `when`(navHostController.currentDestination).thenReturn(navigationDestination)
+    `when`(navigationDestination.route).thenReturn(Route.NEWBOOK)
+
+    navigationActions.navigateTo(TopLevelDestinations.NEW_BOOK)
+    assertThat(navigationActions.currentRoute(), `is`(Route.NEWBOOK))
+  }
+
+  @Test
+  fun goBackCallPopBackStack() {
+    navigationActions.goBack()
+    verify(navHostController).popBackStack()
+  }
+
+  @Test
+  fun topLevelDestinationsHaveCorrectIcon() {
+    assertThat(TopLevelDestinations.CHAT.icon, `is`(Icons.Filled.MailOutline))
+    assertThat(TopLevelDestinations.MAP.icon, `is`(Icons.Outlined.Place))
+    assertThat(TopLevelDestinations.NEW_BOOK.icon, `is`(Icons.Outlined.AddCircle))
+    assertThat(TopLevelDestinations.PROFILE.icon, `is`(Icons.Outlined.AccountCircle))
+  }
+
+  @Test
+  fun list_Navigation_Bar_DestinationsCorrectOrder() {
+    assertThat(
+        List_Navigation_Bar_Destinations,
+        `is`(
+            listOf(
+                TopLevelDestinations.CHAT,
+                TopLevelDestinations.NEW_BOOK,
+                TopLevelDestinations.MAP)))
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/chat/ListChatScreenTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/chat/ListChatScreenTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/chat/ListChatScreenTest.kt
new file mode 100644
--- /dev/null	(date 1731617442000)
+++ b/app/src/androidTest/java/com/android/bookswap/ui/chat/ListChatScreenTest.kt	(date 1731617442000)
@@ -0,0 +1,146 @@
+package com.android.bookswap.ui.chat
+
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.test.assertAll
+import androidx.compose.ui.test.assertHasClickAction
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.assertTextEquals
+import androidx.compose.ui.test.hasClickAction
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onAllNodesWithTag
+import androidx.compose.ui.test.onChild
+import androidx.compose.ui.test.onNodeWithContentDescription
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.navigation.compose.rememberNavController
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.MessageBox
+import com.android.bookswap.ui.components.TopAppBarComponent
+import com.android.bookswap.ui.navigation.BottomNavigationMenu
+import com.android.bookswap.ui.navigation.List_Navigation_Bar_Destinations
+import com.android.bookswap.ui.navigation.NavigationActions
+import java.util.UUID
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+class ListChatScreenTest {
+
+  @get:Rule val composeTestRule = createComposeRule()
+  private lateinit var placeHolderData: List<MessageBox>
+  private lateinit var placeHolderDataEmpty: List<MessageBox>
+
+  @Before
+  fun setUp() {
+    placeHolderData =
+        List(12) {
+          MessageBox(
+              DataUser(
+                  UUID.randomUUID(),
+                  "Hello",
+                  "First ${it + 1}",
+                  "Last ${it + 1}",
+                  "",
+                  "",
+                  0.0,
+                  0.0,
+                  "",
+                  emptyList(),
+                  "googleUid"),
+              "Test message $it test for the feature of ellipsis in the message",
+              "01.01.24")
+        }
+    placeHolderDataEmpty = emptyList()
+  }
+
+  @Test
+  fun hasRequiredComponentsWithMessage() {
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      ListChatScreen(
+          placeHolderData,
+          navigationActions,
+          { TopAppBarComponent(Modifier, navigationActions, "Messages") },
+          {
+            BottomNavigationMenu(
+                onTabSelect = { destination -> navigationActions.navigateTo(destination) },
+                tabList = List_Navigation_Bar_Destinations,
+                selectedItem = navigationActions.currentRoute())
+          })
+    }
+    composeTestRule.onNodeWithTag("TopAppBar").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("profileIconButton").assertIsDisplayed()
+    composeTestRule.onNodeWithContentDescription("Profile Icon").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("chat_messageList").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("bottomNavigationMenu").assertIsDisplayed()
+
+    composeTestRule.onNodeWithTag("TopAppBar_Title").assertTextEquals("Messages")
+  }
+
+  @Test
+  fun hasRequiredComponentsWithMessageEmpty() {
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      ListChatScreen(
+          placeHolderDataEmpty,
+          navigationActions,
+          { TopAppBarComponent(Modifier, navigationActions, "Messages") },
+          {
+            BottomNavigationMenu(
+                onTabSelect = { destination -> navigationActions.navigateTo(destination) },
+                tabList = List_Navigation_Bar_Destinations,
+                selectedItem = navigationActions.currentRoute())
+          })
+    }
+    composeTestRule.onNodeWithTag("TopAppBar").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("profileIconButton").assertIsDisplayed()
+    composeTestRule.onNodeWithContentDescription("Profile Icon").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("chat_messageList").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("bottomNavigationMenu").assertIsDisplayed()
+
+    composeTestRule.onNodeWithTag("TopAppBar_Title").assertTextEquals("Messages")
+    composeTestRule.onNodeWithTag("chat_messageList").onChild().assertTextEquals("No messages yet")
+  }
+
+  @Test
+  fun hasClickableComponents() {
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      ListChatScreen(
+          placeHolderData,
+          navigationActions,
+          { TopAppBarComponent(Modifier, navigationActions, "Messages") },
+          {
+            BottomNavigationMenu(
+                onTabSelect = { destination -> navigationActions.navigateTo(destination) },
+                tabList = List_Navigation_Bar_Destinations,
+                selectedItem = navigationActions.currentRoute())
+          })
+    }
+    composeTestRule.onNodeWithTag("profileIconButton").assertHasClickAction()
+  }
+
+  @Test
+  fun allMessageBoxesAreClickable() {
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      ListChatScreen(
+          placeHolderData,
+          navigationActions,
+          { TopAppBarComponent(Modifier, navigationActions, "Messages") },
+          {
+            BottomNavigationMenu(
+                onTabSelect = { destination -> navigationActions.navigateTo(destination) },
+                tabList = List_Navigation_Bar_Destinations,
+                selectedItem = navigationActions.currentRoute())
+          })
+    }
+
+    val messageNodes = composeTestRule.onAllNodesWithTag("chat_messageBox")
+    assert(messageNodes.fetchSemanticsNodes().isNotEmpty())
+    messageNodes.assertAll(hasClickAction())
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/map/MapScreenTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/map/MapScreenTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/map/MapScreenTest.kt
new file mode 100644
--- /dev/null	(date 1731617426000)
+++ b/app/src/androidTest/java/com/android/bookswap/ui/map/MapScreenTest.kt	(date 1731617426000)
@@ -0,0 +1,267 @@
+package com.android.bookswap.ui.map
+
+import androidx.compose.ui.geometry.Offset
+import androidx.compose.ui.semantics.getOrNull
+import androidx.compose.ui.test.assertCountEquals
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.assertIsNotDisplayed
+import androidx.compose.ui.test.assertTextContains
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onAllNodesWithTag
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.compose.ui.test.performTouchInput
+import androidx.compose.ui.test.swipe
+import androidx.compose.ui.test.swipeUp
+import androidx.navigation.compose.rememberNavController
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.UserBooksWithLocation
+import com.android.bookswap.model.map.BookManagerViewModel
+import com.android.bookswap.model.map.DefaultGeolocation
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.google.maps.android.compose.CameraPositionState
+import io.mockk.every
+import io.mockk.just
+import io.mockk.mockk
+import io.mockk.runs
+import java.util.UUID
+import junit.framework.TestCase.assertEquals
+import kotlinx.coroutines.flow.MutableStateFlow
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+val longListBook =
+    List(20) {
+      DataBook(
+          uuid = UUID(2000, 2000),
+          title = "Book 1",
+          author = "Author 1",
+          description = "Description of Book 1",
+          rating = 5,
+          photo = "url_to_photo_1",
+          language = BookLanguages.ENGLISH,
+          isbn = "123-456-789",
+          genres = listOf(BookGenres.FICTION, BookGenres.NONFICTION))
+    }
+
+val books =
+    listOf(
+        DataBook(
+            uuid = UUID(1000, 1000),
+            title = "Book 1",
+            author = "Author 1",
+            description = "Description of Book 1",
+            rating = 5,
+            photo = "url_to_photo_1",
+            language = BookLanguages.ENGLISH,
+            isbn = "123-456-789",
+            genres = listOf(BookGenres.FICTION, BookGenres.HORROR)),
+        DataBook(
+            uuid = UUID(2000, 1000),
+            title = "Book 2",
+            author = "Author 2",
+            description = "Description of Book 2",
+            rating = 4,
+            photo = "url_to_photo_2",
+            language = BookLanguages.FRENCH,
+            isbn = "234-567-890",
+            genres = listOf(BookGenres.FICTION)))
+
+class MapScreenTest {
+  private val user = listOf(DataUser(bookList = listOf(UUID(1000, 1000), UUID(2000, 1000))))
+  private val userLongList = listOf(DataUser(bookList = listOf(UUID(2000, 2000))))
+
+  private val userBooksWithLocationList =
+      listOf(UserBooksWithLocation(UUID.randomUUID(), user[0].longitude, user[0].latitude, books))
+  private val userBooksWithLocationLongList =
+      listOf(
+          UserBooksWithLocation(
+              UUID.randomUUID(), userLongList[0].longitude, userLongList[0].latitude, longListBook))
+
+  private val userWithoutBooks =
+      listOf(UserBooksWithLocation(UUID.randomUUID(), 0.0, 0.0, emptyList()))
+  @get:Rule val composeTestRule = createComposeRule()
+
+  private val mockBookManagerViewModel: BookManagerViewModel = mockk()
+
+  @Before
+  fun setup() {
+
+    every { mockBookManagerViewModel.filteredBooks } returns MutableStateFlow(books)
+
+    every { mockBookManagerViewModel.filteredUsers } returns
+        MutableStateFlow(userBooksWithLocationList)
+    every { mockBookManagerViewModel.startUpdatingBooks() } just runs
+    every { mockBookManagerViewModel.stopUpdatingBooks() } just runs
+  }
+
+  @Test
+  fun displayAllComponents() {
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      MapScreen(mockBookManagerViewModel, navigationActions, 0)
+    }
+    composeTestRule.onNodeWithTag("mapScreen").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("mapGoogleMap").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("mapBoxMarker").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("mapBoxMarkerList").assertIsDisplayed()
+    composeTestRule.onAllNodesWithTag("mapBoxMarkerListBox").assertCountEquals(2)
+    composeTestRule.onAllNodesWithTag("mapBoxMarkerListBoxTitle").assertCountEquals(2)
+    composeTestRule.onAllNodesWithTag("mapBoxMarkerListBoxAuthor").assertCountEquals(2)
+    composeTestRule.onAllNodesWithTag("mapBoxMarkerListDivider").assertCountEquals(1)
+
+    // components of Draggable Menu
+    composeTestRule.onNodeWithTag("mapDraggableMenu").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("mapDraggableMenuStructure").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("mapDraggableMenuHandle").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("mapDraggableMenuHandleDivider").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("mapDraggableMenuBookBox0").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("mapDraggableMenuBookBox1").assertIsDisplayed()
+    composeTestRule.onAllNodesWithTag("mapDraggableMenuBookBoxImage").assertCountEquals(2)
+    composeTestRule.onAllNodesWithTag("mapDraggableMenuBookBoxTitle").assertCountEquals(2)
+    composeTestRule.onAllNodesWithTag("mapDraggableMenuBookBoxAuthor").assertCountEquals(2)
+    composeTestRule.onAllNodesWithTag("mapDraggableMenuBookBoxRating").assertCountEquals(2)
+    composeTestRule.onAllNodesWithTag("mapDraggableMenuBookBoxStar").assertCountEquals(9)
+    composeTestRule.onAllNodesWithTag("mapDraggableMenuBookBoxEmptyStar").assertCountEquals(1)
+    composeTestRule.onAllNodesWithTag("mapDraggableMenuBookBoxTag").assertCountEquals(2)
+    composeTestRule
+        .onAllNodesWithTag("mapDraggableMenuBookBoxDivider")
+        .assertCountEquals(books.size - 1)
+
+    composeTestRule.onNodeWithTag("filterButton").assertIsDisplayed()
+  }
+
+  @Test
+  fun noMarkerDisplayedForUserWithoutBooks() {
+    every { mockBookManagerViewModel.filteredBooks } answers { MutableStateFlow(emptyList()) }
+    every { mockBookManagerViewModel.filteredUsers } answers { MutableStateFlow(userWithoutBooks) }
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      MapScreen(mockBookManagerViewModel, navigationActions, 0)
+    }
+
+    // Assert that the marker info window is displayed, but without book entries
+    composeTestRule.onNodeWithTag("mapBoxMarker").assertIsNotDisplayed()
+    composeTestRule.onAllNodesWithTag("mapBoxMarkerListBox").assertCountEquals(0) // No books
+  }
+
+  @Test
+  fun emptyUserListDoesNotShowMarkers() {
+    every { mockBookManagerViewModel.filteredBooks } answers { MutableStateFlow(emptyList()) }
+    every { mockBookManagerViewModel.filteredUsers } answers { MutableStateFlow(emptyList()) }
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      MapScreen(mockBookManagerViewModel, navigationActions)
+    }
+
+    // Assert that the map is displayed but no marker and info window is shown
+    composeTestRule.onNodeWithTag("mapGoogleMap").assertIsDisplayed()
+    composeTestRule.onAllNodesWithTag("mapBoxMarker").assertCountEquals(0) // No marker info
+  }
+
+  @Test
+  fun emptyBooksListGiveEmptyDraggableMenu() {
+    every { mockBookManagerViewModel.filteredBooks } answers { MutableStateFlow(emptyList()) }
+    every { mockBookManagerViewModel.filteredUsers } answers { MutableStateFlow(emptyList()) }
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      MapScreen(mockBookManagerViewModel, navigationActions)
+    }
+    // Assert that the marker info window is displayed, but without book entries
+    composeTestRule.onNodeWithTag("mapDraggableMenu").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("mapDraggableMenuBookBox0").assertIsNotDisplayed()
+    composeTestRule
+        .onNodeWithTag("mapDraggableMenuNoBook")
+        .assertIsDisplayed()
+        .assertTextContains("No books to display")
+  }
+
+  @Test
+  fun noUserSelectedInitially() {
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      MapScreen(mockBookManagerViewModel, navigationActions)
+    }
+
+    // Assert that no info window is displayed when no user is selected
+    composeTestRule.onNodeWithTag("mapGoogleMap").assertIsDisplayed()
+    composeTestRule.onAllNodesWithTag("mapBoxMarker").assertCountEquals(0) // No info window
+  }
+
+  @Test
+  fun draggableMenu_canBeDraggedVertically() {
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      MapScreen(mockBookManagerViewModel, navigationActions, 0)
+    }
+    // Ensure the DraggableMenu is initially displayed
+    composeTestRule.onNodeWithTag("mapDraggableMenu").assertIsDisplayed()
+
+    // Simulate a drag gesture by swiping up (closing the menu)
+    composeTestRule.onNodeWithTag("mapDraggableMenu").performTouchInput {
+      swipeUp(startY = bottom, endY = top, durationMillis = 500)
+    }
+
+    // Assert that after swiping, the menu is still displayed but in a new position
+    composeTestRule.onNodeWithTag("mapDraggableMenu").assertIsDisplayed()
+
+    // Simulate dragging the menu back down (opening the menu)
+    composeTestRule.onNodeWithTag("mapDraggableMenu").performTouchInput {
+      swipe(start = Offset(0f, 100f), end = Offset(0f, -500f), durationMillis = 500)
+    }
+
+    // Assert that after swiping, the menu is still displayed but in a new position
+    composeTestRule.onNodeWithTag("mapDraggableMenu").assertIsDisplayed()
+  }
+
+  @Test
+  fun draggableMenuListIsScrollable() {
+
+    every { mockBookManagerViewModel.filteredBooks } answers { MutableStateFlow(longListBook) }
+    every { mockBookManagerViewModel.filteredUsers } answers
+        {
+          MutableStateFlow(userBooksWithLocationLongList)
+        }
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      MapScreen(mockBookManagerViewModel, navigationActions, 0)
+    }
+
+    // Assert initial state: Only first item(s) are visible
+    composeTestRule.onNodeWithTag("mapDraggableMenuBookBox0").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("mapDraggableMenuBookBox19").assertIsNotDisplayed()
+    // Perform scroll gesture on LazyColumn
+    composeTestRule.onNodeWithTag("mapDraggableMenuStructure").performTouchInput {
+      for (i in 1..19) {
+        swipeUp()
+      }
+    }
+    composeTestRule.onNodeWithTag("mapDraggableMenuBookBox0").assertIsNotDisplayed()
+    composeTestRule.onNodeWithTag("mapDraggableMenuBookBox19").assertIsDisplayed()
+  }
+
+  @Test
+  fun mapHasGeoLocation() {
+    val geolocation = DefaultGeolocation()
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      MapScreen(mockBookManagerViewModel, navigationActions, 0)
+    }
+    val node1 = composeTestRule.onNodeWithTag("mapGoogleMap").fetchSemanticsNode()
+    val cameraPositionState: CameraPositionState? = node1.config.getOrNull(CameraPositionKey)
+
+    assertEquals(geolocation.latitude.value, cameraPositionState?.position?.target?.latitude)
+    assertEquals(geolocation.longitude.value, cameraPositionState?.position?.target?.longitude)
+  }
+}
Index: app/src/test/resources/robolectric.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/app/src/test/resources/robolectric.properties b/app/src/test/resources/robolectric.properties
new file mode 100644
--- /dev/null	(date 1730306755529)
+++ b/app/src/test/resources/robolectric.properties	(date 1730306755529)
@@ -0,0 +1,2 @@
+sdk=34
+qualifiers=w360dp-h720dp-xhdpi
\ No newline at end of file
Index: app/src/test/java/com/android/bookswap/utils/JSONUtils.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/utils/JSONUtils.kt b/app/src/test/java/com/android/bookswap/utils/JSONUtils.kt
new file mode 100644
--- /dev/null	(date 1730306755529)
+++ b/app/src/test/java/com/android/bookswap/utils/JSONUtils.kt	(date 1730306755529)
@@ -0,0 +1,55 @@
+package com.android.bookswap.utils
+
+import org.json.JSONObject
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertNull
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.RobolectricTestRunner
+
+@RunWith(RobolectricTestRunner::class)
+class JSONUtils {
+  private lateinit var jsonObj: JSONObject
+
+  @Before
+  fun setup() {
+    val json =
+        """
+          {
+            "test": {
+                "test1": "works"
+            },
+            "array": [
+                "works2"
+            ]
+          }
+        """
+            .trimIndent()
+
+    jsonObj = JSONObject(json)
+  }
+
+  @Test
+  fun getJSONObjectOrNull() {
+    assertEquals("works", jsonObj.getJSONObjectOrNull("test")!!.getString("test1"))
+    assertNull(jsonObj.getJSONObjectOrNull("not-exist"))
+  }
+
+  @Test
+  fun getJSONArrayOrNull() {
+    assertEquals("works2", jsonObj.getJSONArrayOrNull("array")!!.get(0))
+    assertNull(jsonObj.getJSONArrayOrNull("not-exist"))
+  }
+
+  @Test
+  fun getStringOrNull() {
+    // Test for JSONObject
+    assertEquals("works", jsonObj.getJSONObject("test").getStringOrNull("test1"))
+    assertNull(jsonObj.getJSONObject("test").getStringOrNull("not-exist"))
+
+    // Test for JSONArray
+    assertEquals("works2", jsonObj.getJSONArray("array").getString(0))
+    assertNull(jsonObj.getJSONArray("array").getStringOrNull(2))
+  }
+}
Index: gradlew.bat
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
--- /dev/null	(date 1730306755531)
+++ b/gradlew.bat	(date 1730306755531)
@@ -0,0 +1,89 @@
+@rem
+@rem Copyright 2015 the original author or authors.
+@rem
+@rem Licensed under the Apache License, Version 2.0 (the "License");
+@rem you may not use this file except in compliance with the License.
+@rem You may obtain a copy of the License at
+@rem
+@rem      https://www.apache.org/licenses/LICENSE-2.0
+@rem
+@rem Unless required by applicable law or agreed to in writing, software
+@rem distributed under the License is distributed on an "AS IS" BASIS,
+@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@rem See the License for the specific language governing permissions and
+@rem limitations under the License.
+@rem
+
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Resolve any "." and ".." in APP_HOME to make it shorter.
+for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto execute
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto execute
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
Index: settings.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/settings.gradle.kts b/settings.gradle.kts
new file mode 100644
--- /dev/null	(date 1730306755531)
+++ b/settings.gradle.kts	(date 1730306755531)
@@ -0,0 +1,24 @@
+pluginManagement {
+    repositories {
+        google {
+            content {
+                includeGroupByRegex("com\\.android.*")
+                includeGroupByRegex("com\\.google.*")
+                includeGroupByRegex("androidx.*")
+            }
+        }
+        mavenCentral()
+        gradlePluginPortal()
+    }
+}
+dependencyResolutionManagement {
+    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
+    repositories {
+        google()
+        mavenCentral()
+    }
+}
+
+rootProject.name = "BookSwapApp"
+include(":app")
+ 
\ No newline at end of file
Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gitignore b/.gitignore
new file mode 100644
--- /dev/null	(date 1730449039973)
+++ b/.gitignore	(date 1730449039973)
@@ -0,0 +1,14 @@
+/.idea/
+.DS_Store
+.gradle
+/local.properties
+/build
+/captures
+.externalNativeBuild
+.cxx
+local.properties
+
+# Google Services (e.g. APIs or Firebase)
+app/google-services.json
+
+keystore.jks
\ No newline at end of file
Index: build.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build.gradle.kts b/build.gradle.kts
new file mode 100644
--- /dev/null	(date 1730451037652)
+++ b/build.gradle.kts	(date 1730451037652)
@@ -0,0 +1,16 @@
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+plugins {
+    alias(libs.plugins.androidApplication) apply false
+    alias(libs.plugins.jetbrainsKotlinAndroid) apply false
+    id("org.sonarqube") version "4.4.1.3373"
+    alias(libs.plugins.gms) apply false
+
+}
+
+sonar {
+    properties {
+        property("sonar.projectKey", "BookswapEPFL_Bookswap")
+        property("sonar.organization", "bookswapepfl")
+        property("sonar.host.url", "https://sonarcloud.io")
+    }
+}
Index: gradlew
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/gradlew b/gradlew
new file mode 100644
--- /dev/null	(date 1730306755531)
+++ b/gradlew	(date 1730306755531)
@@ -0,0 +1,185 @@
+#!/usr/bin/env sh
+
+#
+# Copyright 2015 the original author or authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn () {
+    echo "$*"
+}
+
+die () {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin or MSYS, switch paths to Windows format before running java
+if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=`expr $i + 1`
+    done
+    case $i in
+        0) set -- ;;
+        1) set -- "$args0" ;;
+        2) set -- "$args0" "$args1" ;;
+        3) set -- "$args0" "$args1" "$args2" ;;
+        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
+}
+APP_ARGS=`save "$@"`
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+exec "$JAVACMD" "$@"
Index: .github/workflows/ci.yml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
new file mode 100644
--- /dev/null	(date 1730306755516)
+++ b/.github/workflows/ci.yml	(date 1730306755516)
@@ -0,0 +1,124 @@
+name: CI - Test Runner
+
+# Run the workflow when commits are pushed on main or when a PR is modified
+on:
+  push:
+    branches:
+      - main
+
+  pull_request:
+    types:
+      - opened
+      - synchronize
+      - reopened
+
+jobs:
+  ci:
+    name: CI
+    # Execute the CI on the course's runners
+    runs-on: ubuntu-latest
+
+    steps:
+      # First step : Checkout the repository on the runner
+      - name: Checkout
+        uses: actions/checkout@v4
+        with:
+          submodules: recursive
+          fetch-depth: 0 # Shallow clones should be disabled for a better relevancy of Sonar analysis (if we use Sonar Later)
+
+
+      # Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into Linux. Enabling it allows the Android emulator to run faster.
+      - name: Enable KVM group perms
+        run: |
+          echo 'KERNEL=="kvm", GROUP="kvm", MODE="0666", OPTIONS+="static_node=kvm"' | sudo tee /etc/udev/rules.d/99-kvm4all.rules
+          sudo udevadm control --reload-rules
+          sudo udevadm trigger --name-match=kvm
+
+      - name: Setup JDK
+        uses: actions/setup-java@v4
+        with:
+          distribution: "temurin"
+          java-version: "17"
+
+      # Caching is a very useful part of a CI, as a workflow is executed in a clean environment every time,
+      # this means that one would need to re-download and re-process gradle files for every run. Which is very time consuming.
+      #
+      # To avoid that, we cache the the gradle folder to reuse it later.
+      - name: Gradle cache
+        uses: gradle/actions/setup-gradle@v3
+
+      # Cache the Emulator, if the cache does not hit, create the emulator
+      - name: AVD cache
+        uses: actions/cache@v4
+        id: avd-cache
+        with:
+          path: |
+            ~/.android/avd/*
+            ~/.android/adb*
+          key: avd-34
+
+      - name: create AVD and generate snapshot for caching
+        if: steps.avd-cache.outputs.cache-hit != 'true'
+        uses: reactivecircus/android-emulator-runner@v2
+        with:
+          api-level: 34
+          target: google_apis
+          arch: x86_64
+          force-avd-creation: false
+          emulator-options: -no-window -gpu swiftshader_indirect -noaudio -no-boot-anim -camera-back none
+          disable-animations: false
+          script: echo "Generated AVD snapshot for caching."
+
+      - name: Grant execute permission for gradlew
+        run: |
+          chmod +x ./gradlew
+
+      # Check formatting
+      - name: KTFmt Check
+        run: |
+          ./gradlew ktfmtCheck
+
+      # Load google-services.json and local.properties from the secrets
+      - name: Decode secrets
+        env:
+          GOOGLE_SERVICES: ${{ secrets.GOOGLE_SERVICES }}
+          LOCAL_PROPERTIES: ${{ secrets.LOCAL_PROPERTIES }}
+        run: |
+          echo "$GOOGLE_SERVICES" | base64 --decode > ./app/google-services.json
+          echo "$LOCAL_PROPERTIES" | base64 --decode > ./local.properties
+
+      # This step runs gradle commands to build the application
+      - name: Assemble
+        run: |
+          # To run the CI with debug information, add --info
+          ./gradlew assembleDebug lint --parallel --build-cache
+
+      # Run Unit tests
+      - name: Run tests
+        run: |
+          # To run the CI with debug information, add --info
+          ./gradlew check --parallel --build-cache
+
+      # Run connected tests on the emulator
+      - name: run tests
+        uses: reactivecircus/android-emulator-runner@v2
+        with:
+          api-level: 34
+          target: google_apis
+          arch: x86_64
+          force-avd-creation: false
+          emulator-options: -no-snapshot-save -no-window -gpu swiftshader_indirect -noaudio -no-boot-anim -camera-back none
+          disable-animations: true
+          script: ./gradlew connectedCheck --parallel --build-cache
+
+      # This step generates the coverage report which will be uploaded to sonar
+      - name: Generate Coverage Report
+        run: |
+          ./gradlew jacocoTestReport
+
+      # Upload the various reports to sonar
+      - name: Upload report to SonarCloud
+        env:
+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
+        run: ./gradlew sonar --parallel --build-cache
\ No newline at end of file
Index: gradle/wrapper/gradle-wrapper.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
--- /dev/null	(date 1730306755531)
+++ b/gradle/wrapper/gradle-wrapper.properties	(date 1730306755531)
@@ -0,0 +1,6 @@
+#Mon Mar 11 13:43:48 CET 2024
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.4-bin.zip
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
Index: gradle/libs.versions.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
new file mode 100644
--- /dev/null	(date 1731617442000)
+++ b/gradle/libs.versions.toml	(date 1731617442000)
@@ -0,0 +1,120 @@
+[versions]
+agp = "8.3.0"
+firebaseBom = "33.4.0"
+kotlin = "1.8.10"
+coreKtx = "1.12.0"
+ktfmt = "0.17.0"
+junit = "4.13.2"
+junitVersion = "1.1.5"
+espressoCore = "3.5.1"
+appcompat = "1.6.1"
+material = "1.11.0"
+composeBom = "2024.02.02"
+composeActivity = "1.8.2"
+composeViewModel = "2.7.0"
+lifecycleRuntimeKtx = "2.7.0"
+kaspresso = "1.5.5"
+mockitoAndroid = "5.14.2"
+mockitoCore = "5.14.2"
+mockitoInline = "5.2.0"
+mockitoKotlin = "5.4.0"
+mockk = "1.13.13"
+mockk-android = "1.13.13"
+okhttp = "4.9.1"
+robolectric = "4.11.1"
+sonar = "4.4.1.3373"
+firebaseFirestoreKtx = "25.1.0"
+
+# gradle/libs.versions.toml
+gms = "4.4.2"
+
+# Firebase Libraries
+firebaseAnalytics = "21.0.0"
+firebaseAuth = "23.0.0"
+firebaseAuthKtx = "23.0.0"
+firebaseDatabaseKtx = "21.0.0"
+firebaseFirestore = "25.1.0"
+firebaseUiAuth = "8.0.0"
+
+# Google Service and Maps
+playServicesAuth = "21.2.0"
+playServicesMaps = "19.0.0"
+espressoIntents = "3.6.1"
+navigationCompose = "2.8.2"
+volley = "1.2.1" # HTTP request
+json = "20240303"
+firebaseMessagingKtx = "24.0.2" #Json parsing
+mapsCompose = "4.3.3"
+mapsComposeUtils = "4.3.0"
+
+byteBuddy= "1.15.4"
+firebaseStorageKtx = "21.0.1"
+
+[libraries]
+google-play-services-location = { group = "com.google.android.gms", name = "play-services-location", version = "19.0.1" }
+# Firebase Libraries
+
+firebase-analytics = { module = "com.google.firebase:firebase-analytics", version.ref = "firebaseAnalytics" }
+firebase-bom = { module = "com.google.firebase:firebase-bom", version.ref = "firebaseBom" }
+
+firebase-firestore-ktx = { group = "com.google.firebase", name = "firebase-firestore-ktx", version.ref = "firebaseFirestoreKtx" }
+
+firebase-auth-ktx = { group = "com.google.firebase", name = "firebase-auth-ktx", version.ref = "firebaseAuthKtx" }
+firebase-auth = { module = "com.google.firebase:firebase-auth", version.ref = "firebaseAuth" }
+firebase-database-ktx = { module = "com.google.firebase:firebase-database-ktx", version.ref = "firebaseDatabaseKtx" }
+firebase-firestore = { module = "com.google.firebase:firebase-firestore", version.ref = "firebaseFirestore" }
+firebase-ui-auth = { module = "com.firebaseui:firebase-ui-auth", version.ref = "firebaseUiAuth" }
+
+androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
+google-firebase-auth = { module = "com.google.firebase:firebase-auth" }
+junit = { group = "junit", name = "junit", version.ref = "junit" }
+androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
+androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
+androidx-appcompat = { group = "androidx.appcompat", name = "appcompat", version.ref = "appcompat" }
+material = { group = "com.google.android.material", name = "material", version.ref = "material" }
+mockk = { group = "io.mockk", name = "mockk", version.ref = "mockk" }
+mockk-android = { group = "io.mockk", name = "mockk-android", version.ref = "mockk-android" }
+mockito-android = { module = "org.mockito:mockito-android", version.ref = "mockitoAndroid" }
+mockito-core = { module = "org.mockito:mockito-core", version.ref = "mockitoCore" }
+mockito-inline = { module = "org.mockito:mockito-inline", version.ref = "mockitoInline" }
+mockito-kotlin = { module = "org.mockito.kotlin:mockito-kotlin" , version.ref="mockitoKotlin"}
+androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
+
+compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
+compose-material3 = { group = "androidx.compose.material3", name = "material3" }
+compose-ui = { group = "androidx.compose.ui", name = "ui" }
+compose-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
+compose-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
+compose-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
+compose-activity = { group = "androidx.activity", name = "activity-compose", version.ref = "composeActivity" }
+compose-viewmodel = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-compose", version.ref = "composeViewModel" }
+compose-test-junit = { group = "androidx.compose.ui", name = "ui-test-junit4" }
+compose-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
+
+kaspresso = { group = "com.kaspersky.android-components", name = "kaspresso", version.ref = "kaspresso" }
+kaspresso-compose = { group = "com.kaspersky.android-components", name = "kaspresso-compose-support", version.ref = "kaspresso" }
+
+okhttp = { module = "com.squareup.okhttp3:okhttp", version.ref = "okhttp" }
+play-services-auth = { module = "com.google.android.gms:play-services-auth", version.ref = "playServicesAuth" }
+play-services-maps = { module = "com.google.android.gms:play-services-maps", version.ref = "playServicesMaps" }
+
+robolectric = { module = "org.robolectric:robolectric", version.ref = "robolectric" }
+androidx-navigation-compose = { group = "androidx.navigation", name = "navigation-compose", version.ref = "navigationCompose" }
+
+androidx-espresso-intents = { group = "androidx.test.espresso", name = "espresso-intents", version.ref = "espressoIntents" }
+volley = { module = "com.android.volley:volley", version.ref = "volley" }
+json = { module = "org.json:json", version.ref = "json" }
+firebase-messaging-ktx = { group = "com.google.firebase", name = "firebase-messaging-ktx", version.ref = "firebaseMessagingKtx" }
+
+maps-compose = { module = "com.google.maps.android:maps-compose", version.ref = "mapsCompose" }
+maps-compose-utils = { module = "com.google.maps.android:maps-compose-utils", version.ref = "mapsComposeUtils" }
+firebase-storage-ktx = { group = "com.google.firebase", name = "firebase-storage-ktx", version.ref = "firebaseStorageKtx" }
+
+
+
+[plugins]
+androidApplication = { id = "com.android.application", version.ref = "agp" }
+jetbrainsKotlinAndroid = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
+ktfmt = { id = "com.ncorti.ktfmt.gradle", version.ref = "ktfmt" }
+sonar = { id = "org.sonarqube", version.ref = "sonar" }
+gms = { id = "com.google.gms.google-services", version.ref = "gms" }
\ No newline at end of file
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
new file mode 100644
--- /dev/null	(date 1730306755516)
+++ b/README.md	(date 1730306755516)
@@ -0,0 +1,30 @@
+# Bookswap
+
+## Description
+The application would consist of an online version of the free book exchange boxes often found in small villages scattered throughout the whole of the Swiss countryside, it would help avoid having to search for said box exchanges and would additionally allow a search for a more desirable book than what perhaps would be in the box if one were to simply walk up to said box and have a look.
+
+The intended target audience are the older folk who most often use said exchange boxes and avid readers who may either not have easy access to the boxes or who do, yet prefer looking for books that may cater to them.
+
+It would include a repository of books that you have read and are willing to exchange, this is a list or repository of book entries each containing a unique bookID (generated upon creation, unique to each entry), a title, an author, a back cover text, a series of tags on the subject, an optional note on opinions about the book and a rating by the entry owner. 
+
+We would additionally include a functionality by which one can take two pictures of the front and back covers and it would automatically fill in all information, this is to aid mainly with the back cover description, as they may be long and lengthy enough to consider an annoyance having to write it in a text box on the app.
+
+Next there is the recommendation version, one can click on tags (at least one is mandatory) on the genre of the book, this would allow that upon a good opinion of a book, the app will recommend using an AI the closest books that match the genres you like. This would of course use geolocation as it must match you with books that lie somewhere in your near vicinity. 
+
+There is also an AI that takes in a request that can be somewhat vague and come up with better books according to your current mood and desires.
+
+Lastly, there is a method of connecting with other people to propose the book exchange, or maybe something further… Each account has a few things, mostly based on the google login, which would allow you to enter a chatbox with the people you want a book from, it would be a very simple chatbox, with minimal memory of previous texts, but long enough to set up a meeting and hopefully provide you with a new book and perhaps a new close acquaintance.
+
+- For the split app model, we will use the public cloud services not only for the google login, but also for storing the repository of books and the chatbox.
+- A google login will be used to share info between devices.
+- It will use geolocation for the recommendation and camera for easier creation of book entries
+- The scans of the books and entry creation and managing will be offline and doable without connectivity, it will also store a state so you can see your directory as it was the last time the android was connected.It will update the cloud upon reconnecting.
+
+## Links
+[Figma link](https://www.figma.com/design/uyHS0PV5RBnmToK2JuTb4h/Untitled?node-id=0-1&m=dev&t=VdHNM8v7U5bhvsW7-1)
+
+[Team review sheet](https://docs.google.com/spreadsheets/d/1hyi3ISzlwAXZ63ztd7Q84RkBFf24cPgatv3uUx4Y4hc/edit?usp=sharing)
+
+[Team minutes](https://docs.google.com/spreadsheets/d/1YF34CWge25Y1hSQsP5UWHCDoyYNJaxIPasSb13gWYao/edit?usp=sharing)
+
+[Architecture Diagram](https://lucid.app/lucidchart/a07f4bb7-a054-40e9-95be-d4cbb0485822/edit?viewport_loc=-1324%2C33%2C6059%2C2938%2C0_0&invitationId=inv_d502a57d-8d89-4e37-9a4f-f06ec2cf1941)
Index: gradle.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
--- /dev/null	(date 1730306755530)
+++ b/gradle.properties	(date 1730306755530)
@@ -0,0 +1,23 @@
+# Project-wide Gradle settings.
+# IDE (e.g. Android Studio) users:
+# Gradle settings configured through the IDE *will override*
+# any settings specified in this file.
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. For more details, visit
+# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
+# org.gradle.parallel=true
+# AndroidX package structure to make it clearer which packages are bundled with the
+# Android operating system, and which are packaged with your app's APK
+# https://developer.android.com/topic/libraries/support-library/androidx-rn
+android.useAndroidX=true
+# Kotlin code style for this project: "official" or "obsolete":
+kotlin.code.style=official
+# Enables namespacing of each library's R class so that its R class includes only the
+# resources declared in the library itself and none from the library's dependencies,
+# thereby reducing the size of the R class for that library
+android.nonTransitiveRClass=true
\ No newline at end of file
Index: app/src/main/java/com/android/bookswap/data/MessageBox.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/MessageBox.kt b/app/src/main/java/com/android/bookswap/data/MessageBox.kt
new file mode 100644
--- /dev/null	(date 1731615667845)
+++ b/app/src/main/java/com/android/bookswap/data/MessageBox.kt	(date 1731615667845)
@@ -0,0 +1,4 @@
+package com.android.bookswap.data
+
+/** Data class for the message box */
+data class MessageBox(val contact: DataUser, val message: String, val date: String)
Index: app/src/androidTest/java/com/android/bookswap/ui/books/add/BookAdditionChoiceScreenTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/books/add/BookAdditionChoiceScreenTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/books/add/BookAdditionChoiceScreenTest.kt
new file mode 100644
--- /dev/null	(date 1731615667838)
+++ b/app/src/androidTest/java/com/android/bookswap/ui/books/add/BookAdditionChoiceScreenTest.kt	(date 1731615667838)
@@ -0,0 +1,47 @@
+package com.android.bookswap.ui.books.add
+
+import androidx.compose.ui.test.assertHasClickAction
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.navigation.compose.rememberNavController
+import com.android.bookswap.ui.navigation.NavigationActions
+import io.mockk.mockk
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+class BookAdditionChoiceScreenTest {
+
+  @get:Rule val composeTestRule = createComposeRule()
+  private lateinit var mockNavigationActions: NavigationActions
+
+  @Before
+  fun setUp() {
+    mockNavigationActions = mockk()
+  }
+
+  @Test
+  fun hasRequiredComponents() {
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      BookAdditionChoiceScreen(navigationActions)
+    }
+    composeTestRule.onNodeWithTag("button_Manually").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("button_From ISBN").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("button_From Photo").assertIsDisplayed()
+  }
+
+  @Test
+  fun hasClickableComponents() {
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      BookAdditionChoiceScreen(navigationActions)
+    }
+    composeTestRule.onNodeWithTag("button_Manually").assertHasClickAction()
+    composeTestRule.onNodeWithTag("button_From ISBN").assertHasClickAction()
+    composeTestRule.onNodeWithTag("button_From Photo").assertHasClickAction()
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/books/edit/EditBookTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/books/edit/EditBookTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/books/edit/EditBookTest.kt
new file mode 100644
--- /dev/null	(date 1730990089000)
+++ b/app/src/androidTest/java/com/android/bookswap/ui/books/edit/EditBookTest.kt	(date 1730990089000)
@@ -0,0 +1,161 @@
+package com.android.bookswap.ui.books.edit
+
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.assertTextContains
+import androidx.compose.ui.test.assertTextEquals
+import androidx.compose.ui.test.hasTestTag
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.compose.ui.test.performClick
+import androidx.compose.ui.test.performScrollToNode
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.source.network.BooksFirestoreRepository
+import com.android.bookswap.ui.navigation.NavigationActions
+import io.mockk.MockKAnnotations
+import io.mockk.every
+import io.mockk.impl.annotations.MockK
+import java.util.UUID
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+class EditBookScreenTest {
+
+  @MockK private lateinit var booksRepository: BooksFirestoreRepository
+
+  @MockK private lateinit var navigationActions: NavigationActions
+
+  @get:Rule val composeTestRule = createComposeRule()
+
+  private val sampleBook =
+      DataBook(
+          uuid = UUID.randomUUID(),
+          title = "Sample Book",
+          author = "Sample Author",
+          description = "Sample Description",
+          rating = 4,
+          photo = "sample_photo_url",
+          language = BookLanguages.ENGLISH,
+          isbn = "123456789",
+          genres = listOf(BookGenres.FANTASY))
+
+  @Before
+  fun setUp() {
+    MockKAnnotations.init(this)
+
+    every { navigationActions.currentRoute() } returns "EDIT_BOOK"
+  }
+
+  @Test
+  fun displayEditScreenComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("editBookScreen").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditTitleComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("editBookTitle").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditTitleValueComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("editBookTitle").assertTextEquals("Edit your Book")
+  }
+
+  @Test
+  fun displayEditButtonComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("goBackButton").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditSaveValueComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule
+        .onNodeWithTag("editBookScreenColumn")
+        .performScrollToNode(hasTestTag("bookSave"))
+    composeTestRule.onNodeWithTag("bookSave").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("bookSave").assertTextEquals("Save")
+  }
+
+  @Test
+  fun displayEditDeleteValueComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule
+        .onNodeWithTag("editBookScreenColumn")
+        .performScrollToNode(hasTestTag("bookDelete"))
+    composeTestRule.onNodeWithTag("bookDelete").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("bookDelete").assertTextEquals("Delete")
+  }
+
+  @Test
+  fun displayEditBookTitleComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("inputBookTitle").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookAuthorComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookAuthor").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookDescriptionComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookDescription").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookRatingComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookRating").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookPhotoComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookPhoto").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookLanguageComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookLanguage").assertIsDisplayed()
+  }
+
+  @Test
+  fun inputsHaveInitialValue() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("inputBookTitle").assertTextContains(sampleBook.title)
+    composeTestRule.onNodeWithTag("inputBookAuthor").assertTextContains(sampleBook.author ?: "")
+    composeTestRule
+        .onNodeWithTag("inputBookDescription")
+        .assertTextContains(sampleBook.description ?: "")
+    composeTestRule.onNodeWithTag("inputBookPhoto").assertTextContains(sampleBook.photo ?: "")
+    composeTestRule
+        .onNodeWithTag("inputBookLanguage")
+        .assertTextContains(sampleBook.language.toString())
+  }
+
+  @Test
+  fun genreDropdownWorks() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    // opens genre dropdown and select a genre
+    composeTestRule.onNodeWithTag("GenreDropdown").performClick()
+    composeTestRule.onNodeWithTag("GenreDropdownItem_Fantasy").performClick()
+
+    // verify the selected genre
+    composeTestRule.onNodeWithTag("SelectedGenre").assertTextContains("Fantasy")
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/books/BookProfileScreenTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/books/BookProfileScreenTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/books/BookProfileScreenTest.kt
new file mode 100644
--- /dev/null	(date 1731615667838)
+++ b/app/src/androidTest/java/com/android/bookswap/ui/books/BookProfileScreenTest.kt	(date 1731615667838)
@@ -0,0 +1,99 @@
+package com.android.bookswap.ui.books
+
+import androidx.compose.ui.test.assertHasClickAction
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.hasTestTag
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.compose.ui.test.performClick
+import androidx.compose.ui.test.performScrollToNode
+import androidx.navigation.compose.rememberNavController
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.ui.navigation.NavigationActions
+import io.mockk.mockk
+import java.util.UUID
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+class BookProfileScreenTest {
+
+  @get:Rule val composeTestRule = createComposeRule()
+  private lateinit var mockNavController: NavigationActions
+
+  private val testBook =
+      DataBook(
+          uuid = UUID.randomUUID(),
+          title = "Historia de España",
+          author = "Jose Ignacio Pastor Iglesias",
+          description =
+              "Recuento de la historia de España desde los primeros pobladores hasta la actualidad. Escrito con especial enfasis en los reyes catolicos y la exploracion de América.",
+          rating = 9,
+          photo = null,
+          language = BookLanguages.SPANISH,
+          isbn = "978-84-09025-23-5",
+          genres = listOf(BookGenres.HISTORICAL, BookGenres.NONFICTION, BookGenres.BIOGRAPHY))
+
+  @Before
+  fun setUp() {
+    mockNavController = mockk()
+  }
+
+  @Test
+  fun hasRequiredComponents() {
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      BookProfileScreen(testBook, navigationActions)
+    }
+
+    composeTestRule.onNodeWithTag("bookTitle").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("bookAuthor").assertIsDisplayed()
+    composeTestRule
+        .onNodeWithTag("bookProfileScroll")
+        .performScrollToNode(hasTestTag("bookProfileEditionPlace"))
+    composeTestRule.onNodeWithTag("bookProfileLanguage").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("bookProfileGenresTitle").assertIsDisplayed()
+    testBook.genres.forEach { genre ->
+      composeTestRule.onNodeWithTag("bookProfileGenre${genre.Genre}").assertIsDisplayed()
+    }
+    composeTestRule.onNodeWithTag("bookProfileISBN").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("bookProfileDate").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("bookProfileVolume").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("bookProfileIssue").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("bookProfileEditorial").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("bookProfileEditionPlace").assertIsDisplayed()
+  }
+
+  @Test
+  fun iconsAreClickable() {
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      BookProfileScreen(testBook, navigationActions)
+    }
+
+    composeTestRule.onNodeWithTag("bookProfileImageLeft").assertHasClickAction()
+    composeTestRule.onNodeWithTag("bookProfileImageRight").assertHasClickAction()
+  }
+
+  @Test
+  fun pictureChangesOnIconClick() {
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      BookProfileScreen(testBook, navigationActions)
+    }
+
+    // Verify the first picture is displayed
+    composeTestRule.onNodeWithTag("bookProfileImage Isabel La Catolica").assertIsDisplayed()
+
+    // Perform a click action on the icon
+    composeTestRule.onNodeWithTag("bookProfileImageRight").performClick()
+
+    // Verify the next picture is displayed
+    composeTestRule.onNodeWithTag("bookProfileImage Felipe II").assertIsDisplayed()
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/MainActivityTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/MainActivityTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/MainActivityTest.kt
new file mode 100644
--- /dev/null	(date 1731615667837)
+++ b/app/src/androidTest/java/com/android/bookswap/ui/MainActivityTest.kt	(date 1731615667837)
@@ -0,0 +1,17 @@
+package com.android.bookswap.ui
+
+import androidx.compose.ui.test.junit4.createAndroidComposeRule
+import androidx.compose.ui.test.onNodeWithTag
+import com.android.bookswap.MainActivity
+import org.junit.Rule
+import org.junit.Test
+
+class MainActivityTest {
+  @get:Rule val androidComposeRule = createAndroidComposeRule<MainActivity>()
+
+  @Test
+  fun testMainActivity() {
+    androidComposeRule.onNodeWithTag("main_screen_container").assertExists()
+    androidComposeRule.onNodeWithTag("SignInScreen").assertExists()
+  }
+}
Index: app/src/test/java/com/android/bookswap/data/source/api/ChatGptApiCallTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/source/api/ChatGptApiCallTest.kt b/app/src/test/java/com/android/bookswap/data/source/api/ChatGptApiCallTest.kt
new file mode 100644
--- /dev/null	(date 1731615667857)
+++ b/app/src/test/java/com/android/bookswap/data/source/api/ChatGptApiCallTest.kt	(date 1731615667857)
@@ -0,0 +1,51 @@
+package com.android.bookswap.data.source.api
+
+import android.content.Context
+import com.android.volley.Request
+import com.android.volley.RequestQueue
+import com.android.volley.toolbox.Volley
+import io.mockk.every
+import io.mockk.mockk
+import io.mockk.mockkStatic
+import junit.framework.TestCase.assertEquals
+import org.junit.Before
+import org.junit.Test
+
+class ChatGptApiCallTest {
+  private lateinit var mockContext: Context
+  private lateinit var mockRequestQueue: RequestQueue
+  private lateinit var chatGPTApiService: ChatGPTApiService
+  private lateinit var request: Request<*>
+
+  @Before
+  fun setUp() {
+
+    mockContext = mockk()
+
+    mockRequestQueue = mockk()
+    request = mockk()
+
+    mockkStatic(Volley::class)
+    every { Volley.newRequestQueue(any()) } returns mockRequestQueue
+
+    chatGPTApiService = ChatGPTApiService(mockContext, mode = false)
+  }
+
+  @Test
+  fun `test sendChatRequest adds request to requestQueue`() {
+
+    val userMessages = listOf("Hello")
+    val onSuccess: (String) -> Unit = mockk(relaxed = true)
+    val onError: (String) -> Unit = mockk(relaxed = true)
+    var check = 0
+    every { mockRequestQueue.add(any<Request<*>>()) } answers
+        {
+          check++
+          return@answers request
+        }
+
+    chatGPTApiService.sendChatRequest(userMessages, onSuccess, onError)
+
+    assertEquals(1, check)
+  }
+}
Index: app/src/main/res/xml/filepaths.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/xml/filepaths.xml b/app/src/main/res/xml/filepaths.xml
new file mode 100644
--- /dev/null	(date 1731615667856)
+++ b/app/src/main/res/xml/filepaths.xml	(date 1731615667856)
@@ -0,0 +1,4 @@
+<paths>
+    <!-- creates a reference to the cache folder that the system maintains -->
+    <cache-path name="temporary_camera_images" path="/" />
+</paths>
\ No newline at end of file
Index: app/src/main/java/com/android/bookswap/ui/components/TopAppBarComponent.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/components/TopAppBarComponent.kt b/app/src/main/java/com/android/bookswap/ui/components/TopAppBarComponent.kt
new file mode 100644
--- /dev/null	(date 1731615667851)
+++ b/app/src/main/java/com/android/bookswap/ui/components/TopAppBarComponent.kt	(date 1731615667851)
@@ -0,0 +1,28 @@
+package com.android.bookswap.ui.components
+
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.Text
+import androidx.compose.material3.TopAppBar
+import androidx.compose.material3.TopAppBarDefaults
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.platform.testTag
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.profile.ProfileIcon
+import com.android.bookswap.ui.theme.ColorVariable
+
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun TopAppBarComponent(
+    modifier: Modifier = Modifier,
+    navigationActions: NavigationActions,
+    title: String = navigationActions.currentRoute()
+) {
+  TopAppBar(
+      title = { Text(text = title, Modifier.testTag("TopAppBar_Title")) },
+      modifier = modifier.testTag("TopAppBar"),
+      { BackButtonComponent(navActions = navigationActions) },
+      { ProfileIcon(navigationActions = navigationActions) },
+      TopAppBarDefaults.windowInsets,
+      TopAppBarDefaults.topAppBarColors(ColorVariable.BackGround))
+}
Index: app/src/main/java/com/android/bookswap/ui/books/edit/EditBookScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/books/edit/EditBookScreen.kt b/app/src/main/java/com/android/bookswap/ui/books/edit/EditBookScreen.kt
new file mode 100644
--- /dev/null	(date 1731635418607)
+++ b/app/src/main/java/com/android/bookswap/ui/books/edit/EditBookScreen.kt	(date 1731635418607)
@@ -0,0 +1,317 @@
+package com.android.bookswap.ui.books.edit
+
+import android.widget.Toast
+import androidx.compose.foundation.background
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.widthIn
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.automirrored.filled.ArrowBack
+import androidx.compose.material3.Button
+import androidx.compose.material3.ButtonDefaults
+import androidx.compose.material3.DropdownMenuItem
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.ExposedDropdownMenuBox
+import androidx.compose.material3.ExposedDropdownMenuDefaults
+import androidx.compose.material3.Icon
+import androidx.compose.material3.IconButton
+import androidx.compose.material3.OutlinedTextField
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.Text
+import androidx.compose.material3.TextFieldDefaults
+import androidx.compose.material3.TopAppBar
+import androidx.compose.material3.TopAppBarDefaults
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.setValue
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.platform.LocalConfiguration
+import androidx.compose.ui.platform.LocalContext
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.unit.dp
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.source.network.BooksFirestoreSource
+import com.android.bookswap.ui.books.add.createDataBook
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.theme.ColorVariable
+
+/** Constants * */
+private val SCREEN_PADDING = 16.dp
+private val ELEMENT_SPACING = 8.dp
+private val BUTTON_SPACER_HEIGHT = 16.dp
+private const val COLUMN_WIDTH_RATIO = 0.9f // Column width as 90% of screen width
+
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun EditBookScreen(
+    booksRepository: BooksFirestoreSource,
+    navigationActions: NavigationActions,
+    book: DataBook
+) {
+
+  val configuration = LocalConfiguration.current
+  val screenWidth = configuration.screenWidthDp.dp
+  val columnMaxWidth = screenWidth * COLUMN_WIDTH_RATIO
+  /*val book =
+      booksRepository.selectedBook.collectAsState().value
+          ?: return Text(text = "No Book selected. Should not happen", color = Color.Red)
+  */
+  // Use this and modify the editBookScreen structure if needed when incorporating in the app
+  // navigation
+
+  var title by remember { mutableStateOf(book.title) }
+  var author by remember { mutableStateOf(book.author ?: "") }
+  var description by remember { mutableStateOf(book.description ?: "") }
+  var rating by remember { mutableStateOf(book.rating?.toString() ?: "") }
+  var photo by remember { mutableStateOf(book.photo ?: "") }
+  var language by remember { mutableStateOf(book.language.toString()) }
+  var genres by remember { mutableStateOf(book.genres) }
+  var selectedGenre by remember { mutableStateOf<BookGenres?>(null) } // Genre selection state
+  var expanded by remember { mutableStateOf(false) } // State for dropdown menu
+
+  val context = LocalContext.current
+
+  Scaffold(
+      modifier = Modifier.testTag("editBookScreen").background(ColorVariable.BackGround),
+      containerColor = ColorVariable.BackGround, // Sets entire Scaffold background color
+      topBar = {
+        TopAppBar(
+            title = { Text("Edit your Book", modifier = Modifier.testTag("editBookTitle")) },
+            navigationIcon = {
+              IconButton(
+                  modifier = Modifier.testTag("goBackButton"),
+                  onClick = { navigationActions.goBack() }) {
+                    Icon(
+                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
+                        contentDescription = "Back")
+                  }
+            },
+            colors = TopAppBarDefaults.topAppBarColors(containerColor = ColorVariable.BackGround))
+      },
+      content = { paddingValues ->
+        LazyColumn(
+            modifier =
+                Modifier.fillMaxWidth()
+                    .padding(paddingValues)
+                    .padding(SCREEN_PADDING)
+                    .widthIn(max = columnMaxWidth)
+                    .background(ColorVariable.BackGround)
+                    .testTag("editBookScreenColumn"),
+            verticalArrangement = Arrangement.spacedBy(ELEMENT_SPACING)) {
+              // Title Edit Field
+              item {
+                OutlinedTextField(
+                    value = title,
+                    onValueChange = { title = it },
+                    label = { Text("Title") },
+                    placeholder = { Text("Enter the book title") },
+                    modifier = Modifier.fillMaxWidth().testTag("inputBookTitle"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+
+              item {
+                // Genre Dropdown Edit Field
+                ExposedDropdownMenuBox(
+                    expanded = expanded,
+                    onExpandedChange = { expanded = !expanded },
+                    modifier = Modifier.fillMaxWidth().testTag("GenreDropdown")) {
+                      OutlinedTextField(
+                          value = selectedGenre?.Genre ?: "Select Genre",
+                          onValueChange = {},
+                          label = { Text("Genre") },
+                          readOnly = true,
+                          trailingIcon = {
+                            ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)
+                          },
+                          modifier = Modifier.menuAnchor().testTag("SelectedGenre"),
+                          colors =
+                              TextFieldDefaults.outlinedTextFieldColors(
+                                  containerColor = ColorVariable.Secondary,
+                                  focusedBorderColor = Color.Black,
+                                  unfocusedBorderColor = Color.Black))
+                      ExposedDropdownMenu(
+                          expanded = expanded, onDismissRequest = { expanded = false }) {
+                            BookGenres.values().forEach { genre ->
+                              DropdownMenuItem(
+                                  text = { Text(text = genre.Genre) },
+                                  modifier = Modifier.testTag("GenreDropdownItem_${genre.Genre}"),
+                                  onClick = {
+                                    selectedGenre = genre
+                                    genres = listOf(genre) // Update genres list with selected genre
+                                    expanded = false
+                                  })
+                            }
+                          }
+                    }
+              }
+
+              item {
+                // Author Edit Field
+                OutlinedTextField(
+                    value = author,
+                    onValueChange = { author = it },
+                    label = { Text("Author") },
+                    placeholder = { Text("Enter the author's name") },
+                    modifier = Modifier.fillMaxWidth().testTag("inputBookAuthor"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+
+              item {
+                // Description Edit Field
+                OutlinedTextField(
+                    value = description,
+                    onValueChange = { description = it },
+                    label = { Text("Description") },
+                    placeholder = { Text("Provide a description of the book") },
+                    modifier = Modifier.fillMaxWidth().testTag("inputBookDescription"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+
+              item {
+                // Rating Edit Field
+                OutlinedTextField(
+                    value = rating,
+                    onValueChange = { rating = it },
+                    label = { Text("Rating") },
+                    placeholder = { Text("Rate the book (e.g. 4.5)") },
+                    modifier = Modifier.fillMaxWidth().testTag("inputBookRating"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+              // ISBN Edit Field
+              /*OutlinedTextField(
+                  value = isbn,
+                  onValueChange = { isbn = it },
+                  label = { Text("ISBN") },
+                  placeholder = { Text("ISBN Number") },
+                  modifier = Modifier.fillMaxWidth().testTag("inputBookISBN")
+              )*/
+              // Remove for now but could be added later
+              item {
+                // Photo Edit Field
+                /*
+                OutlinedTextField(
+                    value = photo,
+                    onValueChange = { photo = it },
+                    label = { Text("Photo") },
+                    placeholder = { Text("Enter the photo URL") },
+                    modifier = Modifier.fillMaxWidth().testTag("inputBookPhoto"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black)
+                ) //TODO: Add photo upload functionality
+
+                    */
+              }
+
+              item {
+                // Language Edit Field
+                OutlinedTextField(
+                    value = language,
+                    onValueChange = { language = it },
+                    label = { Text("Language ") },
+                    placeholder = { Text("In which language are the book") },
+                    modifier = Modifier.testTag("inputBookLanguage"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+              item { Spacer(modifier = Modifier.height(BUTTON_SPACER_HEIGHT)) }
+
+              item {
+                Button(
+                    onClick = {
+                      try {
+                        if (title.isBlank())
+                            throw IllegalArgumentException("Title cannot be null or blank")
+                        if (author.isBlank())
+                            throw IllegalArgumentException("Author cannot be null or blank")
+                        if (description.isBlank())
+                            throw IllegalArgumentException("Description cannot be null or blank")
+                        if (rating.isBlank())
+                            throw IllegalArgumentException("Rating cannot be null or blank")
+                        if (language.isBlank())
+                            throw IllegalArgumentException("Language cannot be null or blank")
+                        if (book.isbn.isNullOrBlank())
+                            throw IllegalArgumentException("ISBN cannot be null or blank")
+                        if (genres.isEmpty())
+                            throw IllegalArgumentException("Genres cannot be empty")
+
+                        val updatedBook =
+                            createDataBook(
+                                context = context,
+                                uuid = book.uuid,
+                                title = title,
+                                author = author,
+                                description = description,
+                                ratingStr = rating,
+                                photo = book.photo.toString(),
+                                bookLanguageStr = language,
+                                isbn = book.isbn,
+                                genres = genres)
+
+                        booksRepository.updateBook(
+                            updatedBook!!,
+                            onSuccess = { navigationActions.goBack() },
+                            onFailure = {
+                              Toast.makeText(context, "Failed to update book.", Toast.LENGTH_SHORT)
+                                  .show()
+                            })
+                      } catch (e: Exception) {
+                        Toast.makeText(context, "Error: ${e.message}", Toast.LENGTH_SHORT).show()
+                      }
+                    },
+                    modifier = Modifier.fillMaxWidth().testTag("bookSave"),
+                    enabled = title.isNotBlank(),
+                    colors = ButtonDefaults.buttonColors(containerColor = ColorVariable.Primary)) {
+                      Text("Save", color = Color.White)
+                    }
+              }
+
+              item {
+                Button(
+                    onClick = {
+                      booksRepository.deleteBooks(
+                          book.uuid,
+                          book,
+                          onSuccess = { navigationActions.goBack() },
+                          onFailure = {
+                            Toast.makeText(context, "Failed to delete book.", Toast.LENGTH_SHORT)
+                                .show()
+                          })
+                    },
+                    modifier = Modifier.fillMaxWidth().testTag("bookDelete"),
+                    colors = ButtonDefaults.buttonColors(containerColor = ColorVariable.Primary)) {
+                      Text("Delete", color = Color.White)
+                    }
+              }
+            }
+      })
+}
Index: app/src/main/java/com/android/bookswap/model/PhotoRequester.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/PhotoRequester.kt b/app/src/main/java/com/android/bookswap/model/PhotoRequester.kt
new file mode 100644
--- /dev/null	(date 1731615667847)
+++ b/app/src/main/java/com/android/bookswap/model/PhotoRequester.kt	(date 1731615667847)
@@ -0,0 +1,88 @@
+package com.android.bookswap.model
+
+import android.Manifest
+import android.content.Context
+import android.graphics.ImageDecoder
+import android.net.Uri
+import androidx.activity.compose.ManagedActivityResultLauncher
+import androidx.activity.compose.rememberLauncherForActivityResult
+import androidx.activity.result.contract.ActivityResultContracts
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.graphics.ImageBitmap
+import androidx.compose.ui.graphics.asImageBitmap
+import androidx.core.content.FileProvider
+import com.android.bookswap.BuildConfig
+import java.io.File
+
+const val IMAGE_TYPE = ".jpg"
+const val IMAGE_PREFIX = "temp_image_"
+/**
+ * Easy code abstraction allowing the user to open their photo app and take a photo of their choice
+ * and then confirm it. Please call [Init] (Composable) in your UI (doesn't matter where)
+ *
+ * @param context the ui context
+ * @param callback what to do when the user has finished (or failed) taking a photo
+ */
+class PhotoRequester(
+    private val context: Context,
+    private val callback: (Result<ImageBitmap>) -> Unit
+) {
+  private var initialized = false // Confirm that init was called
+
+  private lateinit var permissionLauncher: ManagedActivityResultLauncher<String, Boolean>
+  private lateinit var cameraLauncher: ManagedActivityResultLauncher<Uri, Boolean>
+
+  private var fileUri: Uri? = null // Temp file path
+
+  @Composable
+  fun Init() {
+    initialized = true
+
+    // When a photo is called
+    cameraLauncher =
+        rememberLauncherForActivityResult(ActivityResultContracts.TakePicture()) { isImageSaved ->
+          if (isImageSaved) {
+            val source = ImageDecoder.createSource(context.contentResolver, fileUri!!)
+
+            callback(Result.success(ImageDecoder.decodeBitmap(source).asImageBitmap()))
+          } else {
+            fileUri = null
+            callback(Result.failure(Exception("Image could not be saved in phone.")))
+          }
+        }
+    // Ask for permission before using the camera.
+    permissionLauncher =
+        rememberLauncherForActivityResult(ActivityResultContracts.RequestPermission()) {
+            permissionGranted ->
+          if (permissionGranted) {
+            fileUri = getTempUri()
+            cameraLauncher.launch(fileUri)
+          } else {
+            callback(Result.failure(Exception("Permission denied.")))
+          }
+        }
+  }
+
+  /** Request a photo from the user, this will ends-up calling [callback] */
+  fun requestPhoto() {
+    if (!initialized) throw Error("Always call Init() before using requestPhoto()")
+
+    permissionLauncher.launch(Manifest.permission.CAMERA)
+  }
+
+  /** Generate a Uri for temporary file storage in the app cache. */
+  private fun getTempUri(): Uri {
+    val tempFile =
+        File.createTempFile(IMAGE_PREFIX, IMAGE_TYPE, context.cacheDir /* cache directory */)
+
+    // Create sandboxed url for this temp file - needed for the camera API
+    val uri =
+        FileProvider.getUriForFile(
+            context,
+            "${BuildConfig.APPLICATION_ID}.provider", // matches the provider information in the
+            // manifest
+            tempFile)
+
+    return uri
+  }
+}
Index: app/src/main/java/com/android/bookswap/model/PhotoViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/PhotoViewModel.kt b/app/src/main/java/com/android/bookswap/model/PhotoViewModel.kt
new file mode 100644
--- /dev/null	(date 1731617426316)
+++ b/app/src/main/java/com/android/bookswap/model/PhotoViewModel.kt	(date 1731617426316)
@@ -0,0 +1,267 @@
+package com.android.bookswap.model
+
+
+import android.graphics.Bitmap
+import android.graphics.BitmapFactory
+import android.util.Base64
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.graphics.ImageBitmap
+import androidx.compose.ui.graphics.asAndroidBitmap
+import androidx.compose.ui.platform.LocalContext
+import androidx.lifecycle.ViewModel
+import androidx.lifecycle.viewModelScope
+import com.android.bookswap.data.DataPhoto
+import com.android.bookswap.data.repository.PhotoRepository
+import java.io.ByteArrayOutputStream
+import java.io.InputStream
+import java.net.HttpURLConnection
+import java.net.URL
+import java.util.UUID
+import kotlinx.coroutines.launch
+
+/**
+ * ViewModel for managing photo-related operations.
+ *
+ * @property photoRepository Repository for handling photo data operations.
+ */
+class PhotoViewModel(private val photoRepository: PhotoRepository) : ViewModel() {
+  /**
+   * Generates a new UUID.
+   *
+   * @return A new UUID.
+   */
+  fun getNewUid(): UUID {
+    return photoRepository.getNewUUID()
+  }
+  /**
+   * Initializes the photo repository.
+   *
+   * @param callback Callback to be invoked with the result of the initialization.
+   */
+  fun init(callback: (Result<Unit>) -> Unit) {
+    viewModelScope.launch { photoRepository.init(callback) }
+  }
+  /**
+   * Retrieves a photo by its UUID.
+   *
+   * @param uid UUID of the photo to retrieve.
+   * @param onSuccess Callback to be invoked with the retrieved photo.
+   * @param onFailure Callback to be invoked with an exception if retrieval fails.
+   */
+  fun getPhoto(uid: UUID, callback: (Result<DataPhoto>) -> Unit) {
+    viewModelScope.launch { photoRepository.getPhoto(uid, callback) }
+  }
+  /**
+   * Converts a Bitmap to a Base64-encoded string.
+   *
+   * @param bitmap The Bitmap to convert.
+   * @return The Base64-encoded string representation of the Bitmap.
+   */
+  fun bitmapToBase64(bitmap: Bitmap): String {
+    return photoRepository.bitmapToBase64(bitmap)
+  }
+  /**
+   * Converts a Base64-encoded string to a Bitmap.
+   *
+   * @param base64 The Base64-encoded string to convert.
+   * @return The Bitmap representation of the Base64-encoded string.
+   */
+  fun base64ToBitmap(base64: String): Bitmap {
+    return photoRepository.base64ToBitmap(base64)
+  }
+  /**
+   * Converts an ImageBitmap to a Bitmap.
+   *
+   * @param imageBitmap The ImageBitmap to convert.
+   * @return The Bitmap representation of the ImageBitmap.
+   */
+  fun ImageBitmapToBitmap(imageBitmap: ImageBitmap): Bitmap {
+    return imageBitmap.asAndroidBitmap()
+  }
+  /**
+   * Composable function to take a photo using the device's camera.
+   *
+   * @param callback Callback to be invoked with the result of the photo capture.
+   */
+  @Composable
+  fun takePhoto(callback: (Result<DataPhoto>) -> Unit) {
+    val photoRequester =
+        PhotoRequester(LocalContext.current) { result ->
+          result
+              .onSuccess { imageBitmap ->
+                val bitmap = ImageBitmapToBitmap(imageBitmap)
+                val base64 = bitmapToBase64(bitmap)
+                val uuid = getNewUid()
+                val timestamp = System.currentTimeMillis()
+                val dataPhoto = DataPhoto(uuid, "", timestamp, base64)
+                callback(Result.success(dataPhoto))
+              }
+              .onFailure { exception -> callback(Result.failure(exception)) }
+        }
+
+    photoRequester.Init()
+    photoRequester.requestPhoto()
+  }
+  /**
+   * Converts a Bitmap to a Base64-encoded PNG string.
+   *
+   * @param bitmap The Bitmap to convert.
+   * @return The Base64-encoded PNG string representation of the Bitmap.
+   */
+  private fun bitmapToPng(bitmap: Bitmap): String {
+    val outputStream = ByteArrayOutputStream()
+    bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream)
+    val byteArray = outputStream.toByteArray()
+    return Base64.encodeToString(byteArray, Base64.DEFAULT)
+  }
+  /**
+   * Converts a Bitmap to a Base64-encoded JPEG string.
+   *
+   * @param bitmap The Bitmap to convert.
+   * @return The Base64-encoded JPEG string representation of the Bitmap.
+   */
+  private fun bitmapToJpeg(bitmap: Bitmap): String {
+    val outputStream = ByteArrayOutputStream()
+    bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream)
+    val byteArray = outputStream.toByteArray()
+    return Base64.encodeToString(byteArray, Base64.DEFAULT)
+  }
+  /**
+   * Converts a Base64-encoded JPEG string to a Bitmap.
+   *
+   * @param base64 The Base64-encoded JPEG string to convert.
+   * @return The Bitmap representation of the Base64-encoded JPEG string.
+   */
+  private fun JpegToBitmap(base64: String): Bitmap {
+    val decodedString = Base64.decode(base64, Base64.DEFAULT)
+    return android.graphics.BitmapFactory.decodeByteArray(decodedString, 0, decodedString.size)
+  }
+  /**
+   * Converts a Base64-encoded PNG string to a Bitmap.
+   *
+   * @param base64 The Base64-encoded PNG string to convert.
+   * @return The Bitmap representation of the Base64-encoded PNG string.
+   */
+  private fun PngToBitmap(base64: String): Bitmap {
+    val decodedString = Base64.decode(base64, Base64.DEFAULT)
+    return android.graphics.BitmapFactory.decodeByteArray(decodedString, 0, decodedString.size)
+  }
+  /**
+   * Saves a photo.
+   *
+   * @param bitmap The Bitmap of the photo to save.
+   * @param onSuccess Callback to be invoked with the saved photo.
+   * @param onFailure Callback to be invoked with an exception if saving fails.
+   */
+  fun savePhoto(bitmap: Bitmap, onSuccess: (DataPhoto) -> Unit, onFailure: (Exception) -> Unit) {
+    val base64 = bitmapToBase64(bitmap)
+    val uuid = getNewUid()
+    val timestamp = System.currentTimeMillis()
+
+    val dataPhoto = DataPhoto(uuid, url = "", timestamp, base64)
+    viewModelScope.launch {
+      photoRepository.addPhoto(
+          dataPhoto,
+          callback = { result ->
+            result.onSuccess { onSuccess(dataPhoto) }
+            result.onFailure { onFailure(it as Exception) }
+          })
+    }
+  }
+  /**
+   * Saves a photo from a Base64-encoded JPEG string.
+   *
+   * @param base64 The Base64-encoded JPEG string of the photo to save.
+   * @param onSuccess Callback to be invoked with the saved photo.
+   * @param onFailure Callback to be invoked with an exception if saving fails.
+   */
+  fun savePhotoJPEG(
+      base64: String,
+      onSuccess: (DataPhoto) -> Unit,
+      onFailure: (Exception) -> Unit
+  ) {
+    JpegToBitmap(base64).let { bitmap -> savePhoto(bitmap, onSuccess, onFailure) }
+  }
+  /**
+   * Saves a photo from a Base64-encoded PNG string.
+   *
+   * @param base64 The Base64-encoded PNG string of the photo to save.
+   * @param onSuccess Callback to be invoked with the saved photo.
+   * @param onFailure Callback to be invoked with an exception if saving fails.
+   */
+  fun savePhotoPNG(base64: String, onSuccess: (DataPhoto) -> Unit, onFailure: (Exception) -> Unit) {
+    savePhoto(PngToBitmap(base64), onSuccess, onFailure)
+  }
+  /**
+   * Converts a URL to a Bitmap.
+   *
+   * @param urlString The URL of the image to convert.
+   * @return The Bitmap representation of the image, or null if conversion fails.
+   */
+  fun urlToBitmap(urlString: String): Bitmap? {
+    return try {
+      val url = URL(urlString)
+      val connection: HttpURLConnection = url.openConnection() as HttpURLConnection
+      connection.doInput = true
+      connection.connect()
+      val input: InputStream = connection.inputStream
+      BitmapFactory.decodeStream(input)
+    } catch (e: Exception) {
+      e.printStackTrace()
+      null
+    }
+  }
+  /**
+   * Converts a Bitmap to a Base64-encoded URL string.
+   *
+   * @param bitmap The Bitmap to convert.
+   * @return The Base64-encoded URL string representation of the Bitmap.
+   */
+  fun bitmapToUrl(bitmap: Bitmap): String {
+    val outputStream = ByteArrayOutputStream()
+    bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream)
+    val byteArray = outputStream.toByteArray()
+    return Base64.encodeToString(byteArray, Base64.DEFAULT)
+  }
+  /**
+   * Converts a URL to a DataPhoto object.
+   *
+   * @param urlString The URL of the image to convert.
+   * @return The DataPhoto object representation of the image, or null if conversion fails.
+   */
+  fun urlToDataPhoto(urlString: String): DataPhoto? {
+    return urlToBitmap(urlString)?.let { bitmap ->
+      val base64 = bitmapToBase64(bitmap)
+      val uuid = getNewUid()
+      val timestamp = System.currentTimeMillis()
+      DataPhoto(uuid, urlString, timestamp, base64)
+    }
+  }
+
+  /**
+   * Converts a Base64-encoded URL string to a Bitmap.
+   *
+   * @param base64 The Base64-encoded URL string to convert.
+   * @return The Bitmap representation of the Base64-encoded URL string.
+   */
+  fun bitmapToDataUrl(
+      bitmap: Bitmap,
+      format: Bitmap.CompressFormat = Bitmap.CompressFormat.PNG
+  ): String {
+    val outputStream = ByteArrayOutputStream()
+    bitmap.compress(format, 100, outputStream) // Compress the Bitmap to the specified format
+    val byteArray = outputStream.toByteArray()
+    val base64String = Base64.encodeToString(byteArray, Base64.DEFAULT)
+
+    // Determine the MIME type based on the format
+    val mimeType =
+        when (format) {
+          Bitmap.CompressFormat.JPEG -> "image/jpeg"
+          Bitmap.CompressFormat.PNG -> "image/png"
+          Bitmap.CompressFormat.WEBP -> "image/webp"
+          else -> "image/png" // default to PNG if format is unknown
+        }
+
+    return "data:$mimeType;base64,$base64String"
+  }
+}
Index: app/src/main/java/com/android/bookswap/data/source/network/ImageToDataSource.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/source/network/ImageToDataSource.kt b/app/src/main/java/com/android/bookswap/data/source/network/ImageToDataSource.kt
new file mode 100644
--- /dev/null	(date 1731615667846)
+++ b/app/src/main/java/com/android/bookswap/data/source/network/ImageToDataSource.kt	(date 1731615667846)
@@ -0,0 +1,69 @@
+package com.android.bookswap.data.source.network
+
+import com.android.bookswap.R
+import com.android.bookswap.data.source.api.ApiService
+import org.json.JSONObject
+
+/**
+ * Class to send an image URL to ChatGPT API and parse the response for book information.
+ *
+ * @param apiService The API service to send the request
+ */
+class ImageToDataSource(private val apiService: ApiService) {
+  // The specific prompt for the image analysis
+  private val PROMPT = R.string.prompt
+
+  /**
+   * Function to send an image URL to ChatGPT API and parse the response for book information.
+   *
+   * @param imageUrl URL of the image to analyze
+   * @param onSuccess Callback for a successful response, returns structured book data
+   * @param onError Callback for handling errors
+   */
+  fun analyzeImage(
+      imageUrl: String,
+      onSuccess: (Map<String, String>) -> Unit,
+      onError: (String) -> Unit
+  ) {
+    // Complete the prompt by appending the image URL
+    val fullPrompt = "$PROMPT $imageUrl"
+
+    // Send the request to ChatGPTApiService
+    apiService.sendChatRequest(
+        userMessages = listOf(fullPrompt),
+        onSuccess = { responseContent ->
+          try {
+            // Parse the JSON response into a Map
+            val parsedData = parseResponse(responseContent)
+            onSuccess(parsedData)
+          } catch (e: Exception) {
+            onError("Parsing error: ${e.localizedMessage}")
+          }
+        },
+        onError = { error -> onError("API Request Error: $error") })
+  }
+
+  /**
+   * Parses the ChatGPT response JSON string into a map of book information.
+   *
+   * @param response JSON string returned by the ChatGPT API
+   * @return A map with keys: "title", "author", "description", "language", and "isbn"
+   */
+  private fun parseResponse(response: String): Map<String, String> {
+    val jsonObject = JSONObject(response)
+
+    // Extract the fields as specified
+    val title = jsonObject.optString("title", "N/A")
+    val author = jsonObject.optString("author", "N/A")
+    val description = jsonObject.optString("description", "N/A")
+    val language = jsonObject.optString("language", "N/A")
+    val isbn = jsonObject.optString("isbn", "N/A")
+
+    return mapOf(
+        "title" to title,
+        "author" to author,
+        "description" to description,
+        "language" to language,
+        "isbn" to isbn)
+  }
+}
Index: app/src/main/java/com/android/bookswap/data/source/api/ApiService.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/source/api/ApiService.kt b/app/src/main/java/com/android/bookswap/data/source/api/ApiService.kt
new file mode 100644
--- /dev/null	(date 1731615667845)
+++ b/app/src/main/java/com/android/bookswap/data/source/api/ApiService.kt	(date 1731615667845)
@@ -0,0 +1,18 @@
+package com.android.bookswap.data.source.api
+/*
+  This interface is used to send a chat request to the API
+*/
+interface ApiService {
+  /**
+   * Send a chat request to the API
+   *
+   * @param userMessages List of user messages to send
+   * @param onSuccess Callback for a successful response
+   * @param onError Callback for handling errors
+   */
+  fun sendChatRequest(
+      userMessages: List<String>,
+      onSuccess: (String) -> Unit,
+      onError: (String) -> Unit
+  )
+}
Index: app/src/main/java/com/android/bookswap/data/repository/PhotoRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/repository/PhotoRepository.kt b/app/src/main/java/com/android/bookswap/data/repository/PhotoRepository.kt
new file mode 100644
--- /dev/null	(date 1731617426314)
+++ b/app/src/main/java/com/android/bookswap/data/repository/PhotoRepository.kt	(date 1731617426314)
@@ -0,0 +1,51 @@
+package com.android.bookswap.data.repository
+
+import android.graphics.Bitmap
+import com.android.bookswap.data.DataPhoto
+import java.util.UUID
+
+interface PhotoRepository {
+  /** Generates a new unique id for a message */
+  fun getNewUUID(): UUID
+
+  /**
+   * Initialize the repository
+   *
+   * @param callback callback function that receives Result.success() when operation succeed of
+   *   Result.failure(exception) if error
+   */
+  fun init(callback: (Result<Unit>) -> Unit)
+
+  /**
+   * Fetches a specific photo from Firestore by UUID
+   *
+   * @param uuid the UUID of the photo to fetch
+   * @param callback callback function that receives Result.success(DataPhoto) when operation
+   *   succeed of Result.failure(exception) if error
+   */
+  fun getPhoto(uuid: UUID, callback: (Result<DataPhoto>) -> Unit)
+
+  /**
+   * Converts a Bitmap to a Base64 encoded string.
+   *
+   * @param bitmap the Bitmap to convert.
+   * @return the Base64 encoded string.
+   */
+  fun bitmapToBase64(bitmap: Bitmap): String
+
+  /**
+   * Converts a Base64 encoded string to a Bitmap.
+   *
+   * @param base64 the Base64 encoded string to convert.
+   * @return the Bitmap.
+   */
+  fun base64ToBitmap(base64: String): Bitmap
+
+  /**
+   * Uploads a photo to Firestore.
+   *
+   * @param dataPhoto the photo data to upload.
+   * @param callback callback function that receives Unit if success or an an exception if error.
+   */
+  fun addPhoto(dataPhoto: DataPhoto, callback: (Result<Unit>) -> Unit)
+}
Index: app/src/main/java/com/android/bookswap/data/DataPhoto.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/DataPhoto.kt b/app/src/main/java/com/android/bookswap/data/DataPhoto.kt
new file mode 100644
--- /dev/null	(date 1731615667844)
+++ b/app/src/main/java/com/android/bookswap/data/DataPhoto.kt	(date 1731615667844)
@@ -0,0 +1,10 @@
+package com.android.bookswap.data
+
+import java.util.UUID
+
+data class DataPhoto(
+    val uuid: UUID, // UUID,
+    val url: String,
+    val timestamp: Long,
+    val base64: String,
+)
