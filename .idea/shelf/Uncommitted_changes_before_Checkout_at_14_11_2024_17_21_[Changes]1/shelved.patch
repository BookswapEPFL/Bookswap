Index: app/src/main/java/com/android/bookswap/model/map/IGeolocation.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.model.map\n\nimport androidx.compose.runtime.MutableState\n\n/**\n * Interface for providing geolocation data, with basic location management functionality.\n *\n * Classes implementing this interface should provide access to the user's current latitude and\n * longitude, as well as functions to start and stop location updates.\n *\n * This interface allows different implementations for geolocation, facilitating testing by enabling\n * the use of mock or fake data sources.\n */\ninterface IGeolocation {\n  val latitude: MutableState<Double>\n  val longitude: MutableState<Double>\n\n  fun startLocationUpdates()\n\n  fun stopLocationUpdates()\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/map/IGeolocation.kt b/app/src/main/java/com/android/bookswap/model/map/IGeolocation.kt
--- a/app/src/main/java/com/android/bookswap/model/map/IGeolocation.kt	
+++ b/app/src/main/java/com/android/bookswap/model/map/IGeolocation.kt	
@@ -1,6 +1,6 @@
 package com.android.bookswap.model.map
 
-import androidx.compose.runtime.MutableState
+import kotlinx.coroutines.flow.MutableStateFlow
 
 /**
  * Interface for providing geolocation data, with basic location management functionality.
@@ -12,8 +12,8 @@
  * the use of mock or fake data sources.
  */
 interface IGeolocation {
-  val latitude: MutableState<Double>
-  val longitude: MutableState<Double>
+  val latitude: MutableStateFlow<Double>
+  val longitude: MutableStateFlow<Double>
 
   fun startLocationUpdates()
 
Index: app/src/main/java/com/android/bookswap/ui/authentication/SignIn.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.authentication\n\n// import com.android.bookswap.ui.navigation.NavigationActions\n// import com.android.bookswap.ui.navigation.TopLevelDestinations\nimport android.content.Intent\nimport android.util.Log\nimport android.widget.Toast\nimport androidx.activity.compose.ManagedActivityResultLauncher\nimport androidx.activity.compose.rememberLauncherForActivityResult\nimport androidx.activity.result.ActivityResult\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.compose.foundation.BorderStroke\nimport androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.platform.testTag\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport com.android.bookswap.R\nimport com.android.bookswap.ui.navigation.NavigationActions\nimport com.android.bookswap.ui.navigation.TopLevelDestinations\nimport com.android.bookswap.ui.theme.ColorVariable\nimport com.google.android.gms.auth.api.signin.GoogleSignIn\nimport com.google.android.gms.auth.api.signin.GoogleSignInOptions\nimport com.google.android.gms.common.api.ApiException\nimport com.google.firebase.Firebase\nimport com.google.firebase.auth.AuthResult\nimport com.google.firebase.auth.GoogleAuthProvider\nimport com.google.firebase.auth.auth\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.tasks.await\n\n@Composable\nfun SignInScreen(navigationActions: NavigationActions) { // Add this when navigation is\n  // implemented\n  val context = LocalContext.current\n\n  val launcher =\n      rememberFirebaseAuthLauncher(\n          onAuthComplete = { result ->\n            Log.d(\"SignInScreen\", \"User signed in: ${result.user?.displayName}\")\n            Toast.makeText(context, \"Login successful!\", Toast.LENGTH_LONG).show()\n            navigationActions.navigateTo(TopLevelDestinations.MAP)\n          },\n          onAuthError = {\n            Log.e(\"SignInScreen\", \"Failed to sign in: ${it.statusCode}\")\n            Toast.makeText(context, \"Login Failed!\", Toast.LENGTH_LONG).show()\n          })\n  val token = stringResource(R.string.default_web_client_id)\n\n  Scaffold(\n      modifier = Modifier.fillMaxSize().testTag(\"SignInScreen\"),\n      containerColor = ColorVariable.BackGround, // Set the background color\n      content = { padding ->\n        Column(\n            modifier = Modifier.fillMaxSize().padding(padding),\n            horizontalAlignment = Alignment.CenterHorizontally,\n            verticalArrangement = Arrangement.Center,\n        ) {\n          // App Logo Image\n          Image(\n              painter = painterResource(id = R.drawable.logo5), // Bookswap logo\n              contentDescription = \"App Logo\",\n              modifier = Modifier.size(250.dp))\n\n          Spacer(modifier = Modifier.height(50.dp))\n\n          // First part of the title:\n          Text(\n              modifier = Modifier.testTag(\"login_loginTitle1\"),\n              text = \"Welcome to\",\n              style =\n                  TextStyle(\n                      fontSize = 40.sp,\n                      lineHeight = 40.sp,\n                      // fontFamily = FontFamily(Font(R.font.roboto)),\n                      fontWeight = FontWeight(600),\n                      color = Color(108, 88, 76),\n                      letterSpacing = 0.4.sp,\n                      textAlign = TextAlign.Center))\n\n          Spacer(modifier = Modifier.height(5.dp))\n\n          // Second part of the logo:\n          Text(\n              modifier = Modifier.testTag(\"login_loginTitle2\"),\n              text = \"BookSwap\",\n              style =\n                  TextStyle(\n                      fontSize = 60.sp,\n                      lineHeight = 40.sp,\n                      // fontFamily = FontFamily(Font(R.font.roboto)),\n                      fontWeight = FontWeight(800),\n                      color = Color(108, 88, 76),\n                      letterSpacing = 0.6.sp,\n                      textAlign = TextAlign.Center))\n\n          Spacer(modifier = Modifier.height(50.dp))\n\n          // Authenticate With Google Button\n          GoogleSignInButton(\n              onSignInClick = {\n                val gso =\n                    GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)\n                        .requestIdToken(token)\n                        .requestEmail()\n                        .build()\n                val googleSignInClient = GoogleSignIn.getClient(context, gso)\n                launcher.launch(googleSignInClient.signInIntent)\n              })\n        }\n      })\n}\n\n@Composable\nfun GoogleSignInButton(onSignInClick: () -> Unit) {\n  Button(\n      onClick = onSignInClick,\n      colors =\n          ButtonDefaults.buttonColors(containerColor = ColorVariable.Secondary), // Button color\n      shape = RoundedCornerShape(50), // Circular edges for the button\n      border = BorderStroke(1.dp, ColorVariable.Primary), // Button's border color\n      modifier =\n          Modifier.padding(8.dp)\n              .height(48.dp) // Adjust height as needed\n              .testTag(\"loginButton\")) {\n        Row(\n            verticalAlignment = Alignment.CenterVertically,\n            horizontalArrangement = Arrangement.Center,\n            modifier = Modifier.fillMaxWidth()) {\n              // Google logo\n              Image(\n                  painter = painterResource(id = R.drawable.google_logo), // Google logo\n                  contentDescription = \"Google Logo\",\n                  modifier =\n                      Modifier.size(30.dp) // Size of the Google logo\n                          .padding(end = 8.dp))\n\n              // Text for the button\n              Text(\n                  text = \"Sign in with Google\",\n                  color = ColorVariable.Accent, // Text color\n                  fontSize = 16.sp, // Font size\n                  fontWeight = FontWeight.Medium)\n            }\n      }\n}\n\n@Composable\nfun rememberFirebaseAuthLauncher(\n    onAuthComplete: (AuthResult) -> Unit,\n    onAuthError: (ApiException) -> Unit\n): ManagedActivityResultLauncher<Intent, ActivityResult> {\n  val scope = rememberCoroutineScope()\n  return rememberLauncherForActivityResult(ActivityResultContracts.StartActivityForResult()) {\n      result ->\n    val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)\n    try {\n      val account = task.getResult(ApiException::class.java)!!\n      val credential = GoogleAuthProvider.getCredential(account.idToken!!, null)\n      scope.launch {\n        val authResult = Firebase.auth.signInWithCredential(credential).await()\n        onAuthComplete(authResult)\n      }\n    } catch (e: ApiException) {\n      onAuthError(e)\n    }\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/authentication/SignIn.kt b/app/src/main/java/com/android/bookswap/ui/authentication/SignIn.kt
--- a/app/src/main/java/com/android/bookswap/ui/authentication/SignIn.kt	
+++ b/app/src/main/java/com/android/bookswap/ui/authentication/SignIn.kt	
@@ -11,7 +11,15 @@
 import androidx.activity.result.contract.ActivityResultContracts
 import androidx.compose.foundation.BorderStroke
 import androidx.compose.foundation.Image
-import androidx.compose.foundation.layout.*
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
 import androidx.compose.foundation.shape.RoundedCornerShape
 import androidx.compose.material3.Button
 import androidx.compose.material3.ButtonDefaults
@@ -49,12 +57,17 @@
 fun SignInScreen(navigationActions: NavigationActions) { // Add this when navigation is
   // implemented
   val context = LocalContext.current
+  var googleUid = ""
 
   val launcher =
       rememberFirebaseAuthLauncher(
           onAuthComplete = { result ->
-            Log.d("SignInScreen", "User signed in: ${result.user?.displayName}")
-            Toast.makeText(context, "Login successful!", Toast.LENGTH_LONG).show()
+            val googleUserName = result.user?.displayName ?: ""
+            // TODO googleUserUid will be used for retrieving the corresponding DataUser
+            // will be done in another class.
+            googleUid = result.user?.uid ?: ""
+            Log.d("SignInScreen", "User signed in: $googleUserName")
+            Toast.makeText(context, "Welcome $googleUserName!", Toast.LENGTH_LONG).show()
             navigationActions.navigateTo(TopLevelDestinations.MAP)
           },
           onAuthError = {
Index: app/src/main/java/com/android/bookswap/data/DataMessage.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.data\n\ndata class DataMessage(\n    val id: String = \"\",\n    val text: String = \"\",\n    val senderId: String = \"\",\n    val receiverId: String = \"\",\n    val timestamp: Long = 0L\n)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/DataMessage.kt b/app/src/main/java/com/android/bookswap/data/DataMessage.kt
--- a/app/src/main/java/com/android/bookswap/data/DataMessage.kt	
+++ b/app/src/main/java/com/android/bookswap/data/DataMessage.kt	
@@ -1,9 +1,17 @@
 package com.android.bookswap.data
 
+import java.util.UUID
+
 data class DataMessage(
-    val id: String = "",
+    val messageType: MessageType = MessageType.TEXT,
+    val uuid: UUID = UUID.randomUUID(),
     val text: String = "",
-    val senderId: String = "",
-    val receiverId: String = "",
+    val senderUUID: UUID,
+    val receiverUUID: UUID,
     val timestamp: Long = 0L
 )
+
+enum class MessageType {
+  TEXT,
+  IMAGE
+}
Index: app/src/main/java/com/android/bookswap/ui/navigation/NavigationActions.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.navigation\n\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.MailOutline\nimport androidx.compose.material.icons.outlined.AccountCircle\nimport androidx.compose.material.icons.outlined.AddCircle\nimport androidx.compose.material.icons.outlined.Place\nimport androidx.compose.ui.graphics.vector.ImageVector\nimport androidx.navigation.NavGraph.Companion.findStartDestination\nimport androidx.navigation.NavHostController\n\nobject Route {\n  const val CHAT = \"Chat\"\n  const val PROFIL = \"Profil\"\n  const val MAP = \"Map\"\n  const val NEWBOOK = \"NewBook\"\n  const val AUTH = \"Auth\"\n}\n\nobject Screen {\n  const val AUTH = \"Auth Screen\"\n  const val CHATLIST = \"ChatList Screen\"\n  const val CHAT = \"Chat Screen\"\n  const val MAP = \"Map Screen\"\n  const val NEWBOOK = \"NewBook Screen\"\n  const val ADD_BOOK_MANUALLY = \"AddBookManually Screen\"\n  const val ADD_BOOK_SCAN = \"AddBookScan Screen\"\n  const val ADD_BOOK_ISBN = \"AddBookISBN Screen\"\n  const val SETTINGS = \"Settings Screen\"\n  const val FILTER = \"Filter Screen\"\n}\n\ndata class TopLevelDestination(val route: String, val icon: ImageVector, val textId: String)\n\nobject TopLevelDestinations {\n  val CHAT =\n      TopLevelDestination(route = Route.CHAT, icon = Icons.Filled.MailOutline, textId = \"Chat\")\n  val MAP = TopLevelDestination(route = Route.MAP, icon = Icons.Outlined.Place, textId = \"Map\")\n  val NEW_BOOK =\n      TopLevelDestination(\n          route = Route.NEWBOOK, icon = Icons.Outlined.AddCircle, textId = \"New Book\")\n  val PROFILE =\n      TopLevelDestination(\n          route = Route.PROFIL, icon = Icons.Outlined.AccountCircle, textId = \"Profile\")\n}\n/** List of top level destinations that are shown in the bottom navigation bar */\nval List_Navigation_Bar_Destinations =\n    listOf(TopLevelDestinations.CHAT, TopLevelDestinations.NEW_BOOK, TopLevelDestinations.MAP)\n\nopen class NavigationActions(\n    private val navController: NavHostController,\n) {\n  /**\n   * Navigate to the specified [TopLevelDestination]\n   *\n   * @param destination The top level destination to navigate to Clear the back stack when\n   *   navigating to a new destination This is useful when navigating to a new screen from the\n   *   bottom navigation bar as we don't want to keep the previous screen in the back stack\n   */\n  open fun navigateTo(destination: TopLevelDestination) {\n\n    navController.navigate(destination.route) {\n      // Pop up to the start destination of the graph to\n      // avoid building up a large stack of destinations\n      popUpTo(navController.graph.findStartDestination().id) {\n        saveState = true\n        inclusive = true\n      }\n\n      // Avoid multiple copies of the same destination when reelecting same item\n      launchSingleTop = true\n\n      // Restore state when reelecting a previously selected item\n      if (destination.route != Route.AUTH) {\n        restoreState = true\n      }\n    }\n  }\n\n  /**\n   * Navigate to the specified screen with optional parameters.\n   *\n   * @param screen The screen to navigate to\n   * @param user1 The first user parameter\n   * @param user2 The second user parameter\n   */\n  open fun navigateTo(screen: String, user1: String? = null, user2: String? = null) {\n    val route =\n        when (screen) {\n          Screen.CHAT -> \"$screen/$user1/$user2\"\n          else -> screen\n        }\n    navController.navigate(route)\n  }\n\n  /**\n   * Navigate to the specified screen.\n   *\n   * @param screen The screen to navigate to\n   */\n  open fun navigateTo(screen: String) {\n    navController.navigate(screen)\n  }\n\n  /** Navigate back to the previous screen. */\n  open fun goBack() {\n    navController.popBackStack()\n  }\n\n  /**\n   * Get the current route of the navigation controller.\n   *\n   * @return The current route\n   */\n  open fun currentRoute(): String {\n    return navController.currentDestination?.route ?: \"\"\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/navigation/NavigationActions.kt b/app/src/main/java/com/android/bookswap/ui/navigation/NavigationActions.kt
--- a/app/src/main/java/com/android/bookswap/ui/navigation/NavigationActions.kt	
+++ b/app/src/main/java/com/android/bookswap/ui/navigation/NavigationActions.kt	
@@ -11,7 +11,7 @@
 
 object Route {
   const val CHAT = "Chat"
-  const val PROFIL = "Profil"
+  const val PROFILE = "Profile"
   const val MAP = "Map"
   const val NEWBOOK = "NewBook"
   const val AUTH = "Auth"
@@ -28,6 +28,7 @@
   const val ADD_BOOK_ISBN = "AddBookISBN Screen"
   const val SETTINGS = "Settings Screen"
   const val FILTER = "Filter Screen"
+  const val PROFILE = "Profile Screen"
 }
 
 data class TopLevelDestination(val route: String, val icon: ImageVector, val textId: String)
@@ -41,7 +42,7 @@
           route = Route.NEWBOOK, icon = Icons.Outlined.AddCircle, textId = "New Book")
   val PROFILE =
       TopLevelDestination(
-          route = Route.PROFIL, icon = Icons.Outlined.AccountCircle, textId = "Profile")
+          route = Route.PROFILE, icon = Icons.Outlined.AccountCircle, textId = "Profile")
 }
 /** List of top level destinations that are shown in the bottom navigation bar */
 val List_Navigation_Bar_Destinations =
@@ -81,15 +82,11 @@
    * Navigate to the specified screen with optional parameters.
    *
    * @param screen The screen to navigate to
-   * @param user1 The first user parameter
-   * @param user2 The second user parameter
+   * @param user1 The first user to pass to the screen
+   * @param user2 The second user to pass to the screen
    */
-  open fun navigateTo(screen: String, user1: String? = null, user2: String? = null) {
-    val route =
-        when (screen) {
-          Screen.CHAT -> "$screen/$user1/$user2"
-          else -> screen
-        }
+  open fun navigateTo(screen: String, otherUserUUID: String) {
+    val route = "$screen/$otherUserUUID"
     navController.navigate(route)
   }
 
Index: app/src/main/java/com/android/bookswap/model/map/Geolocation.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.model.map\n\nimport android.Manifest\nimport android.annotation.SuppressLint\nimport android.app.Activity\nimport android.content.pm.PackageManager\nimport android.os.Build\nimport android.os.Looper\nimport androidx.annotation.RequiresApi\nimport androidx.compose.runtime.mutableDoubleStateOf\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.core.app.ActivityCompat\nimport com.google.android.gms.location.FusedLocationProviderClient\nimport com.google.android.gms.location.LocationCallback\nimport com.google.android.gms.location.LocationRequest\nimport com.google.android.gms.location.LocationResult\nimport com.google.android.gms.location.LocationServices\n\nconst val REQUEST_LOCATION_PERMISSION = 1\nconst val BACKGROUND_LOCATION_PERMISSION_REQUEST_CODE = 2\n\n/**\n * Geolocation class manages the geolocation functionality and handles the required permissions for\n * accessing location data.\n * - To start receiving location updates, call startLocationUpdates().\n * - To stop receiving updates, call stopLocationUpdates().\n * - The current user's location can be checked using the latitude and longitude variables.\n * - The current state of location updates can be checked using the isRunning variable.\n *\n * This class requires appropriate location permissions to function, including both foreground and\n * optionally background location access.\n */\nclass Geolocation(private val activity: Activity) : IGeolocation {\n  private val fusedLocationClient: FusedLocationProviderClient =\n      LocationServices.getFusedLocationProviderClient(activity)\n  val isRunning = mutableStateOf(false)\n  override val latitude = mutableDoubleStateOf(Double.NaN)\n  override val longitude = mutableDoubleStateOf(Double.NaN)\n\n  /** Location request settings */\n  private val locationRequest: LocationRequest =\n      LocationRequest.create().apply {\n        interval = 10000 // Update interval in milliseconds\n        fastestInterval = 5000 // Fastest update interval in milliseconds\n        priority = LocationRequest.PRIORITY_HIGH_ACCURACY\n      }\n\n  private val locationCallback =\n      object : LocationCallback() {\n        override fun onLocationResult(p0: LocationResult) {\n          p0.lastLocation.let { location ->\n            // Handle the updated location here\n            latitude.doubleValue = location.latitude\n            longitude.doubleValue = location.longitude\n            // You can save this location or notify other parts of your app\n          }\n        }\n      }\n\n  /** Request location permissions */\n  private fun requestLocationPermissions() {\n    val permissions =\n        arrayOf(\n            Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION)\n    ActivityCompat.requestPermissions(activity, permissions, REQUEST_LOCATION_PERMISSION)\n  }\n\n  /** Check if permissions are granted */\n  private fun hasLocationPermissions(): Boolean {\n    return ActivityCompat.checkSelfPermission(activity, Manifest.permission.ACCESS_FINE_LOCATION) ==\n        PackageManager.PERMISSION_GRANTED &&\n        ActivityCompat.checkSelfPermission(activity, Manifest.permission.ACCESS_COARSE_LOCATION) ==\n            PackageManager.PERMISSION_GRANTED\n  }\n\n  @RequiresApi(Build.VERSION_CODES.Q)\n  private fun requestBackgroundPermissions() {\n    val permissions = arrayOf(Manifest.permission.ACCESS_BACKGROUND_LOCATION)\n    ActivityCompat.requestPermissions(\n        activity, permissions, BACKGROUND_LOCATION_PERMISSION_REQUEST_CODE)\n  }\n\n  @RequiresApi(Build.VERSION_CODES.Q)\n  private fun hasBackgroundPermissions(): Boolean {\n    return ActivityCompat.checkSelfPermission(\n        activity, Manifest.permission.ACCESS_BACKGROUND_LOCATION) ==\n        PackageManager.PERMISSION_GRANTED\n  }\n\n  /** Start location updates */\n  @SuppressLint(\"MissingPermission\")\n  override fun startLocationUpdates() {\n    if (!isRunning.value) {\n      if (hasLocationPermissions()) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && !hasBackgroundPermissions()) {\n          requestBackgroundPermissions()\n        }\n        // can run without ACCESS_BACKGROUND_LOCATION but it is better if we have the permission\n        fusedLocationClient.requestLocationUpdates(\n            locationRequest, locationCallback, Looper.getMainLooper())\n        isRunning.value = true\n      } else {\n        requestLocationPermissions()\n        // need to check here for the permission, as otherwise the startLocationUpdates would just\n        // loop indefinitely if the user refuse to give the permission\n        if (hasLocationPermissions()) {\n          startLocationUpdates()\n        }\n      }\n    }\n  }\n\n  /** Stop location updates */\n  override fun stopLocationUpdates() {\n    fusedLocationClient.removeLocationUpdates(locationCallback)\n    isRunning.value = false\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/map/Geolocation.kt b/app/src/main/java/com/android/bookswap/model/map/Geolocation.kt
--- a/app/src/main/java/com/android/bookswap/model/map/Geolocation.kt	
+++ b/app/src/main/java/com/android/bookswap/model/map/Geolocation.kt	
@@ -7,7 +7,6 @@
 import android.os.Build
 import android.os.Looper
 import androidx.annotation.RequiresApi
-import androidx.compose.runtime.mutableDoubleStateOf
 import androidx.compose.runtime.mutableStateOf
 import androidx.core.app.ActivityCompat
 import com.google.android.gms.location.FusedLocationProviderClient
@@ -15,6 +14,7 @@
 import com.google.android.gms.location.LocationRequest
 import com.google.android.gms.location.LocationResult
 import com.google.android.gms.location.LocationServices
+import kotlinx.coroutines.flow.MutableStateFlow
 
 const val REQUEST_LOCATION_PERMISSION = 1
 const val BACKGROUND_LOCATION_PERMISSION_REQUEST_CODE = 2
@@ -34,8 +34,8 @@
   private val fusedLocationClient: FusedLocationProviderClient =
       LocationServices.getFusedLocationProviderClient(activity)
   val isRunning = mutableStateOf(false)
-  override val latitude = mutableDoubleStateOf(Double.NaN)
-  override val longitude = mutableDoubleStateOf(Double.NaN)
+  override val latitude = MutableStateFlow(Double.NaN)
+  override val longitude = MutableStateFlow(Double.NaN)
 
   /** Location request settings */
   private val locationRequest: LocationRequest =
@@ -50,8 +50,8 @@
         override fun onLocationResult(p0: LocationResult) {
           p0.lastLocation.let { location ->
             // Handle the updated location here
-            latitude.doubleValue = location.latitude
-            longitude.doubleValue = location.longitude
+            latitude.value = location.latitude
+            longitude.value = location.longitude
             // You can save this location or notify other parts of your app
           }
         }
Index: app/src/main/java/com/android/bookswap/data/source/network/MessageFirestoreSource.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.data.source.network\n\nimport android.content.Context\nimport android.util.Log\nimport android.widget.Toast\nimport com.android.bookswap.data.DataMessage\nimport com.android.bookswap.data.repository.MessageRepository\nimport com.google.firebase.firestore.DocumentSnapshot\nimport com.google.firebase.firestore.FirebaseFirestore\nimport com.google.firebase.firestore.ListenerRegistration\n\nconst val COLLECTION_PATH = \"messages\"\n\nclass MessageFirestoreSource(private val db: FirebaseFirestore) : MessageRepository {\n\n  override fun getNewUid(): String {\n    return db.collection(COLLECTION_PATH).document().id\n  }\n\n  override fun init(callback: (Result<Unit>) -> Unit) {\n    try {\n      callback(Result.success(Unit))\n    } catch (e: Exception) {\n      Log.e(\"MessageSource\", \"Initialization failed: ${e.message}\")\n      callback(Result.failure(e))\n    }\n  }\n\n  override fun getMessages(callback: (Result<List<DataMessage>>) -> Unit) {\n    db.collection(COLLECTION_PATH).get().addOnCompleteListener { task ->\n      if (task.isSuccessful) {\n        val documents = task.result?.documents\n        if (documents != null && documents.isNotEmpty()) {\n          val messages = documents.mapNotNull { documentToMessage(it).getOrNull() }\n          callback(Result.success(messages))\n        } else {\n          callback(Result.success(emptyList()))\n        }\n      } else {\n        callback(Result.failure(task.exception ?: Exception(\"Unknown error fetching messages\")))\n      }\n    }\n  }\n\n  override fun sendMessage(message: DataMessage, callback: (Result<Unit>) -> Unit) {\n    val messageMap =\n        mapOf(\n            \"id\" to message.id,\n            \"text\" to message.text,\n            \"senderId\" to message.senderId,\n            \"receiverId\" to message.receiverId,\n            \"timestamp\" to message.timestamp)\n\n    db.collection(COLLECTION_PATH).document(message.id).set(messageMap).addOnCompleteListener {\n        result ->\n      if (result.isSuccessful) {\n        callback(Result.success(Unit))\n      } else {\n        callback(Result.failure(result.exception ?: Exception(\"Unknown error sending message\")))\n      }\n    }\n  }\n\n  override fun deleteMessage(\n      messageId: String,\n      callback: (Result<Unit>) -> Unit,\n      context: Context\n  ) {\n    val fifteenMinutesInMillis = 15 * 60 * 1000\n    val currentTime = System.currentTimeMillis()\n\n    db.collection(COLLECTION_PATH).document(messageId).get().addOnCompleteListener { task ->\n      if (task.isSuccessful) {\n        val document = task.result\n        if (document != null && document.exists()) {\n          val existingMessage = documentToMessage(document).getOrNull()\n          if (existingMessage != null) {\n            if (currentTime - existingMessage.timestamp <= fifteenMinutesInMillis) {\n              db.collection(COLLECTION_PATH).document(messageId).delete().addOnCompleteListener {\n                  deleteTask ->\n                if (deleteTask.isSuccessful) {\n                  callback(Result.success(Unit))\n                } else {\n                  callback(\n                      Result.failure(\n                          deleteTask.exception ?: Exception(\"Unknown error deleting message\")))\n                }\n              }\n            } else {\n              Toast.makeText(\n                      context,\n                      \"Message can only be deleted within 15 minutes of being sent\",\n                      Toast.LENGTH_LONG)\n                  .show()\n              callback(\n                  Result.failure(\n                      Exception(\"Message can only be deleted within 15 minutes of being sent\")))\n            }\n          } else {\n            callback(Result.failure(Exception(\"Message not found\")))\n          }\n        } else {\n          callback(Result.failure(Exception(\"Message not found\")))\n        }\n      } else {\n        callback(Result.failure(task.exception ?: Exception(\"Unknown error fetching message\")))\n      }\n    }\n  }\n\n  override fun deleteAllMessages(\n      user1Id: String,\n      user2Id: String,\n      callback: (Result<Unit>) -> Unit\n  ) {\n    db.collection(COLLECTION_PATH)\n        .whereIn(\"senderId\", listOf(user1Id, user2Id))\n        .whereIn(\"receiverId\", listOf(user1Id, user2Id))\n        .whereNotEqualTo(\"senderId\", \"receiverId\")\n        .get()\n        .addOnCompleteListener { task ->\n          if (task.isSuccessful) {\n            val documents = task.result\n            if (documents != null && !documents.isEmpty) {\n              val batch = db.batch()\n              documents.documents.forEach { document -> batch.delete(document.reference) }\n              batch.commit().addOnCompleteListener { deleteTask ->\n                if (deleteTask.isSuccessful) {\n                  callback(Result.success(Unit))\n                } else {\n                  callback(\n                      Result.failure(\n                          deleteTask.exception ?: Exception(\"Unknown error deleting messages\")))\n                }\n              }\n            } else {\n              callback(Result.success(Unit))\n            }\n          } else {\n            callback(Result.failure(task.exception ?: Exception(\"Unknown error fetching messages\")))\n          }\n        }\n  }\n\n  override fun updateMessage(\n      message: DataMessage,\n      callback: (Result<Unit>) -> Unit,\n      context: Context\n  ) {\n    val fifteenMinutesInMillis = 15 * 60 * 1000\n    val currentTime = System.currentTimeMillis()\n\n    db.collection(COLLECTION_PATH).document(message.id).get().addOnCompleteListener { task ->\n      if (task.isSuccessful) {\n        val document = task.result\n        if (document != null && document.exists()) {\n          val existingMessage = documentToMessage(document).getOrNull()\n          if (existingMessage != null) {\n            if (currentTime - existingMessage.timestamp <= fifteenMinutesInMillis) {\n              val messageMap =\n                  mapOf(\n                      \"text\" to message.text,\n                      \"timestamp\" to currentTime // Update the timestamp to the current time\n                      )\n              db.collection(COLLECTION_PATH)\n                  .document(message.id)\n                  .update(messageMap)\n                  .addOnCompleteListener { updateTask ->\n                    if (updateTask.isSuccessful) {\n                      callback(Result.success(Unit))\n                    } else {\n                      callback(\n                          Result.failure(\n                              updateTask.exception ?: Exception(\"Unknown error updating message\")))\n                    }\n                  }\n            } else {\n              Toast.makeText(\n                      context,\n                      \"Message can only be updated within 15 minutes of being sent\",\n                      Toast.LENGTH_LONG)\n                  .show()\n              callback(\n                  Result.failure(\n                      Exception(\"Message can only be updated within 15 minutes of being sent\")))\n            }\n          } else {\n            callback(Result.failure(Exception(\"Message not found\")))\n          }\n        } else {\n          callback(Result.failure(Exception(\"Message not found\")))\n        }\n      } else {\n        callback(Result.failure(task.exception ?: Exception(\"Unknown error fetching message\")))\n      }\n    }\n  }\n\n  override fun addMessagesListener(\n      otherUserId: String,\n      currentUserId: String,\n      callback: (Result<List<DataMessage>>) -> Unit\n  ): ListenerRegistration {\n    return db.collection(\"messages\")\n        .whereIn(\"senderId\", listOf(currentUserId, otherUserId))\n        .whereIn(\"receiverId\", listOf(currentUserId, otherUserId))\n        .whereNotEqualTo(\"senderId\", \"receiverId\")\n        .addSnapshotListener { snapshot, e ->\n          if (e != null) {\n            callback(Result.failure(e))\n            return@addSnapshotListener\n          }\n\n          if (snapshot != null && !snapshot.isEmpty) {\n            val messages =\n                snapshot.documents\n                    .mapNotNull { document ->\n                      try {\n                        document.toObject(DataMessage::class.java)\n                      } catch (ex: Exception) {\n                        Log.e(\n                            \"MessageSource\", \"Error converting document to Message: ${ex.message}\")\n                        null\n                      }\n                    }\n                    .sortedBy { it.timestamp } // Sort messages by timestamp\n            callback(Result.success(messages))\n          } else {\n            callback(Result.success(emptyList()))\n          }\n        }\n  }\n}\n\nfun documentToMessage(document: DocumentSnapshot): Result<DataMessage> {\n  return try {\n    val id = document.getString(\"id\")!!\n    val text = document.getString(\"text\")!!\n    val senderId = document.getString(\"senderId\")!!\n    val receiverId = document.getString(\"receiverId\")!!\n    val timestamp = document.getLong(\"timestamp\")!!\n    Result.success(DataMessage(id, text, senderId, receiverId, timestamp))\n  } catch (e: Exception) {\n    Log.e(\"MessageSource\", \"Error converting document to Message: ${e.message}\")\n    Result.failure(e)\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/source/network/MessageFirestoreSource.kt b/app/src/main/java/com/android/bookswap/data/source/network/MessageFirestoreSource.kt
--- a/app/src/main/java/com/android/bookswap/data/source/network/MessageFirestoreSource.kt	
+++ b/app/src/main/java/com/android/bookswap/data/source/network/MessageFirestoreSource.kt	
@@ -4,17 +4,18 @@
 import android.util.Log
 import android.widget.Toast
 import com.android.bookswap.data.DataMessage
+import com.android.bookswap.data.MessageType
 import com.android.bookswap.data.repository.MessageRepository
 import com.google.firebase.firestore.DocumentSnapshot
 import com.google.firebase.firestore.FirebaseFirestore
 import com.google.firebase.firestore.ListenerRegistration
+import java.util.UUID
 
 const val COLLECTION_PATH = "messages"
 
 class MessageFirestoreSource(private val db: FirebaseFirestore) : MessageRepository {
-
-  override fun getNewUid(): String {
-    return db.collection(COLLECTION_PATH).document().id
+  override fun getNewUUID(): UUID {
+    return UUID.randomUUID()
   }
 
   override fun init(callback: (Result<Unit>) -> Unit) {
@@ -30,7 +31,7 @@
     db.collection(COLLECTION_PATH).get().addOnCompleteListener { task ->
       if (task.isSuccessful) {
         val documents = task.result?.documents
-        if (documents != null && documents.isNotEmpty()) {
+        if (!documents.isNullOrEmpty()) {
           val messages = documents.mapNotNull { documentToMessage(it).getOrNull() }
           callback(Result.success(messages))
         } else {
@@ -45,47 +46,53 @@
   override fun sendMessage(message: DataMessage, callback: (Result<Unit>) -> Unit) {
     val messageMap =
         mapOf(
-            "id" to message.id,
+            "uuid" to message.uuid.toString(),
             "text" to message.text,
-            "senderId" to message.senderId,
-            "receiverId" to message.receiverId,
-            "timestamp" to message.timestamp)
+            "senderUUID" to message.senderUUID.toString(),
+            "receiverUUID" to message.receiverUUID.toString(),
+            "timestamp" to message.timestamp,
+            "messageType" to message.messageType.name)
 
-    db.collection(COLLECTION_PATH).document(message.id).set(messageMap).addOnCompleteListener {
-        result ->
-      if (result.isSuccessful) {
-        callback(Result.success(Unit))
-      } else {
-        callback(Result.failure(result.exception ?: Exception("Unknown error sending message")))
-      }
-    }
+    db.collection(COLLECTION_PATH)
+        .document(message.uuid.toString())
+        .set(messageMap)
+        .addOnCompleteListener { result ->
+          if (result.isSuccessful) {
+            callback(Result.success(Unit))
+          } else {
+            callback(Result.failure(result.exception ?: Exception("Unknown error sending message")))
+          }
+        }
   }
 
   override fun deleteMessage(
-      messageId: String,
+      messageUUID: UUID,
       callback: (Result<Unit>) -> Unit,
       context: Context
   ) {
     val fifteenMinutesInMillis = 15 * 60 * 1000
     val currentTime = System.currentTimeMillis()
 
-    db.collection(COLLECTION_PATH).document(messageId).get().addOnCompleteListener { task ->
+    db.collection(COLLECTION_PATH).document(messageUUID.toString()).get().addOnCompleteListener {
+        task ->
       if (task.isSuccessful) {
         val document = task.result
         if (document != null && document.exists()) {
           val existingMessage = documentToMessage(document).getOrNull()
           if (existingMessage != null) {
             if (currentTime - existingMessage.timestamp <= fifteenMinutesInMillis) {
-              db.collection(COLLECTION_PATH).document(messageId).delete().addOnCompleteListener {
-                  deleteTask ->
-                if (deleteTask.isSuccessful) {
-                  callback(Result.success(Unit))
-                } else {
-                  callback(
-                      Result.failure(
-                          deleteTask.exception ?: Exception("Unknown error deleting message")))
-                }
-              }
+              db.collection(COLLECTION_PATH)
+                  .document(messageUUID.toString())
+                  .delete()
+                  .addOnCompleteListener { deleteTask ->
+                    if (deleteTask.isSuccessful) {
+                      callback(Result.success(Unit))
+                    } else {
+                      callback(
+                          Result.failure(
+                              deleteTask.exception ?: Exception("Unknown error deleting message")))
+                    }
+                  }
             } else {
               Toast.makeText(
                       context,
@@ -109,14 +116,14 @@
   }
 
   override fun deleteAllMessages(
-      user1Id: String,
-      user2Id: String,
+      user1UUID: UUID,
+      user2UUID: UUID,
       callback: (Result<Unit>) -> Unit
   ) {
     db.collection(COLLECTION_PATH)
-        .whereIn("senderId", listOf(user1Id, user2Id))
-        .whereIn("receiverId", listOf(user1Id, user2Id))
-        .whereNotEqualTo("senderId", "receiverId")
+        .whereIn("senderUUID", listOf(user1UUID, user2UUID))
+        .whereIn("receiverUUID", listOf(user1UUID, user2UUID))
+        .whereNotEqualTo("senderUUID", "receiverUUID")
         .get()
         .addOnCompleteListener { task ->
           if (task.isSuccessful) {
@@ -150,7 +157,8 @@
     val fifteenMinutesInMillis = 15 * 60 * 1000
     val currentTime = System.currentTimeMillis()
 
-    db.collection(COLLECTION_PATH).document(message.id).get().addOnCompleteListener { task ->
+    db.collection(COLLECTION_PATH).document(message.uuid.toString()).get().addOnCompleteListener {
+        task ->
       if (task.isSuccessful) {
         val document = task.result
         if (document != null && document.exists()) {
@@ -160,10 +168,10 @@
               val messageMap =
                   mapOf(
                       "text" to message.text,
-                      "timestamp" to currentTime // Update the timestamp to the current time
-                      )
+                      "timestamp" to currentTime,
+                      "messageType" to message.messageType.name)
               db.collection(COLLECTION_PATH)
-                  .document(message.id)
+                  .document(message.uuid.toString())
                   .update(messageMap)
                   .addOnCompleteListener { updateTask ->
                     if (updateTask.isSuccessful) {
@@ -197,13 +205,13 @@
   }
 
   override fun addMessagesListener(
-      otherUserId: String,
-      currentUserId: String,
+      otherUserUUID: UUID,
+      currentUserUUID: UUID,
       callback: (Result<List<DataMessage>>) -> Unit
   ): ListenerRegistration {
     return db.collection("messages")
-        .whereIn("senderId", listOf(currentUserId, otherUserId))
-        .whereIn("receiverId", listOf(currentUserId, otherUserId))
+        .whereIn("senderId", listOf(currentUserUUID, otherUserUUID))
+        .whereIn("receiverId", listOf(currentUserUUID, otherUserUUID))
         .whereNotEqualTo("senderId", "receiverId")
         .addSnapshotListener { snapshot, e ->
           if (e != null) {
@@ -234,12 +242,13 @@
 
 fun documentToMessage(document: DocumentSnapshot): Result<DataMessage> {
   return try {
-    val id = document.getString("id")!!
+    val type = MessageType.valueOf(document.getString("messageType")!!)
+    val uuid = UUID.fromString(document.getString("uuid")!!)
     val text = document.getString("text")!!
-    val senderId = document.getString("senderId")!!
-    val receiverId = document.getString("receiverId")!!
+    val senderUUID = UUID.fromString(document.getString("senderUUID")!!)
+    val receiverUUID = UUID.fromString(document.getString("receiverUUID")!!)
     val timestamp = document.getLong("timestamp")!!
-    Result.success(DataMessage(id, text, senderId, receiverId, timestamp))
+    Result.success(DataMessage(type, uuid, text, senderUUID, receiverUUID, timestamp))
   } catch (e: Exception) {
     Log.e("MessageSource", "Error converting document to Message: ${e.message}")
     Result.failure(e)
Index: app/src/main/java/com/android/bookswap/data/source/network/BookFirestoreSource.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.data.source.network\n\nimport com.android.bookswap.data.BookGenres\nimport com.android.bookswap.data.BookLanguages\nimport com.android.bookswap.data.DataBook\nimport com.android.bookswap.data.repository.BooksRepository\nimport com.google.android.gms.tasks.Task\nimport com.google.firebase.Firebase\nimport com.google.firebase.auth.auth\nimport com.google.firebase.firestore.DocumentSnapshot\nimport com.google.firebase.firestore.FirebaseFirestore\nimport java.util.UUID\n\n// A class that implements the BooksRepository interface using Firebase Firestore as the data source\nclass BooksFirestoreRepository(private val db: FirebaseFirestore) : BooksRepository {\n\n  // Name of the Firestore collection that stores books\n  private val collectionBooks = \"Books\"\n\n  // Initializes the repository by adding an auth state listener to Firebase Authentication\n  // If the user is authenticated, it triggers the OnSuccess callback\n  override fun init(OnSucess: () -> Unit) {\n    Firebase.auth.addAuthStateListener {\n      if (it.currentUser != null) {\n        OnSucess()\n      }\n    }\n  }\n  // Generates and returns a new unique document ID for a book in Firestore\n  override fun getNewUid(): UUID {\n    return UUID.fromString(db.collection(collectionBooks).document().id)\n  }\n  // Fetches the list of books from the Firestore collection\n  // If the task is successful, maps the Firestore documents to DataBook objects\n  // Calls OnSuccess with the list of books, or onFailure if the task fails\n  override fun getBook(OnSucess: (List<DataBook>) -> Unit, onFailure: (Exception) -> Unit) {\n    db.collection(collectionBooks).get().addOnCompleteListener { task ->\n      if (task.isSuccessful) {\n        // Maps Firestore documents to DataBook objects or returns an empty list\n        val books = task.result?.mapNotNull { document -> documentToBooks(document) } ?: emptyList()\n        OnSucess(books)\n      } else {\n        task.exception?.let { e -> onFailure(e) }\n      }\n    }\n  }\n  // Adds a new book to the Firestore collection\n  // Calls OnSuccess if the operation is successful, otherwise onFailure with the exception\n  override fun addBook(dataBook: DataBook, OnSucess: () -> Unit, onFailure: (Exception) -> Unit) {\n    performFirestoreOperation(\n        db.collection(collectionBooks).document(dataBook.title).set(dataBook), OnSucess, onFailure)\n  }\n  // Updates an existing book in Firestore by replacing the document with the same title\n  // Uses performFirestoreOperation to handle success and failure\n  override fun updateBook(\n      dataBook: DataBook,\n      OnSucess: () -> Unit,\n      onFailure: (Exception) -> Unit\n  ) {\n    performFirestoreOperation(\n        db.collection(collectionBooks).document(dataBook.title).set(dataBook), OnSucess, onFailure)\n  }\n  // Deletes a book from Firestore by its title\n  // Uses performFirestoreOperation to handle success and failure\n  override fun deleteBooks(\n      id: String,\n      dataBook: DataBook,\n      OnSucess: () -> Unit,\n      onFailure: (Exception) -> Unit\n  ) {\n    performFirestoreOperation(\n        db.collection(collectionBooks).document(dataBook.isbn!!).delete(), OnSucess, onFailure)\n  }\n  // Maps a Firestore document to a DataBook object\n  // If any required field is missing, returns null to avoid incomplete objects\n  fun documentToBooks(document: DocumentSnapshot): DataBook? {\n    return try {\n      val title = document.getString(\"Title\") ?: return null\n      val author = document.getString(\"Author\") ?: return null\n      val description = document.getString(\"Description\") ?: return null\n      val rating = document.getString(\"Rating\") ?: return null\n      val photo = document.getString(\"Photo\") ?: return null\n      val isbn = document.getString(\"ISBN\") ?: return null\n      val languageBook = BookLanguages.valueOf(document.getString(\"Language\") ?: return null)\n      val genres = document.get(\"genres\") as? List<String> ?: emptyList()\n      val bookGenres =\n          genres.mapNotNull { genre ->\n            try {\n              BookGenres.valueOf(genre)\n            } catch (e: IllegalArgumentException) {\n              null\n            }\n          }\n      DataBook(\n          UUID.randomUUID(),\n          title,\n          author,\n          description,\n          rating.toInt(),\n          photo,\n          languageBook,\n          isbn,\n          bookGenres)\n    } catch (e: Exception) {\n      null // Return null in case of any exception during the conversion\n    }\n  }\n  // Helper function to perform Firestore operations (add, update, delete)\n  // Executes the provided Firestore task and triggers success or failure callbacks\n  private fun performFirestoreOperation(\n      task: Task<Void>,\n      OnSucess: () -> Unit,\n      OnFailure: (Exception) -> Unit\n  ) {\n    task.addOnCompleteListener { result ->\n      if (result.isSuccessful) {\n        OnSucess()\n      } else {\n        result.exception?.let { e -> OnFailure(e) }\n      }\n    }\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/source/network/BookFirestoreSource.kt b/app/src/main/java/com/android/bookswap/data/source/network/BookFirestoreSource.kt
--- a/app/src/main/java/com/android/bookswap/data/source/network/BookFirestoreSource.kt	
+++ b/app/src/main/java/com/android/bookswap/data/source/network/BookFirestoreSource.kt	
@@ -1,5 +1,6 @@
 package com.android.bookswap.data.source.network
 
+import android.util.Log
 import com.android.bookswap.data.BookGenres
 import com.android.bookswap.data.BookLanguages
 import com.android.bookswap.data.DataBook
@@ -10,78 +11,96 @@
 import com.google.firebase.firestore.DocumentSnapshot
 import com.google.firebase.firestore.FirebaseFirestore
 import java.util.UUID
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.flow.asStateFlow
 
 // A class that implements the BooksRepository interface using Firebase Firestore as the data source
-class BooksFirestoreRepository(private val db: FirebaseFirestore) : BooksRepository {
+class BooksFirestoreSource(private val db: FirebaseFirestore) : BooksRepository {
 
   // Name of the Firestore collection that stores books
   private val collectionBooks = "Books"
 
-  // Initializes the repository by adding an auth state listener to Firebase Authentication
-  // If the user is authenticated, it triggers the OnSuccess callback
-  override fun init(OnSucess: () -> Unit) {
+  private val books_ = MutableStateFlow<List<DataBook>>(emptyList())
+  val books: StateFlow<List<DataBook>> = books_.asStateFlow()
+
+  // Selected todo, i.e the todo for the detail view
+  private val selectedBook_ = MutableStateFlow<DataBook?>(null)
+  val selectedBook: StateFlow<DataBook?> = selectedBook_.asStateFlow()
+  // Use this code in editBookScreen and modify the editBookScreen structure if needed when
+  // incorporating in the app navigation
+
+  override fun init(onSuccess: () -> Unit) {
     Firebase.auth.addAuthStateListener {
       if (it.currentUser != null) {
-        OnSucess()
+        onSuccess()
       }
     }
   }
-  // Generates and returns a new unique document ID for a book in Firestore
-  override fun getNewUid(): UUID {
-    return UUID.fromString(db.collection(collectionBooks).document().id)
+
+  override fun getNewUUID(): UUID {
+    return UUID.randomUUID()
   }
-  // Fetches the list of books from the Firestore collection
-  // If the task is successful, maps the Firestore documents to DataBook objects
-  // Calls OnSuccess with the list of books, or onFailure if the task fails
-  override fun getBook(OnSucess: (List<DataBook>) -> Unit, onFailure: (Exception) -> Unit) {
+
+  override fun getBook(callback: (Result<List<DataBook>>) -> Unit) {
     db.collection(collectionBooks).get().addOnCompleteListener { task ->
       if (task.isSuccessful) {
         // Maps Firestore documents to DataBook objects or returns an empty list
         val books = task.result?.mapNotNull { document -> documentToBooks(document) } ?: emptyList()
-        OnSucess(books)
+        callback(Result.success(books))
       } else {
-        task.exception?.let { e -> onFailure(e) }
+        task.exception?.let { e -> callback(Result.failure(e)) }
       }
     }
   }
-  // Adds a new book to the Firestore collection
-  // Calls OnSuccess if the operation is successful, otherwise onFailure with the exception
-  override fun addBook(dataBook: DataBook, OnSucess: () -> Unit, onFailure: (Exception) -> Unit) {
+
+  override fun addBook(dataBook: DataBook, callback: (Result<Unit>) -> Unit) {
+    // Check if essential fields are non-null before attempting to save
+    if (dataBook.title.isBlank() ||
+        dataBook.author.isNullOrBlank() ||
+        dataBook.isbn.isNullOrBlank()) {
+      val exception = IllegalArgumentException("Missing required book fields.")
+      Log.e("BooksFirestoreRepository", "Failed to add book: ${exception.message}")
+      callback(Result.failure(exception))
+      return
+    }
+
+    Log.d("BooksFirestoreRepository", "Attempting to add book: ${dataBook.title}")
+
+    // Attempt to add book to Firestore
     performFirestoreOperation(
-        db.collection(collectionBooks).document(dataBook.title).set(dataBook), OnSucess, onFailure)
+        db.collection(collectionBooks).document(dataBook.uuid.toString()).set(dataBook)) { result ->
+          if (result.isSuccess)
+              Log.d("BooksFirestoreRepository", "Book added successfully: ${dataBook.title}")
+          else {
+            val error = result.exceptionOrNull()!!
+            Log.e("BooksFirestoreRepository", "Failed to add book: ${error.message}", error)
+          }
+          callback(result)
+        }
   }
-  // Updates an existing book in Firestore by replacing the document with the same title
-  // Uses performFirestoreOperation to handle success and failure
-  override fun updateBook(
-      dataBook: DataBook,
-      OnSucess: () -> Unit,
-      onFailure: (Exception) -> Unit
-  ) {
+
+  override fun updateBook(dataBook: DataBook, callback: (Result<Unit>) -> Unit) {
     performFirestoreOperation(
-        db.collection(collectionBooks).document(dataBook.title).set(dataBook), OnSucess, onFailure)
+        db.collection(collectionBooks).document(dataBook.uuid.toString()).set(dataBook), callback)
   }
-  // Deletes a book from Firestore by its title
-  // Uses performFirestoreOperation to handle success and failure
-  override fun deleteBooks(
-      id: String,
-      dataBook: DataBook,
-      OnSucess: () -> Unit,
-      onFailure: (Exception) -> Unit
-  ) {
+
+  override fun deleteBooks(uuid: UUID, dataBook: DataBook, callback: (Result<Unit>) -> Unit) {
     performFirestoreOperation(
-        db.collection(collectionBooks).document(dataBook.isbn!!).delete(), OnSucess, onFailure)
+        db.collection(collectionBooks).document(dataBook.uuid.toString()).delete(), callback)
   }
   // Maps a Firestore document to a DataBook object
   // If any required field is missing, returns null to avoid incomplete objects
   fun documentToBooks(document: DocumentSnapshot): DataBook? {
     return try {
-      val title = document.getString("Title") ?: return null
-      val author = document.getString("Author") ?: return null
-      val description = document.getString("Description") ?: return null
-      val rating = document.getString("Rating") ?: return null
-      val photo = document.getString("Photo") ?: return null
-      val isbn = document.getString("ISBN") ?: return null
-      val languageBook = BookLanguages.valueOf(document.getString("Language") ?: return null)
+      val uuid = UUID.fromString(document.getString("uuid")) ?: return null
+      val title = document.getString("title") ?: return null
+      val author = document.getString("author")
+      val description = document.getString("description")
+      val rating = document.getLong("rating")
+      val photo = document.getString("photo")
+      val isbn = document.getString("isbn")
+      val languageBook = BookLanguages.valueOf(document.getString("language") ?: return null)
       val genres = document.get("genres") as? List<String> ?: emptyList()
       val bookGenres =
           genres.mapNotNull { genre ->
@@ -92,31 +111,21 @@
             }
           }
       DataBook(
-          UUID.randomUUID(),
-          title,
-          author,
-          description,
-          rating.toInt(),
-          photo,
-          languageBook,
-          isbn,
-          bookGenres)
+          uuid, title, author, description, rating?.toInt(), photo, languageBook, isbn, bookGenres)
     } catch (e: Exception) {
       null // Return null in case of any exception during the conversion
     }
   }
-  // Helper function to perform Firestore operations (add, update, delete)
-  // Executes the provided Firestore task and triggers success or failure callbacks
-  private fun performFirestoreOperation(
-      task: Task<Void>,
-      OnSucess: () -> Unit,
-      OnFailure: (Exception) -> Unit
-  ) {
+  /**
+   * Helper function to perform Firestore operations (add, update, delete) Executes the provided
+   * Firestore task and triggers success or failure callbacks
+   */
+  private fun performFirestoreOperation(task: Task<Void>, callback: (Result<Unit>) -> Unit) {
     task.addOnCompleteListener { result ->
       if (result.isSuccessful) {
-        OnSucess()
+        callback(Result.success(Unit))
       } else {
-        result.exception?.let { e -> OnFailure(e) }
+        result.exception?.let { e -> callback(Result.failure(e)) }
       }
     }
   }
Index: app/src/androidTest/java/com/android/bookswap/ui/map/MapScreenTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.map\n\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.semantics.getOrNull\nimport androidx.compose.ui.test.assertCountEquals\nimport androidx.compose.ui.test.assertIsDisplayed\nimport androidx.compose.ui.test.assertIsNotDisplayed\nimport androidx.compose.ui.test.assertTextContains\nimport androidx.compose.ui.test.junit4.createComposeRule\nimport androidx.compose.ui.test.onAllNodesWithTag\nimport androidx.compose.ui.test.onNodeWithTag\nimport androidx.compose.ui.test.performTouchInput\nimport androidx.compose.ui.test.swipe\nimport androidx.compose.ui.test.swipeUp\nimport androidx.navigation.compose.rememberNavController\nimport com.android.bookswap.data.BookGenres\nimport com.android.bookswap.data.BookLanguages\nimport com.android.bookswap.data.DataBook\nimport com.android.bookswap.model.map.BookFilter\nimport com.android.bookswap.model.map.DefaultGeolocation\nimport com.android.bookswap.ui.navigation.NavigationActions\nimport com.google.maps.android.compose.CameraPositionState\nimport java.util.UUID\nimport junit.framework.TestCase.assertEquals\nimport org.junit.Rule\nimport org.junit.Test\n\nclass MapScreenTest {\n  private val user =\n      listOf(\n          TempUser(\n              latitude = 0.0,\n              longitude = 0.0,\n              listBook =\n                  listOf(\n                      DataBook(\n                          uuid = UUID.randomUUID(),\n                          title = \"Book 1\",\n                          author = \"Author 1\",\n                          description = \"Description of Book 1\",\n                          rating = 5,\n                          photo = \"url_to_photo_1\",\n                          language = BookLanguages.ENGLISH,\n                          isbn = \"123-456-789\",\n                          genres = listOf(BookGenres.FICTION, BookGenres.HORROR)),\n                      DataBook(\n                          uuid = UUID.randomUUID(),\n                          title = \"Book 2\",\n                          author = \"Author 2\",\n                          description = \"Description of Book 2\",\n                          rating = 4,\n                          photo = \"url_to_photo_2\",\n                          language = BookLanguages.FRENCH,\n                          isbn = \"234-567-890\",\n                          genres = listOf(BookGenres.FICTION)))))\n\n  private val userWithoutBooks =\n      listOf(TempUser(latitude = 1.0, longitude = 1.0, listBook = emptyList()))\n  @get:Rule val composeTestRule = createComposeRule()\n\n  private val longListUser =\n      listOf(\n          TempUser(\n              latitude = 0.0,\n              longitude = 0.0,\n              listBook =\n                  List(20) {\n                    DataBook(\n                        uuid = UUID.randomUUID(),\n                        title = \"Book 1\",\n                        author = \"Author 1\",\n                        description = \"Description of Book 1\",\n                        rating = 5,\n                        photo = \"url_to_photo_1\",\n                        language = BookLanguages.ENGLISH,\n                        isbn = \"123-456-789\",\n                        genres = listOf(BookGenres.FICTION, BookGenres.NONFICTION))\n                  }))\n\n  @Test\n  fun displayAllComponents() {\n    composeTestRule.setContent {\n      val navController = rememberNavController()\n      val navigationActions = NavigationActions(navController)\n      MapScreen(user, user[0], navigationActions, BookFilter())\n    }\n    composeTestRule.onNodeWithTag(\"mapScreen\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"mapGoogleMap\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"mapBoxMarker\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"mapBoxMarkerList\").assertIsDisplayed()\n    composeTestRule.onAllNodesWithTag(\"mapBoxMarkerListBox\").assertCountEquals(2)\n    composeTestRule.onAllNodesWithTag(\"mapBoxMarkerListBoxTitle\").assertCountEquals(2)\n    composeTestRule.onAllNodesWithTag(\"mapBoxMarkerListBoxAuthor\").assertCountEquals(2)\n    composeTestRule.onAllNodesWithTag(\"mapBoxMarkerListDivider\").assertCountEquals(1)\n\n    // components of Draggable Menu\n    composeTestRule.onNodeWithTag(\"mapDraggableMenu\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"mapDraggableMenuStructure\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"mapDraggableMenuHandle\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"mapDraggableMenuHandleDivider\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"mapDraggableMenuBookBox0\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"mapDraggableMenuBookBox1\").assertIsDisplayed()\n    composeTestRule.onAllNodesWithTag(\"mapDraggableMenuBookBoxImage\").assertCountEquals(2)\n    composeTestRule.onAllNodesWithTag(\"mapDraggableMenuBookBoxTitle\").assertCountEquals(2)\n    composeTestRule.onAllNodesWithTag(\"mapDraggableMenuBookBoxAuthor\").assertCountEquals(2)\n    composeTestRule.onAllNodesWithTag(\"mapDraggableMenuBookBoxRating\").assertCountEquals(2)\n    composeTestRule.onAllNodesWithTag(\"mapDraggableMenuBookBoxStar\").assertCountEquals(9)\n    composeTestRule.onAllNodesWithTag(\"mapDraggableMenuBookBoxEmptyStar\").assertCountEquals(1)\n    composeTestRule.onAllNodesWithTag(\"mapDraggableMenuBookBoxTag\").assertCountEquals(2)\n    composeTestRule.onAllNodesWithTag(\"mapDraggableMenuBookBoxDivider\").assertCountEquals(2)\n  }\n\n  @Test\n  fun noMarkerDisplayedForUserWithoutBooks() {\n    composeTestRule.setContent {\n      val navController = rememberNavController()\n      val navigationActions = NavigationActions(navController)\n      MapScreen(userWithoutBooks, userWithoutBooks[0], navigationActions, BookFilter())\n    }\n\n    // Assert that the marker info window is displayed, but without book entries\n    composeTestRule.onNodeWithTag(\"mapBoxMarker\").assertIsNotDisplayed()\n    composeTestRule.onAllNodesWithTag(\"mapBoxMarkerListBox\").assertCountEquals(0) // No books\n  }\n\n  @Test\n  fun noBookDisplayedInDraggableMenuForAllUsersWithNoBook() {\n    composeTestRule.setContent {\n      val navController = rememberNavController()\n      val navigationActions = NavigationActions(navController)\n      MapScreen(userWithoutBooks, navigationActions = navigationActions, bookFilter = BookFilter())\n    }\n\n    composeTestRule.onNodeWithTag(\"mapDraggableMenu\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"mapDraggableMenuBookBox0\").assertIsNotDisplayed() // No books\n  }\n\n  @Test\n  fun emptyUserListDoesNotShowMarkers() {\n    composeTestRule.setContent {\n      val navController = rememberNavController()\n      val navigationActions = NavigationActions(navController)\n      MapScreen(listOf(), null, navigationActions, bookFilter = BookFilter())\n    }\n\n    // Assert that the map is displayed but no marker and info window is shown\n    composeTestRule.onNodeWithTag(\"mapGoogleMap\").assertIsDisplayed()\n    composeTestRule.onAllNodesWithTag(\"mapBoxMarker\").assertCountEquals(0) // No marker info\n  }\n\n  @Test\n  fun emptyUserListGiveEmptyDraggableMenu() {\n    composeTestRule.setContent {\n      val navController = rememberNavController()\n      val navigationActions = NavigationActions(navController)\n      MapScreen(userWithoutBooks, navigationActions = navigationActions, bookFilter = BookFilter())\n    }\n\n    // Assert that the marker info window is displayed, but without book entries\n    composeTestRule.onNodeWithTag(\"mapDraggableMenu\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"mapDraggableMenuBookBox0\").assertIsNotDisplayed() // No books\n  }\n\n  @Test\n  fun noUserSelectedInitially() {\n    composeTestRule.setContent {\n      val navController = rememberNavController()\n      val navigationActions = NavigationActions(navController)\n      MapScreen(user, null, navigationActions, bookFilter = BookFilter())\n    }\n\n    // Assert that no info window is displayed when no user is selected\n    composeTestRule.onNodeWithTag(\"mapGoogleMap\").assertIsDisplayed()\n    composeTestRule.onAllNodesWithTag(\"mapBoxMarker\").assertCountEquals(0) // No info window\n  }\n\n  @Test\n  fun draggableMenu_canBeDraggedVertically() {\n    composeTestRule.setContent {\n      val navController = rememberNavController()\n      val navigationActions = NavigationActions(navController)\n      MapScreen(user, user[0], navigationActions, bookFilter = BookFilter())\n    }\n\n    // Ensure the DraggableMenu is initially displayed\n    composeTestRule.onNodeWithTag(\"mapDraggableMenu\").assertIsDisplayed()\n\n    // Simulate a drag gesture by swiping up (closing the menu)\n    composeTestRule.onNodeWithTag(\"mapDraggableMenu\").performTouchInput {\n      swipeUp(startY = bottom, endY = top, durationMillis = 500)\n    }\n\n    // Assert that after swiping, the menu is still displayed but in a new position\n    composeTestRule.onNodeWithTag(\"mapDraggableMenu\").assertIsDisplayed()\n\n    // Simulate dragging the menu back down (opening the menu)\n    composeTestRule.onNodeWithTag(\"mapDraggableMenu\").performTouchInput {\n      swipe(start = Offset(0f, 100f), end = Offset(0f, -500f), durationMillis = 500)\n    }\n\n    // Assert that after swiping, the menu is still displayed but in a new position\n    composeTestRule.onNodeWithTag(\"mapDraggableMenu\").assertIsDisplayed()\n  }\n\n  @Test\n  fun filterButtonIsDisplayed() {\n    composeTestRule.setContent {\n      val navController = rememberNavController()\n      val navigationActions = NavigationActions(navController)\n      MapScreen(user, user[0], navigationActions, BookFilter())\n    }\n    composeTestRule.onNodeWithTag(\"filterButton\").assertIsDisplayed()\n  }\n\n  @Test\n  fun bookChangedWhenFilterApplied() {\n    val bookFilter = BookFilter()\n    bookFilter.setGenres(listOf(\"Horror\"))\n    composeTestRule.setContent {\n      val navController = rememberNavController()\n      val navigationActions = NavigationActions(navController)\n      MapScreen(user, user[0], navigationActions, bookFilter)\n    }\n    composeTestRule.onNodeWithTag(\"mapDraggableMenuBookBox0\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"mapDraggableMenuBookBox1\").assertIsNotDisplayed()\n  }\n\n  @Test\n  fun draggableMenuListIsScrollable() {\n    composeTestRule.setContent {\n      val navController = rememberNavController()\n      val navigationActions = NavigationActions(navController)\n      // Passing multiple books to ensure list needs scrolling\n      MapScreen(longListUser, longListUser[0], navigationActions, BookFilter())\n    }\n\n    // Assert initial state: Only first item(s) are visible\n    composeTestRule.onNodeWithTag(\"mapDraggableMenuBookBox0\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"mapDraggableMenuBookBox19\").assertIsNotDisplayed()\n    // Perform scroll gesture on LazyColumn\n    composeTestRule.onNodeWithTag(\"mapDraggableMenuStructure\").performTouchInput {\n      for (i in 1..19) {\n        swipeUp()\n      }\n    }\n    composeTestRule.onNodeWithTag(\"mapDraggableMenuBookBox0\").assertIsNotDisplayed()\n    composeTestRule.onNodeWithTag(\"mapDraggableMenuBookBox19\").assertIsDisplayed()\n  }\n\n  @Test\n  fun listMarkerBookChangedWhenFilterApplied() {\n    val bookFilter = BookFilter()\n    bookFilter.setGenres(listOf(\"Horror\"))\n    composeTestRule.setContent {\n      val navController = rememberNavController()\n      val navigationActions = NavigationActions(navController)\n      MapScreen(user, user[0], navigationActions, bookFilter)\n    }\n    composeTestRule.onNodeWithTag(\"mapBoxMarkerListBox\").assertIsDisplayed()\n    composeTestRule.onAllNodesWithTag(\"mapBoxMarkerListBox\").assertCountEquals(1)\n    composeTestRule.onNodeWithTag(\"mapBoxMarkerListBoxTitle\").assertTextContains(\"Book 1\")\n  }\n\n  @Test\n  fun noBooksTextDisplayedWhenNoBooksFound() {\n    val bookFilter = BookFilter()\n    bookFilter.setGenres(listOf(\"Dystopian\"))\n    composeTestRule.setContent {\n      val navController = rememberNavController()\n      val navigationActions = NavigationActions(navController)\n      MapScreen(user, user[0], navigationActions, bookFilter)\n    }\n    composeTestRule\n        .onNodeWithTag(\"mapDraggableMenuNoBook\")\n        .assertIsDisplayed()\n        .assertTextContains(\"No books found\")\n    composeTestRule.onNodeWithTag(\"mapDraggableMenuBookBox\").assertIsNotDisplayed()\n  }\n\n  @Test\n  fun mapHasGeoLocation() {\n    val geolocation = DefaultGeolocation()\n    composeTestRule.setContent {\n      val navController = rememberNavController()\n      val navigationActions = NavigationActions(navController)\n      MapScreen(user, user[0], navigationActions, BookFilter(), geolocation)\n    }\n    val node1 = composeTestRule.onNodeWithTag(\"mapGoogleMap\").fetchSemanticsNode()\n    val cameraPositionState: CameraPositionState? = node1.config.getOrNull(CameraPositionKey)\n\n    assertEquals(geolocation.latitude.value, cameraPositionState?.position?.target?.latitude)\n    assertEquals(geolocation.longitude.value, cameraPositionState?.position?.target?.longitude)\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/map/MapScreenTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/map/MapScreenTest.kt
--- a/app/src/androidTest/java/com/android/bookswap/ui/map/MapScreenTest.kt	
+++ b/app/src/androidTest/java/com/android/bookswap/ui/map/MapScreenTest.kt	
@@ -16,73 +16,94 @@
 import com.android.bookswap.data.BookGenres
 import com.android.bookswap.data.BookLanguages
 import com.android.bookswap.data.DataBook
-import com.android.bookswap.model.map.BookFilter
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.UserBooksWithLocation
+import com.android.bookswap.model.map.BookManagerViewModel
 import com.android.bookswap.model.map.DefaultGeolocation
 import com.android.bookswap.ui.navigation.NavigationActions
 import com.google.maps.android.compose.CameraPositionState
+import io.mockk.every
+import io.mockk.just
+import io.mockk.mockk
+import io.mockk.runs
 import java.util.UUID
 import junit.framework.TestCase.assertEquals
+import kotlinx.coroutines.flow.MutableStateFlow
+import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 
-class MapScreenTest {
-  private val user =
-      listOf(
-          TempUser(
-              latitude = 0.0,
-              longitude = 0.0,
-              listBook =
-                  listOf(
-                      DataBook(
-                          uuid = UUID.randomUUID(),
-                          title = "Book 1",
-                          author = "Author 1",
-                          description = "Description of Book 1",
-                          rating = 5,
-                          photo = "url_to_photo_1",
-                          language = BookLanguages.ENGLISH,
-                          isbn = "123-456-789",
-                          genres = listOf(BookGenres.FICTION, BookGenres.HORROR)),
-                      DataBook(
-                          uuid = UUID.randomUUID(),
-                          title = "Book 2",
-                          author = "Author 2",
-                          description = "Description of Book 2",
-                          rating = 4,
-                          photo = "url_to_photo_2",
-                          language = BookLanguages.FRENCH,
-                          isbn = "234-567-890",
-                          genres = listOf(BookGenres.FICTION)))))
+val longListBook =
+    List(20) {
+      DataBook(
+          uuid = UUID(2000, 2000),
+          title = "Book 1",
+          author = "Author 1",
+          description = "Description of Book 1",
+          rating = 5,
+          photo = "url_to_photo_1",
+          language = BookLanguages.ENGLISH,
+          isbn = "123-456-789",
+          genres = listOf(BookGenres.FICTION, BookGenres.NONFICTION))
+    }
+
+val books =
+    listOf(
+        DataBook(
+            uuid = UUID(1000, 1000),
+            title = "Book 1",
+            author = "Author 1",
+            description = "Description of Book 1",
+            rating = 5,
+            photo = "url_to_photo_1",
+            language = BookLanguages.ENGLISH,
+            isbn = "123-456-789",
+            genres = listOf(BookGenres.FICTION, BookGenres.HORROR)),
+        DataBook(
+            uuid = UUID(2000, 1000),
+            title = "Book 2",
+            author = "Author 2",
+            description = "Description of Book 2",
+            rating = 4,
+            photo = "url_to_photo_2",
+            language = BookLanguages.FRENCH,
+            isbn = "234-567-890",
+            genres = listOf(BookGenres.FICTION)))
+
+class MapScreenTest {
+  private val user = listOf(DataUser(bookList = listOf(UUID(1000, 1000), UUID(2000, 1000))))
+  private val userLongList = listOf(DataUser(bookList = listOf(UUID(2000, 2000))))
+
+  private val userBooksWithLocationList =
+      listOf(UserBooksWithLocation(UUID.randomUUID(), user[0].longitude, user[0].latitude, books))
+  private val userBooksWithLocationLongList =
+      listOf(
+          UserBooksWithLocation(
+              UUID.randomUUID(), userLongList[0].longitude, userLongList[0].latitude, longListBook))
 
   private val userWithoutBooks =
-      listOf(TempUser(latitude = 1.0, longitude = 1.0, listBook = emptyList()))
+      listOf(UserBooksWithLocation(UUID.randomUUID(), 0.0, 0.0, emptyList()))
   @get:Rule val composeTestRule = createComposeRule()
 
-  private val longListUser =
-      listOf(
-          TempUser(
-              latitude = 0.0,
-              longitude = 0.0,
-              listBook =
-                  List(20) {
-                    DataBook(
-                        uuid = UUID.randomUUID(),
-                        title = "Book 1",
-                        author = "Author 1",
-                        description = "Description of Book 1",
-                        rating = 5,
-                        photo = "url_to_photo_1",
-                        language = BookLanguages.ENGLISH,
-                        isbn = "123-456-789",
-                        genres = listOf(BookGenres.FICTION, BookGenres.NONFICTION))
-                  }))
+  private val mockBookManagerViewModel: BookManagerViewModel = mockk()
+
+  @Before
+  fun setup() {
+
+    every { mockBookManagerViewModel.filteredBooks } returns MutableStateFlow(books)
+
+    every { mockBookManagerViewModel.filteredUsers } returns
+        MutableStateFlow(userBooksWithLocationList)
+    every { mockBookManagerViewModel.startUpdatingBooks() } just runs
+    every { mockBookManagerViewModel.stopUpdatingBooks() } just runs
+  }
 
   @Test
   fun displayAllComponents() {
     composeTestRule.setContent {
       val navController = rememberNavController()
       val navigationActions = NavigationActions(navController)
-      MapScreen(user, user[0], navigationActions, BookFilter())
+      MapScreen(mockBookManagerViewModel, navigationActions, 0)
     }
     composeTestRule.onNodeWithTag("mapScreen").assertIsDisplayed()
     composeTestRule.onNodeWithTag("mapGoogleMap").assertIsDisplayed()
@@ -108,14 +129,18 @@
     composeTestRule.onAllNodesWithTag("mapDraggableMenuBookBoxEmptyStar").assertCountEquals(1)
     composeTestRule.onAllNodesWithTag("mapDraggableMenuBookBoxTag").assertCountEquals(2)
     composeTestRule.onAllNodesWithTag("mapDraggableMenuBookBoxDivider").assertCountEquals(2)
+
+    composeTestRule.onNodeWithTag("filterButton").assertIsDisplayed()
   }
 
   @Test
   fun noMarkerDisplayedForUserWithoutBooks() {
+    every { mockBookManagerViewModel.filteredBooks } answers { MutableStateFlow(emptyList()) }
+    every { mockBookManagerViewModel.filteredUsers } answers { MutableStateFlow(userWithoutBooks) }
     composeTestRule.setContent {
       val navController = rememberNavController()
       val navigationActions = NavigationActions(navController)
-      MapScreen(userWithoutBooks, userWithoutBooks[0], navigationActions, BookFilter())
+      MapScreen(mockBookManagerViewModel, navigationActions, 0)
     }
 
     // Assert that the marker info window is displayed, but without book entries
@@ -123,24 +148,14 @@
     composeTestRule.onAllNodesWithTag("mapBoxMarkerListBox").assertCountEquals(0) // No books
   }
 
-  @Test
-  fun noBookDisplayedInDraggableMenuForAllUsersWithNoBook() {
-    composeTestRule.setContent {
-      val navController = rememberNavController()
-      val navigationActions = NavigationActions(navController)
-      MapScreen(userWithoutBooks, navigationActions = navigationActions, bookFilter = BookFilter())
-    }
-
-    composeTestRule.onNodeWithTag("mapDraggableMenu").assertIsDisplayed()
-    composeTestRule.onNodeWithTag("mapDraggableMenuBookBox0").assertIsNotDisplayed() // No books
-  }
-
   @Test
   fun emptyUserListDoesNotShowMarkers() {
+    every { mockBookManagerViewModel.filteredBooks } answers { MutableStateFlow(emptyList()) }
+    every { mockBookManagerViewModel.filteredUsers } answers { MutableStateFlow(emptyList()) }
     composeTestRule.setContent {
       val navController = rememberNavController()
       val navigationActions = NavigationActions(navController)
-      MapScreen(listOf(), null, navigationActions, bookFilter = BookFilter())
+      MapScreen(mockBookManagerViewModel, navigationActions)
     }
 
     // Assert that the map is displayed but no marker and info window is shown
@@ -149,16 +164,21 @@
   }
 
   @Test
-  fun emptyUserListGiveEmptyDraggableMenu() {
+  fun emptyBooksListGiveEmptyDraggableMenu() {
+    every { mockBookManagerViewModel.filteredBooks } answers { MutableStateFlow(emptyList()) }
+    every { mockBookManagerViewModel.filteredUsers } answers { MutableStateFlow(emptyList()) }
     composeTestRule.setContent {
       val navController = rememberNavController()
       val navigationActions = NavigationActions(navController)
-      MapScreen(userWithoutBooks, navigationActions = navigationActions, bookFilter = BookFilter())
+      MapScreen(mockBookManagerViewModel, navigationActions)
     }
-
     // Assert that the marker info window is displayed, but without book entries
     composeTestRule.onNodeWithTag("mapDraggableMenu").assertIsDisplayed()
-    composeTestRule.onNodeWithTag("mapDraggableMenuBookBox0").assertIsNotDisplayed() // No books
+    composeTestRule.onNodeWithTag("mapDraggableMenuBookBox0").assertIsNotDisplayed()
+    composeTestRule
+        .onNodeWithTag("mapDraggableMenuNoBook")
+        .assertIsDisplayed()
+        .assertTextContains("No books found")
   }
 
   @Test
@@ -166,7 +186,7 @@
     composeTestRule.setContent {
       val navController = rememberNavController()
       val navigationActions = NavigationActions(navController)
-      MapScreen(user, null, navigationActions, bookFilter = BookFilter())
+      MapScreen(mockBookManagerViewModel, navigationActions)
     }
 
     // Assert that no info window is displayed when no user is selected
@@ -179,9 +199,8 @@
     composeTestRule.setContent {
       val navController = rememberNavController()
       val navigationActions = NavigationActions(navController)
-      MapScreen(user, user[0], navigationActions, bookFilter = BookFilter())
+      MapScreen(mockBookManagerViewModel, navigationActions, 0)
     }
-
     // Ensure the DraggableMenu is initially displayed
     composeTestRule.onNodeWithTag("mapDraggableMenu").assertIsDisplayed()
 
@@ -202,36 +221,18 @@
     composeTestRule.onNodeWithTag("mapDraggableMenu").assertIsDisplayed()
   }
 
-  @Test
-  fun filterButtonIsDisplayed() {
-    composeTestRule.setContent {
-      val navController = rememberNavController()
-      val navigationActions = NavigationActions(navController)
-      MapScreen(user, user[0], navigationActions, BookFilter())
-    }
-    composeTestRule.onNodeWithTag("filterButton").assertIsDisplayed()
-  }
-
-  @Test
-  fun bookChangedWhenFilterApplied() {
-    val bookFilter = BookFilter()
-    bookFilter.setGenres(listOf("Horror"))
-    composeTestRule.setContent {
-      val navController = rememberNavController()
-      val navigationActions = NavigationActions(navController)
-      MapScreen(user, user[0], navigationActions, bookFilter)
-    }
-    composeTestRule.onNodeWithTag("mapDraggableMenuBookBox0").assertIsDisplayed()
-    composeTestRule.onNodeWithTag("mapDraggableMenuBookBox1").assertIsNotDisplayed()
-  }
-
   @Test
   fun draggableMenuListIsScrollable() {
+
+    every { mockBookManagerViewModel.filteredBooks } answers { MutableStateFlow(longListBook) }
+    every { mockBookManagerViewModel.filteredUsers } answers
+        {
+          MutableStateFlow(userBooksWithLocationLongList)
+        }
     composeTestRule.setContent {
       val navController = rememberNavController()
       val navigationActions = NavigationActions(navController)
-      // Passing multiple books to ensure list needs scrolling
-      MapScreen(longListUser, longListUser[0], navigationActions, BookFilter())
+      MapScreen(mockBookManagerViewModel, navigationActions, 0)
     }
 
     // Assert initial state: Only first item(s) are visible
@@ -247,43 +248,13 @@
     composeTestRule.onNodeWithTag("mapDraggableMenuBookBox19").assertIsDisplayed()
   }
 
-  @Test
-  fun listMarkerBookChangedWhenFilterApplied() {
-    val bookFilter = BookFilter()
-    bookFilter.setGenres(listOf("Horror"))
-    composeTestRule.setContent {
-      val navController = rememberNavController()
-      val navigationActions = NavigationActions(navController)
-      MapScreen(user, user[0], navigationActions, bookFilter)
-    }
-    composeTestRule.onNodeWithTag("mapBoxMarkerListBox").assertIsDisplayed()
-    composeTestRule.onAllNodesWithTag("mapBoxMarkerListBox").assertCountEquals(1)
-    composeTestRule.onNodeWithTag("mapBoxMarkerListBoxTitle").assertTextContains("Book 1")
-  }
-
-  @Test
-  fun noBooksTextDisplayedWhenNoBooksFound() {
-    val bookFilter = BookFilter()
-    bookFilter.setGenres(listOf("Dystopian"))
-    composeTestRule.setContent {
-      val navController = rememberNavController()
-      val navigationActions = NavigationActions(navController)
-      MapScreen(user, user[0], navigationActions, bookFilter)
-    }
-    composeTestRule
-        .onNodeWithTag("mapDraggableMenuNoBook")
-        .assertIsDisplayed()
-        .assertTextContains("No books found")
-    composeTestRule.onNodeWithTag("mapDraggableMenuBookBox").assertIsNotDisplayed()
-  }
-
   @Test
   fun mapHasGeoLocation() {
     val geolocation = DefaultGeolocation()
     composeTestRule.setContent {
       val navController = rememberNavController()
       val navigationActions = NavigationActions(navController)
-      MapScreen(user, user[0], navigationActions, BookFilter(), geolocation)
+      MapScreen(mockBookManagerViewModel, navigationActions, 0)
     }
     val node1 = composeTestRule.onNodeWithTag("mapGoogleMap").fetchSemanticsNode()
     val cameraPositionState: CameraPositionState? = node1.config.getOrNull(CameraPositionKey)
Index: app/src/main/java/com/android/bookswap/ui/books/BookProfile.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.books\r\n\r\nimport androidx.compose.foundation.Image\r\nimport androidx.compose.foundation.background\r\nimport androidx.compose.foundation.layout.Arrangement\r\nimport androidx.compose.foundation.layout.Box\r\nimport androidx.compose.foundation.layout.Column\r\nimport androidx.compose.foundation.layout.Row\r\nimport androidx.compose.foundation.layout.Spacer\r\nimport androidx.compose.foundation.layout.fillMaxSize\r\nimport androidx.compose.foundation.layout.fillMaxWidth\r\nimport androidx.compose.foundation.layout.height\r\nimport androidx.compose.foundation.layout.padding\r\nimport androidx.compose.foundation.layout.size\r\nimport androidx.compose.foundation.lazy.LazyColumn\r\nimport androidx.compose.material.icons.Icons\r\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\r\nimport androidx.compose.material.icons.automirrored.filled.ArrowForward\r\nimport androidx.compose.material3.ExperimentalMaterial3Api\r\nimport androidx.compose.material3.Icon\r\nimport androidx.compose.material3.IconButton\r\nimport androidx.compose.material3.MaterialTheme\r\nimport androidx.compose.material3.Scaffold\r\nimport androidx.compose.material3.Text\r\nimport androidx.compose.material3.TopAppBar\r\nimport androidx.compose.material3.TopAppBarDefaults\r\nimport androidx.compose.material3.VerticalDivider\r\nimport androidx.compose.runtime.Composable\r\nimport androidx.compose.runtime.getValue\r\nimport androidx.compose.runtime.mutableIntStateOf\r\nimport androidx.compose.runtime.remember\r\nimport androidx.compose.runtime.setValue\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport androidx.compose.ui.graphics.Color\r\nimport androidx.compose.ui.platform.LocalConfiguration\r\nimport androidx.compose.ui.platform.testTag\r\nimport androidx.compose.ui.res.painterResource\r\nimport androidx.compose.ui.text.style.TextAlign\r\nimport androidx.compose.ui.unit.dp\r\nimport com.android.bookswap.R\r\nimport com.android.bookswap.data.DataBook\r\nimport com.android.bookswap.ui.components.BackButtonComponent\r\nimport com.android.bookswap.ui.navigation.BottomNavigationMenu\r\nimport com.android.bookswap.ui.navigation.List_Navigation_Bar_Destinations\r\nimport com.android.bookswap.ui.navigation.NavigationActions\r\nimport com.android.bookswap.ui.theme.ColorVariable\r\n\r\n@OptIn(ExperimentalMaterial3Api::class)\r\n@Composable\r\nfun BookProfileScreen(DataBook: DataBook, navController: NavigationActions) {\r\n  val columnPadding = 8.dp\r\n  val pictureWidth = (LocalConfiguration.current.screenWidthDp.dp * (0.60f))\r\n  val pictureHeight = pictureWidth * 1.41f\r\n  val buttonsHeight = pictureHeight / 12.0f\r\n  val images = listOf(R.drawable.isabellacatolica, R.drawable.felipeii)\r\n  val imagesDescription = listOf(\"Isabel La Catolica\", \"Felipe II\")\r\n  var currentImageIndex by remember { mutableIntStateOf(0) }\r\n  Scaffold(\r\n      modifier = Modifier.testTag(\"bookProfileScreen\"),\r\n      topBar = {\r\n        TopAppBar(\r\n            title = { Text(\"Book Profile\", color = Color.Transparent) },\r\n            navigationIcon = { BackButtonComponent(navController) },\r\n            colors = TopAppBarDefaults.topAppBarColors(containerColor = ColorVariable.BackGround))\r\n      },\r\n      bottomBar = {\r\n        BottomNavigationMenu(\r\n            onTabSelect = { destination -> navController.navigateTo(destination) },\r\n            tabList = List_Navigation_Bar_Destinations,\r\n            selectedItem = navController.currentRoute())\r\n      }) { innerPadding ->\r\n        LazyColumn(\r\n            modifier =\r\n                Modifier.fillMaxSize()\r\n                    .padding(innerPadding)\r\n                    .background(ColorVariable.BackGround)\r\n                    .testTag(\"bookProfileScroll\"),\r\n            verticalArrangement = Arrangement.spacedBy(columnPadding),\r\n            horizontalAlignment = Alignment.CenterHorizontally) {\r\n              item {\r\n                Text(\r\n                    text = DataBook.title,\r\n                    modifier = Modifier.testTag(\"bookTitle\").padding(columnPadding),\r\n                    color = ColorVariable.Accent,\r\n                    style = MaterialTheme.typography.titleLarge)\r\n              }\r\n              item {\r\n                Text(\r\n                    text = DataBook.author ?: \"Author Unknown\",\r\n                    modifier = Modifier.testTag(\"bookAuthor\"),\r\n                    color = ColorVariable.AccentSecondary,\r\n                    style = MaterialTheme.typography.titleMedium)\r\n              }\r\n              item { Spacer(modifier = Modifier.height(columnPadding)) }\r\n              item {\r\n                Box(\r\n                    modifier =\r\n                        Modifier.size(pictureWidth, pictureHeight)\r\n                            .background(ColorVariable.BackGround)) {\r\n                      Image(\r\n                          painter = painterResource(id = images[currentImageIndex]),\r\n                          contentDescription = imagesDescription[currentImageIndex],\r\n                          modifier =\r\n                              Modifier.height(pictureHeight)\r\n                                  .fillMaxWidth()\r\n                                  .testTag(\r\n                                      \"bookProfileImage ${imagesDescription[currentImageIndex]}\"))\r\n                    }\r\n              }\r\n              item {\r\n                Row(\r\n                    modifier = Modifier.fillMaxWidth().padding(horizontal = 16.dp),\r\n                    verticalAlignment = Alignment.CenterVertically,\r\n                    horizontalArrangement = Arrangement.SpaceBetween) {\r\n                      IconButton(\r\n                          onClick = {\r\n                            currentImageIndex = (currentImageIndex - 1 + images.size) % images.size\r\n                          },\r\n                          modifier =\r\n                              Modifier.height(buttonsHeight).testTag(\"bookProfileImageLeft\")) {\r\n                            Icon(\r\n                                imageVector = Icons.AutoMirrored.Filled.ArrowBack,\r\n                                contentDescription = \"Previous Image\",\r\n                                tint = ColorVariable.Accent)\r\n                          }\r\n                      Text(\r\n                          text = imagesDescription[currentImageIndex],\r\n                          color = ColorVariable.AccentSecondary,\r\n                          modifier = Modifier.padding(horizontal = 8.dp))\r\n                      IconButton(\r\n                          onClick = { currentImageIndex = (currentImageIndex + 1) % images.size },\r\n                          modifier =\r\n                              Modifier.height(buttonsHeight).testTag(\"bookProfileImageRight\")) {\r\n                            Icon(\r\n                                imageVector = Icons.AutoMirrored.Filled.ArrowForward,\r\n                                contentDescription = \"Next Image\",\r\n                                tint = ColorVariable.Accent)\r\n                          }\r\n                    }\r\n              }\r\n              item { Spacer(modifier = Modifier.height(columnPadding)) }\r\n              item {\r\n                DataBook.rating?.let {\r\n                  Text(\r\n                      text = \"Rating: $it/10\",\r\n                      color = ColorVariable.Accent,\r\n                      style = MaterialTheme.typography.bodyMedium,\r\n                      modifier = Modifier.padding(vertical = 8.dp).testTag(\"bookProfileRating\"))\r\n                }\r\n              }\r\n              item { Spacer(modifier = Modifier.height(columnPadding)) }\r\n              item {\r\n                Text(\r\n                    text = \"Synopsis\",\r\n                    color = ColorVariable.Accent,\r\n                    style = MaterialTheme.typography.titleSmall,\r\n                    modifier =\r\n                        Modifier.padding(vertical = 8.dp).testTag(\"bookProfileSynopsisTitle\"))\r\n              }\r\n              item {\r\n                Text(\r\n                    text = DataBook.description ?: \"No description available\",\r\n                    color = ColorVariable.Accent,\r\n                    style = MaterialTheme.typography.bodyMedium,\r\n                    modifier = Modifier.padding(vertical = 8.dp).testTag(\"bookProfileSynopsis\"),\r\n                    textAlign = TextAlign.Center)\r\n              }\r\n              item { Spacer(modifier = Modifier.height(columnPadding)) }\r\n              item {\r\n                Row(modifier = Modifier.fillMaxWidth().padding(horizontal = 16.dp)) {\r\n                  Column(modifier = Modifier.weight(1f)) {\r\n                    ProfileText(\r\n                        text = \"Language: ${DataBook.language.languageCode}\",\r\n                        testTag = \"bookProfileLanguage\")\r\n                    ProfileText(text = \"Genres:\", testTag = \"bookProfileGenresTitle\")\r\n                    DataBook.genres.forEach { genre ->\r\n                      Text(\r\n                          text = \"- ${genre.Genre}\",\r\n                          color = ColorVariable.AccentSecondary,\r\n                          style = MaterialTheme.typography.bodyMedium,\r\n                          modifier =\r\n                              Modifier.padding(top = 2.dp, start = 16.dp)\r\n                                  .testTag(\"bookProfileGenre${genre.Genre}\"))\r\n                    }\r\n                    ProfileText(\r\n                        text = \"ISBN: ${DataBook.isbn ?: \"ISBN doesn't exist or is not available\"}\",\r\n                        testTag = \"bookProfileISBN\")\r\n                  }\r\n\r\n                  VerticalDivider(color = ColorVariable.Accent, thickness = 1.dp)\r\n\r\n                  Column(modifier = Modifier.weight(1f)) {\r\n                    ProfileText(\r\n                        text = \"Date of Publication: [Temporary Date]\", testTag = \"bookProfileDate\")\r\n                    ProfileText(text = \"Volume: [Temporary Volume]\", testTag = \"bookProfileVolume\")\r\n                    ProfileText(text = \"Issue: [Temporary Issue]\", testTag = \"bookProfileIssue\")\r\n                    ProfileText(\r\n                        text = \"Editorial: [Temporary Editorial]\", testTag = \"bookProfileEditorial\")\r\n                    ProfileText(\r\n                        text = \"Place of Edition: [Temporary Place]\",\r\n                        testTag = \"bookProfileEditionPlace\")\r\n                  }\r\n                }\r\n              }\r\n            }\r\n      }\r\n}\r\n\r\n@Composable\r\nfun ProfileText(text: String, testTag: String) {\r\n  Text(\r\n      text = text,\r\n      color = ColorVariable.Accent,\r\n      style = MaterialTheme.typography.bodyMedium,\r\n      modifier = Modifier.padding(vertical = 8.dp).testTag(testTag))\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/books/BookProfile.kt b/app/src/main/java/com/android/bookswap/ui/books/BookProfile.kt
--- a/app/src/main/java/com/android/bookswap/ui/books/BookProfile.kt	
+++ b/app/src/main/java/com/android/bookswap/ui/books/BookProfile.kt	
@@ -22,8 +22,6 @@
 import androidx.compose.material3.MaterialTheme
 import androidx.compose.material3.Scaffold
 import androidx.compose.material3.Text
-import androidx.compose.material3.TopAppBar
-import androidx.compose.material3.TopAppBarDefaults
 import androidx.compose.material3.VerticalDivider
 import androidx.compose.runtime.Composable
 import androidx.compose.runtime.getValue
@@ -32,7 +30,6 @@
 import androidx.compose.runtime.setValue
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
-import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.platform.LocalConfiguration
 import androidx.compose.ui.platform.testTag
 import androidx.compose.ui.res.painterResource
@@ -40,15 +37,17 @@
 import androidx.compose.ui.unit.dp
 import com.android.bookswap.R
 import com.android.bookswap.data.DataBook
-import com.android.bookswap.ui.components.BackButtonComponent
-import com.android.bookswap.ui.navigation.BottomNavigationMenu
-import com.android.bookswap.ui.navigation.List_Navigation_Bar_Destinations
 import com.android.bookswap.ui.navigation.NavigationActions
 import com.android.bookswap.ui.theme.ColorVariable
 
 @OptIn(ExperimentalMaterial3Api::class)
 @Composable
-fun BookProfileScreen(DataBook: DataBook, navController: NavigationActions) {
+fun BookProfileScreen(
+    DataBook: DataBook,
+    navController: NavigationActions,
+    topAppBar: @Composable () -> Unit = {},
+    bottomAppBar: @Composable () -> Unit = {},
+) {
   val columnPadding = 8.dp
   val pictureWidth = (LocalConfiguration.current.screenWidthDp.dp * (0.60f))
   val pictureHeight = pictureWidth * 1.41f
@@ -58,18 +57,8 @@
   var currentImageIndex by remember { mutableIntStateOf(0) }
   Scaffold(
       modifier = Modifier.testTag("bookProfileScreen"),
-      topBar = {
-        TopAppBar(
-            title = { Text("Book Profile", color = Color.Transparent) },
-            navigationIcon = { BackButtonComponent(navController) },
-            colors = TopAppBarDefaults.topAppBarColors(containerColor = ColorVariable.BackGround))
-      },
-      bottomBar = {
-        BottomNavigationMenu(
-            onTabSelect = { destination -> navController.navigateTo(destination) },
-            tabList = List_Navigation_Bar_Destinations,
-            selectedItem = navController.currentRoute())
-      }) { innerPadding ->
+      topBar = topAppBar,
+      bottomBar = bottomAppBar) { innerPadding ->
         LazyColumn(
             modifier =
                 Modifier.fillMaxSize()
Index: app/src/main/java/com/android/bookswap/model/userViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.model\n\nimport androidx.lifecycle.ViewModel\nimport com.android.bookswap.data.DataUser\nimport com.android.bookswap.data.repository.UsersRepository\nimport com.android.bookswap.data.source.network.UserFirestoreSource\nimport com.google.firebase.firestore.FirebaseFirestore\n\nopen class UserViewModel(\n    var uuid: String = \"ERROR_UUID\",\n    repository: UsersRepository = UserFirestoreSource(FirebaseFirestore.getInstance())\n) : ViewModel() {\n  private var dataUser = DataUser(uuid)\n  private var isLoaded = false\n  var isStored = false\n  private val userRepository: UsersRepository = repository\n\n  open fun getUser(force: Boolean = false): DataUser {\n    if (!isLoaded || force) {\n      fetchUser()\n    }\n    return dataUser\n  }\n\n  private fun fetchUser() {\n    userRepository.getUser(uuid) { result ->\n      result.onSuccess {\n        dataUser = it\n        isLoaded = true\n        isStored = true\n      }\n    }\n  }\n\n  fun updateUser(\n      greeting: String = dataUser.greeting,\n      firstName: String = dataUser.firstName,\n      lastName: String = dataUser.lastName,\n      email: String = dataUser.email,\n      phone: String = dataUser.phoneNumber,\n      latitude: Double = dataUser.latitude,\n      longitude: Double = dataUser.longitude,\n      picURL: String = dataUser.profilePictureUrl\n  ) {\n    updateUser(\n        DataUser(greeting, firstName, lastName, email, phone, latitude, longitude, picURL, uuid))\n  }\n\n  fun updateUser(newDataUser: DataUser) {\n    this.dataUser = newDataUser\n    this.uuid = newDataUser.userId\n    isLoaded = true\n    userRepository.updateUser(dataUser) { result ->\n      result.fold({ isStored = true }, { isStored = false })\n    }\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/userViewModel.kt b/app/src/main/java/com/android/bookswap/model/userViewModel.kt
--- a/app/src/main/java/com/android/bookswap/model/userViewModel.kt	
+++ b/app/src/main/java/com/android/bookswap/model/userViewModel.kt	
@@ -5,9 +5,10 @@
 import com.android.bookswap.data.repository.UsersRepository
 import com.android.bookswap.data.source.network.UserFirestoreSource
 import com.google.firebase.firestore.FirebaseFirestore
+import java.util.UUID
 
 open class UserViewModel(
-    var uuid: String = "ERROR_UUID",
+    var uuid: UUID,
     repository: UsersRepository = UserFirestoreSource(FirebaseFirestore.getInstance())
 ) : ViewModel() {
   private var dataUser = DataUser(uuid)
@@ -40,15 +41,28 @@
       phone: String = dataUser.phoneNumber,
       latitude: Double = dataUser.latitude,
       longitude: Double = dataUser.longitude,
-      picURL: String = dataUser.profilePictureUrl
+      picURL: String = dataUser.profilePictureUrl,
+      bookList: List<UUID> = dataUser.bookList,
+      googleUid: String = dataUser.googleUid
   ) {
     updateUser(
-        DataUser(greeting, firstName, lastName, email, phone, latitude, longitude, picURL, uuid))
+        DataUser(
+            uuid,
+            greeting,
+            firstName,
+            lastName,
+            email,
+            phone,
+            latitude,
+            longitude,
+            picURL,
+            bookList,
+            googleUid))
   }
 
   fun updateUser(newDataUser: DataUser) {
     this.dataUser = newDataUser
-    this.uuid = newDataUser.userId
+    this.uuid = newDataUser.userUUID
     isLoaded = true
     userRepository.updateUser(dataUser) { result ->
       result.fold({ isStored = true }, { isStored = false })
Index: app/src/main/java/com/android/bookswap/data/DataUser.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.data\n\ndata class DataUser(\n    var greeting: String = \"\",\n    var firstName: String = \"\",\n    var lastName: String = \"\",\n    var email: String = \"\",\n    var phoneNumber: String = \"\",\n    var latitude: Double = 0.0,\n    var longitude: Double = 0.0,\n    var profilePictureUrl: String = \"\",\n    var userId: String = \"\"\n) {\n\n  fun printFullname(): String {\n    return \"$greeting $firstName $lastName\"\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/DataUser.kt b/app/src/main/java/com/android/bookswap/data/DataUser.kt
--- a/app/src/main/java/com/android/bookswap/data/DataUser.kt	
+++ b/app/src/main/java/com/android/bookswap/data/DataUser.kt	
@@ -1,6 +1,9 @@
 package com.android.bookswap.data
 
+import java.util.UUID
+
 data class DataUser(
+    var userUUID: UUID = UUID.randomUUID(),
     var greeting: String = "",
     var firstName: String = "",
     var lastName: String = "",
@@ -9,7 +12,8 @@
     var latitude: Double = 0.0,
     var longitude: Double = 0.0,
     var profilePictureUrl: String = "",
-    var userId: String = ""
+    var bookList: List<UUID> = emptyList(),
+    var googleUid: String = ""
 ) {
 
   fun printFullname(): String {
Index: app/src/androidTest/java/com/android/bookswap/endtoend/NavigationBarEndToEnd.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.endtoend\n\nimport androidx.compose.ui.test.junit4.createComposeRule\nimport androidx.compose.ui.test.onNodeWithTag\nimport androidx.compose.ui.test.performClick\nimport com.android.bookswap.MainActivity\nimport com.android.bookswap.data.source.network.BooksFirestoreRepository\nimport com.android.bookswap.data.source.network.MessageFirestoreSource\nimport com.android.bookswap.ui.navigation.Route\nimport com.google.firebase.firestore.FirebaseFirestore\nimport org.junit.Before\nimport org.junit.Rule\nimport org.junit.Test\n\nclass NavigationBarEndToEnd {\n  @get:Rule val composeTestRule = createComposeRule()\n\n  @Before\n  fun setUp() {\n\n    composeTestRule.setContent {\n      val db = FirebaseFirestore.getInstance()\n\n      val messageRepository = MessageFirestoreSource(db)\n      val bookRepository = BooksFirestoreRepository(db)\n      MainActivity().BookSwapApp(messageRepository, bookRepository, Route.MAP)\n    }\n  }\n\n  @Test\n  fun testNavigationBar() {\n    // Click on the Add Book tab and check if the AddToBookScreen is displayed\n    composeTestRule.onNodeWithTag(\"New Book\").assertExists().performClick()\n    composeTestRule.onNodeWithTag(\"addBookChoiceScreen\").assertExists()\n\n    // Click on the Chat tab and check if the ListChatScreen is displayed\n    composeTestRule.onNodeWithTag(\"Chat\").assertExists().performClick()\n    composeTestRule.onNodeWithTag(\"chat_listScreen\").assertExists()\n\n    // Click on the Map tab and check if the MapScreen is displayed\n    composeTestRule.onNodeWithTag(\"Map\").assertExists().performClick()\n    composeTestRule.onNodeWithTag(\"mapScreen\").assertExists()\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/endtoend/NavigationBarEndToEnd.kt b/app/src/androidTest/java/com/android/bookswap/endtoend/NavigationBarEndToEnd.kt
--- a/app/src/androidTest/java/com/android/bookswap/endtoend/NavigationBarEndToEnd.kt	
+++ b/app/src/androidTest/java/com/android/bookswap/endtoend/NavigationBarEndToEnd.kt	
@@ -4,10 +4,15 @@
 import androidx.compose.ui.test.onNodeWithTag
 import androidx.compose.ui.test.performClick
 import com.android.bookswap.MainActivity
-import com.android.bookswap.data.source.network.BooksFirestoreRepository
+import com.android.bookswap.data.repository.BooksRepository
+import com.android.bookswap.data.repository.UsersRepository
 import com.android.bookswap.data.source.network.MessageFirestoreSource
 import com.android.bookswap.ui.navigation.Route
 import com.google.firebase.firestore.FirebaseFirestore
+import io.mockk.every
+import io.mockk.just
+import io.mockk.mockk
+import io.mockk.runs
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
@@ -15,15 +20,22 @@
 class NavigationBarEndToEnd {
   @get:Rule val composeTestRule = createComposeRule()
 
+  private lateinit var mockBookRepository: BooksRepository
+  private lateinit var mockUserRepository: UsersRepository
+
   @Before
   fun setUp() {
+    mockBookRepository = mockk()
+    every { mockBookRepository.getBook(any()) } just runs
+    mockUserRepository = mockk()
+    every { mockUserRepository.getUsers(any()) } just runs
 
     composeTestRule.setContent {
       val db = FirebaseFirestore.getInstance()
 
       val messageRepository = MessageFirestoreSource(db)
-      val bookRepository = BooksFirestoreRepository(db)
-      MainActivity().BookSwapApp(messageRepository, bookRepository, Route.MAP)
+      MainActivity()
+          .BookSwapApp(messageRepository, mockBookRepository, mockUserRepository, Route.MAP)
     }
   }
 
Index: app/src/main/java/com/android/bookswap/ui/books/add/BookAdditionChoiceScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.books.add\r\n\r\nimport androidx.compose.foundation.BorderStroke\r\nimport androidx.compose.foundation.Image\r\nimport androidx.compose.foundation.background\r\nimport androidx.compose.foundation.layout.*\r\nimport androidx.compose.foundation.shape.RoundedCornerShape\r\nimport androidx.compose.material.icons.Icons\r\nimport androidx.compose.material.icons.automirrored.filled.ArrowForward\r\nimport androidx.compose.material.icons.filled.Add\r\nimport androidx.compose.material.icons.filled.ArrowForward\r\nimport androidx.compose.material3.Button\r\nimport androidx.compose.material3.ButtonDefaults\r\nimport androidx.compose.material3.ExperimentalMaterial3Api\r\nimport androidx.compose.material3.Icon\r\nimport androidx.compose.material3.Scaffold\r\nimport androidx.compose.material3.Text\r\nimport androidx.compose.material3.TopAppBar\r\nimport androidx.compose.material3.TopAppBarDefaults\r\nimport androidx.compose.runtime.Composable\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport androidx.compose.ui.graphics.painter.Painter\r\nimport androidx.compose.ui.graphics.vector.ImageVector\r\nimport androidx.compose.ui.platform.LocalConfiguration\r\nimport androidx.compose.ui.platform.testTag\r\nimport androidx.compose.ui.res.painterResource\r\nimport androidx.compose.ui.unit.Dp\r\nimport androidx.compose.ui.unit.dp\r\nimport androidx.compose.ui.unit.sp\r\nimport androidx.compose.ui.unit.times\r\nimport com.android.bookswap.R\r\nimport com.android.bookswap.ui.components.BackButtonComponent\r\nimport com.android.bookswap.ui.navigation.BottomNavigationMenu\r\nimport com.android.bookswap.ui.navigation.List_Navigation_Bar_Destinations\r\nimport com.android.bookswap.ui.navigation.NavigationActions\r\nimport com.android.bookswap.ui.profile.ProfileIcon\r\nimport com.android.bookswap.ui.theme.ColorVariable\r\n\r\n@OptIn(ExperimentalMaterial3Api::class)\r\n@Composable\r\nfun BookAdditionChoiceScreen(navController: NavigationActions) {\r\n  val columnPadding = 16.dp\r\n  val buttonWidth = (LocalConfiguration.current.screenWidthDp.dp * (0.75f))\r\n  Scaffold(\r\n      modifier = Modifier.testTag(\"addBookChoiceScreen\"),\r\n      topBar = {\r\n        TopAppBar(\r\n            title = { Text(\"Book Addition Choice\", color = ColorVariable.BackGround) },\r\n            navigationIcon = { BackButtonComponent(navController) },\r\n            actions = { ProfileIcon() },\r\n            colors = TopAppBarDefaults.topAppBarColors(containerColor = ColorVariable.BackGround))\r\n      },\r\n      bottomBar = {\r\n        BottomNavigationMenu(\r\n            onTabSelect = { destination -> navController.navigateTo(destination) },\r\n            tabList = List_Navigation_Bar_Destinations,\r\n            selectedItem = navController.currentRoute())\r\n      }) { innerPadding ->\r\n        Column(\r\n            modifier =\r\n                Modifier.padding(innerPadding)\r\n                    .fillMaxSize()\r\n                    .background(ColorVariable.BackGround)\r\n                    .padding(bottom = 10f * columnPadding, top = columnPadding),\r\n            verticalArrangement = Arrangement.Center,\r\n            horizontalAlignment = Alignment.CenterHorizontally) {\r\n              ButtonWithIcon(\r\n                  text = \"Manually\",\r\n                  leftIcon = Icons.Default.Add,\r\n                  leftIconPainter = null,\r\n                  navController = navController,\r\n                  navDestination = \"AddBookManually Screen\",\r\n                  buttonWidth = buttonWidth)\r\n              Spacer(modifier = Modifier.height(2f * columnPadding))\r\n              ButtonWithIcon(\r\n                  text = \"From ISBN\",\r\n                  leftIcon = null,\r\n                  leftIconPainter = painterResource(id = R.drawable.download),\r\n                  navController = navController,\r\n                  navDestination = \"AddBookISBN Screen\",\r\n                  buttonWidth = buttonWidth)\r\n              Spacer(modifier = Modifier.height(2f * columnPadding))\r\n              ButtonWithIcon(\r\n                  text = \"From Photo\",\r\n                  leftIcon = null,\r\n                  leftIconPainter = painterResource(id = R.drawable.photoicon),\r\n                  navController = navController,\r\n                  navDestination = \"AddBookScan Screen\",\r\n                  buttonWidth = buttonWidth)\r\n            }\r\n      }\r\n}\r\n\r\n@Composable\r\nfun ButtonWithIcon(\r\n    text: String,\r\n    leftIcon: ImageVector? = null,\r\n    leftIconPainter: Painter? = null,\r\n    navController: NavigationActions,\r\n    navDestination: String,\r\n    buttonWidth: Dp\r\n) {\r\n  val borderPadding = 1.dp\r\n  val buttonPadding = 8.dp\r\n  val iconSize = 32.dp\r\n  val pngSize = 24.dp\r\n  val textSize = 18.sp\r\n  Button(\r\n      onClick = { navController.navigateTo(navDestination) },\r\n      colors =\r\n          ButtonDefaults.buttonColors(\r\n              containerColor = ColorVariable.AccentSecondary,\r\n              contentColor = ColorVariable.BackGround),\r\n      border = BorderStroke(borderPadding, ColorVariable.Accent),\r\n      shape = RoundedCornerShape(buttonPadding),\r\n      modifier = Modifier.padding(buttonPadding).width(buttonWidth).testTag(\"button_$text\")) {\r\n        Row(\r\n            modifier = Modifier.fillMaxWidth(),\r\n            horizontalArrangement = Arrangement.SpaceBetween,\r\n            verticalAlignment = Alignment.CenterVertically) {\r\n              if (leftIcon != null) {\r\n                Icon(\r\n                    imageVector = leftIcon,\r\n                    contentDescription = null,\r\n                    modifier = Modifier.size(iconSize).testTag(\"leftIcon_$text\"))\r\n              } else if (leftIconPainter != null) {\r\n                Image(\r\n                    painter = leftIconPainter,\r\n                    contentDescription = null,\r\n                    modifier = Modifier.size(pngSize).testTag(\"leftPngIcon_$text\"))\r\n              }\r\n              Text(text, fontSize = textSize)\r\n              Icon(\r\n                  imageVector = Icons.AutoMirrored.Filled.ArrowForward,\r\n                  contentDescription = null,\r\n                  modifier = Modifier.size(iconSize).testTag(\"rightIcon_$text\"))\r\n            }\r\n      }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/books/add/BookAdditionChoiceScreen.kt b/app/src/main/java/com/android/bookswap/ui/books/add/BookAdditionChoiceScreen.kt
--- a/app/src/main/java/com/android/bookswap/ui/books/add/BookAdditionChoiceScreen.kt	
+++ b/app/src/main/java/com/android/bookswap/ui/books/add/BookAdditionChoiceScreen.kt	
@@ -15,8 +15,6 @@
 import androidx.compose.material3.Icon
 import androidx.compose.material3.Scaffold
 import androidx.compose.material3.Text
-import androidx.compose.material3.TopAppBar
-import androidx.compose.material3.TopAppBarDefaults
 import androidx.compose.runtime.Composable
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
@@ -30,33 +28,22 @@
 import androidx.compose.ui.unit.sp
 import androidx.compose.ui.unit.times
 import com.android.bookswap.R
-import com.android.bookswap.ui.components.BackButtonComponent
-import com.android.bookswap.ui.navigation.BottomNavigationMenu
-import com.android.bookswap.ui.navigation.List_Navigation_Bar_Destinations
 import com.android.bookswap.ui.navigation.NavigationActions
-import com.android.bookswap.ui.profile.ProfileIcon
 import com.android.bookswap.ui.theme.ColorVariable
 
 @OptIn(ExperimentalMaterial3Api::class)
 @Composable
-fun BookAdditionChoiceScreen(navController: NavigationActions) {
+fun BookAdditionChoiceScreen(
+    navController: NavigationActions,
+    topAppBar: @Composable () -> Unit = {},
+    bottomAppBar: @Composable () -> Unit = {},
+) {
   val columnPadding = 16.dp
   val buttonWidth = (LocalConfiguration.current.screenWidthDp.dp * (0.75f))
   Scaffold(
       modifier = Modifier.testTag("addBookChoiceScreen"),
-      topBar = {
-        TopAppBar(
-            title = { Text("Book Addition Choice", color = ColorVariable.BackGround) },
-            navigationIcon = { BackButtonComponent(navController) },
-            actions = { ProfileIcon() },
-            colors = TopAppBarDefaults.topAppBarColors(containerColor = ColorVariable.BackGround))
-      },
-      bottomBar = {
-        BottomNavigationMenu(
-            onTabSelect = { destination -> navController.navigateTo(destination) },
-            tabList = List_Navigation_Bar_Destinations,
-            selectedItem = navController.currentRoute())
-      }) { innerPadding ->
+      topBar = topAppBar,
+      bottomBar = bottomAppBar) { innerPadding ->
         Column(
             modifier =
                 Modifier.padding(innerPadding)
Index: app/src/main/java/com/android/bookswap/ui/profile/UserProfile.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.profile\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.aspectRatio\nimport androidx.compose.foundation.layout.consumeWindowInsets\nimport androidx.compose.foundation.layout.fillMaxHeight\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.shape.CircleShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.sharp.ArrowBack\nimport androidx.compose.material.icons.outlined.Edit\nimport androidx.compose.material.icons.rounded.AccountCircle\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clipToBounds\nimport androidx.compose.ui.draw.scale\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.ColorFilter\nimport androidx.compose.ui.platform.testTag\nimport androidx.compose.ui.unit.dp\nimport com.android.bookswap.model.UserViewModel\nimport com.android.bookswap.ui.components.ButtonComponent\nimport com.android.bookswap.ui.theme.*\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun UserProfile(userVM: UserViewModel = UserViewModel()) {\n\n  var user = userVM.getUser()\n  var showEditProfile by remember { mutableStateOf(false) }\n\n  var needRecompose by remember { mutableStateOf(false) }\n\n  if (showEditProfile) {\n    EditProfileDialog(\n        onDismiss = {\n          showEditProfile = false\n          needRecompose = true\n        },\n        onSave = {\n          userVM.updateUser(\n              greeting = it.greeting,\n              firstName = it.firstName,\n              lastName = it.lastName,\n              email = it.email,\n              phone = it.phoneNumber,\n              user.latitude,\n              user.longitude,\n              picURL = user.profilePictureUrl)\n          showEditProfile = false\n          needRecompose = true\n        },\n        dataUser = user)\n  }\n\n  LaunchedEffect(userVM.uuid, needRecompose) {\n    user = userVM.getUser()\n    needRecompose = false\n  }\n\n  BookSwapAppTheme() {\n\n    // Scaffold to provide basic UI structure with a top app bar\n    Scaffold(\n        modifier = Modifier.testTag(\"profileScreenContainer\"),\n        topBar = {\n          TopAppBar(\n              modifier = Modifier.testTag(\"profileTopAppBar\"),\n              // Title of the screen\n              title = { Text(\"Your Profile\", modifier = Modifier.testTag(\"profileTitleTxt\")) },\n              // Icon button for navigation (currently no action defined)\n              navigationIcon = {\n                IconButton(modifier = Modifier.size(32.dp), onClick = {}) {\n                  Icon(\n                      imageVector = Icons.AutoMirrored.Sharp.ArrowBack,\n                      contentDescription = \"\",\n                      modifier = Modifier.size(30.dp))\n                }\n              })\n        }) {\n          // Column layout to stack input fields vertically with spacing\n          Row(\n              modifier = Modifier.padding(it).consumeWindowInsets(it).fillMaxWidth(),\n              horizontalArrangement = Arrangement.spacedBy(5f.dp)) {\n                Column(modifier = Modifier.fillMaxWidth(0.25f)) {\n                  Box {\n                    IconButton(\n                        onClick = { /*TODO: Edit profile picture*/},\n                        modifier = Modifier.aspectRatio(1f)) {\n                          Box(\n                              modifier =\n                                  Modifier.padding(2.5f.dp)\n                                      .border(3.5f.dp, Color(0xFFA98467), CircleShape)) {\n                                Image(\n                                    imageVector = Icons.Rounded.AccountCircle,\n                                    contentDescription = \"\",\n                                    modifier = Modifier.fillMaxSize().scale(1.2f).clipToBounds(),\n                                    colorFilter = ColorFilter.tint(Color(0xFF6C584C)))\n                              }\n                          Box(\n                              modifier = Modifier.fillMaxSize().padding(0f.dp),\n                              contentAlignment = Alignment.TopEnd) {\n                                Image(\n                                    imageVector = Icons.Outlined.Edit,\n                                    contentDescription = \"\",\n                                    colorFilter = ColorFilter.tint(Color(0xFFAAAAAA)))\n                              }\n                        }\n                  }\n                }\n                Column(Modifier.fillMaxHeight().fillMaxWidth(), Arrangement.spacedBy(8.dp)) {\n                  // Full name text\n                  Text(\n                      text = \"${user.greeting} ${user.firstName} ${user.lastName}\",\n                      modifier = Modifier.testTag(\"fullNameTxt\"))\n\n                  // Email text\n                  Text(text = user.email, modifier = Modifier.testTag(\"emailTxt\"))\n\n                  // Phone number text\n                  Text(text = user.phoneNumber, modifier = Modifier.testTag(\"phoneNumberTxt\"))\n\n                  // User address\n                  Text(\n                      text = \"${user.latitude}, ${user.longitude}\",\n                      modifier = Modifier.testTag(\"addressTxt\"))\n\n                  // Edit Button\n                  ButtonComponent({ showEditProfile = true }, Modifier.testTag(\"editProfileBtn\")) {\n                    Text(\"Edit Profile\")\n                  }\n                }\n              }\n        }\n  }\n}\n\n// @Preview(showBackground = true, widthDp = 540, heightDp = 1110)\n// @Composable\n// fun UserProfilePreview() {\n//  val userVM = UserViewModel(\"\")\n//  userVM.updateUser(\n//    DataUser(\n//      \"M.\",\n//      \"John\",\n//      \"Doe\",\n//      \"John.Doe@example.com\",\n//      \"+41223456789\",\n//      0.0,\n//      0.0,\n//      \"dummyPic.png\",\n//      \"dummyUUID0000\")\n//  )\n//  UserProfile(userVM)\n// }\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/profile/UserProfile.kt b/app/src/main/java/com/android/bookswap/ui/profile/UserProfile.kt
--- a/app/src/main/java/com/android/bookswap/ui/profile/UserProfile.kt	
+++ b/app/src/main/java/com/android/bookswap/ui/profile/UserProfile.kt	
@@ -11,10 +11,8 @@
 import androidx.compose.foundation.layout.fillMaxSize
 import androidx.compose.foundation.layout.fillMaxWidth
 import androidx.compose.foundation.layout.padding
-import androidx.compose.foundation.layout.size
 import androidx.compose.foundation.shape.CircleShape
 import androidx.compose.material.icons.Icons
-import androidx.compose.material.icons.automirrored.sharp.ArrowBack
 import androidx.compose.material.icons.outlined.Edit
 import androidx.compose.material.icons.rounded.AccountCircle
 import androidx.compose.material3.*
@@ -31,9 +29,12 @@
 import com.android.bookswap.ui.components.ButtonComponent
 import com.android.bookswap.ui.theme.*
 
-@OptIn(ExperimentalMaterial3Api::class)
 @Composable
-fun UserProfile(userVM: UserViewModel = UserViewModel()) {
+fun UserProfile(
+    userVM: UserViewModel = UserViewModel(java.util.UUID.randomUUID()),
+    topAppBar: @Composable () -> Unit = {},
+    bottomAppBar: @Composable () -> Unit = {}
+) {
 
   var user = userVM.getUser()
   var showEditProfile by remember { mutableStateOf(false) }
@@ -67,81 +68,65 @@
     needRecompose = false
   }
 
-  BookSwapAppTheme() {
-
-    // Scaffold to provide basic UI structure with a top app bar
-    Scaffold(
-        modifier = Modifier.testTag("profileScreenContainer"),
-        topBar = {
-          TopAppBar(
-              modifier = Modifier.testTag("profileTopAppBar"),
-              // Title of the screen
-              title = { Text("Your Profile", modifier = Modifier.testTag("profileTitleTxt")) },
-              // Icon button for navigation (currently no action defined)
-              navigationIcon = {
-                IconButton(modifier = Modifier.size(32.dp), onClick = {}) {
-                  Icon(
-                      imageVector = Icons.AutoMirrored.Sharp.ArrowBack,
-                      contentDescription = "",
-                      modifier = Modifier.size(30.dp))
-                }
-              })
-        }) {
-          // Column layout to stack input fields vertically with spacing
-          Row(
-              modifier = Modifier.padding(it).consumeWindowInsets(it).fillMaxWidth(),
-              horizontalArrangement = Arrangement.spacedBy(5f.dp)) {
-                Column(modifier = Modifier.fillMaxWidth(0.25f)) {
-                  Box {
-                    IconButton(
-                        onClick = { /*TODO: Edit profile picture*/},
-                        modifier = Modifier.aspectRatio(1f)) {
-                          Box(
-                              modifier =
-                                  Modifier.padding(2.5f.dp)
-                                      .border(3.5f.dp, Color(0xFFA98467), CircleShape)) {
-                                Image(
-                                    imageVector = Icons.Rounded.AccountCircle,
-                                    contentDescription = "",
-                                    modifier = Modifier.fillMaxSize().scale(1.2f).clipToBounds(),
-                                    colorFilter = ColorFilter.tint(Color(0xFF6C584C)))
-                              }
-                          Box(
-                              modifier = Modifier.fillMaxSize().padding(0f.dp),
-                              contentAlignment = Alignment.TopEnd) {
-                                Image(
-                                    imageVector = Icons.Outlined.Edit,
-                                    contentDescription = "",
-                                    colorFilter = ColorFilter.tint(Color(0xFFAAAAAA)))
-                              }
-                        }
-                  }
-                }
-                Column(Modifier.fillMaxHeight().fillMaxWidth(), Arrangement.spacedBy(8.dp)) {
-                  // Full name text
-                  Text(
-                      text = "${user.greeting} ${user.firstName} ${user.lastName}",
-                      modifier = Modifier.testTag("fullNameTxt"))
+  // Scaffold to provide basic UI structure with a top app bar
+  Scaffold(
+      modifier = Modifier.testTag("profileScreenContainer"),
+      topBar = topAppBar,
+      bottomBar = bottomAppBar) {
+        // Column layout to stack input fields vertically with spacing
+        Row(
+            modifier = Modifier.padding(it).consumeWindowInsets(it).fillMaxWidth(),
+            horizontalArrangement = Arrangement.spacedBy(5f.dp)) {
+              Column(modifier = Modifier.fillMaxWidth(0.25f)) {
+                Box {
+                  IconButton(
+                      onClick = { /*TODO: Edit profile picture*/},
+                      modifier = Modifier.aspectRatio(1f)) {
+                        Box(
+                            modifier =
+                                Modifier.padding(2.5f.dp)
+                                    .border(3.5f.dp, Color(0xFFA98467), CircleShape)) {
+                              Image(
+                                  imageVector = Icons.Rounded.AccountCircle,
+                                  contentDescription = "",
+                                  modifier = Modifier.fillMaxSize().scale(1.2f).clipToBounds(),
+                                  colorFilter = ColorFilter.tint(Color(0xFF6C584C)))
+                            }
+                        Box(
+                            modifier = Modifier.fillMaxSize().padding(0f.dp),
+                            contentAlignment = Alignment.TopEnd) {
+                              Image(
+                                  imageVector = Icons.Outlined.Edit,
+                                  contentDescription = "",
+                                  colorFilter = ColorFilter.tint(Color(0xFFAAAAAA)))
+                            }
+                      }
+                }
+              }
+              Column(Modifier.fillMaxHeight().fillMaxWidth(), Arrangement.spacedBy(8.dp)) {
+                // Full name text
+                Text(
+                    text = "${user.greeting} ${user.firstName} ${user.lastName}",
+                    modifier = Modifier.testTag("fullNameTxt"))
 
-                  // Email text
-                  Text(text = user.email, modifier = Modifier.testTag("emailTxt"))
+                // Email text
+                Text(text = user.email, modifier = Modifier.testTag("emailTxt"))
 
-                  // Phone number text
-                  Text(text = user.phoneNumber, modifier = Modifier.testTag("phoneNumberTxt"))
+                // Phone number text
+                Text(text = user.phoneNumber, modifier = Modifier.testTag("phoneNumberTxt"))
 
-                  // User address
-                  Text(
-                      text = "${user.latitude}, ${user.longitude}",
-                      modifier = Modifier.testTag("addressTxt"))
+                // User address
+                Text(
+                    text = "${user.latitude}, ${user.longitude}",
+                    modifier = Modifier.testTag("addressTxt"))
 
-                  // Edit Button
-                  ButtonComponent({ showEditProfile = true }, Modifier.testTag("editProfileBtn")) {
-                    Text("Edit Profile")
-                  }
+                // Edit Button
+                ButtonComponent({ showEditProfile = true }, Modifier.testTag("editProfileBtn")) {
+                  Text("Edit Profile")
                 }
               }
-        }
-  }
+            }
+      }
 }
 
 // @Preview(showBackground = true, widthDp = 540, heightDp = 1110)
Index: app/src/main/java/com/android/bookswap/MainActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Surface\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.semantics.semantics\nimport androidx.compose.ui.semantics.testTag\nimport androidx.navigation.compose.NavHost\nimport androidx.navigation.compose.composable\nimport androidx.navigation.compose.rememberNavController\nimport androidx.navigation.navigation\nimport com.android.bookswap.data.BookGenres\nimport com.android.bookswap.data.BookLanguages\nimport com.android.bookswap.data.DataBook\nimport com.android.bookswap.data.source.network.BooksFirestoreRepository\nimport com.android.bookswap.data.source.network.MessageFirestoreSource\nimport com.android.bookswap.model.chat.MessageBox\nimport com.android.bookswap.model.chat.PermissionHandler\nimport com.android.bookswap.model.map.BookFilter\nimport com.android.bookswap.model.map.DefaultGeolocation\nimport com.android.bookswap.model.map.Geolocation\nimport com.android.bookswap.model.map.IGeolocation\nimport com.android.bookswap.resources.C\nimport com.android.bookswap.ui.authentication.SignInScreen\nimport com.android.bookswap.ui.books.add.AddISBNScreen\nimport com.android.bookswap.ui.books.add.AddToBookScreen\nimport com.android.bookswap.ui.books.add.BookAdditionChoiceScreen\nimport com.android.bookswap.ui.chat.ChatScreen\nimport com.android.bookswap.ui.chat.ListChatScreen\nimport com.android.bookswap.ui.map.FilterMapScreen\nimport com.android.bookswap.ui.map.MapScreen\nimport com.android.bookswap.ui.map.TempUser\nimport com.android.bookswap.ui.navigation.NavigationActions\nimport com.android.bookswap.ui.navigation.Route\nimport com.android.bookswap.ui.navigation.Screen\nimport com.android.bookswap.ui.theme.BookSwapAppTheme\nimport com.google.firebase.firestore.FirebaseFirestore\nimport java.util.UUID\n\nclass MainActivity : ComponentActivity() {\n\n  private lateinit var permissionHandler: PermissionHandler\n\n  override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    // permissionHandler = PermissionHandler(this)\n    // permissionHandler.askNotificationPermission()\n\n    // Initialize Firebase Firestore\n    val db = FirebaseFirestore.getInstance()\n\n    // Create the MessageFirestoreSource object\n    val messageRepository = MessageFirestoreSource(db)\n    val bookRepository = BooksFirestoreRepository(db)\n\n    // Initialize the geolocation\n    val geolocation = Geolocation(this)\n\n    setContent {\n      BookSwapAppTheme {\n        // A surface container using the 'background' color from the theme\n        Surface(\n            modifier = Modifier.fillMaxSize().semantics { testTag = C.Tag.main_screen_container },\n            color = MaterialTheme.colorScheme.background) {\n              BookSwapApp(messageRepository, bookRepository, geolocation = geolocation)\n            }\n      }\n    }\n  }\n\n  @Composable\n  fun BookSwapApp(\n      messageRepository: MessageFirestoreSource,\n      bookRepository: BooksFirestoreRepository,\n      startDestination: String = Route.AUTH,\n      geolocation: IGeolocation = DefaultGeolocation()\n  ) {\n    val navController = rememberNavController()\n    val navigationActions = NavigationActions(navController)\n    val bookFilter = BookFilter()\n\n    val placeHolder =\n        listOf(\n            MessageBox(\n                contactName = \"user124\",\n                message = \"Welcome message for user124\",\n                date = \"01.01.24\")) +\n            List(6) {\n              MessageBox(\n                  contactName = \"Contact ${it + 1}\",\n                  message = \"Test message $it test for the feature of ellipsis in the message\",\n                  date = \"01.01.24\")\n            }\n\n    NavHost(navController = navController, startDestination = startDestination) {\n      navigation(startDestination = Screen.AUTH, route = Route.AUTH) {\n        composable(Screen.AUTH) { SignInScreen(navigationActions) }\n      }\n      navigation(startDestination = Screen.CHATLIST, route = Route.CHAT) {\n        composable(Screen.CHATLIST) { ListChatScreen(placeHolder, navigationActions) }\n        composable(\"${Screen.CHAT}/{user1}/{user2}\") { backStackEntry ->\n          val user1 = backStackEntry.arguments?.getString(\"user1\") ?: \"\"\n          val user2 = backStackEntry.arguments?.getString(\"user2\") ?: \"\"\n          ChatScreen(messageRepository, user1, user2, navigationActions)\n        }\n      }\n      navigation(startDestination = Screen.MAP, route = Route.MAP) {\n        composable(Screen.MAP) {\n          MapScreen(\n              user,\n              navigationActions = navigationActions,\n              bookFilter = bookFilter,\n              geolocation = geolocation)\n        }\n        composable(Screen.FILTER) { FilterMapScreen(navigationActions, bookFilter) }\n      }\n      navigation(startDestination = Screen.NEWBOOK, route = Route.NEWBOOK) {\n        composable(Screen.NEWBOOK) { BookAdditionChoiceScreen(navigationActions) }\n        composable(Screen.ADD_BOOK_MANUALLY) { AddToBookScreen(bookRepository, navigationActions) }\n        composable(Screen.ADD_BOOK_SCAN) { /*Todo*/}\n        composable(Screen.ADD_BOOK_ISBN) { AddISBNScreen(navigationActions, bookRepository) }\n      }\n    }\n  }\n}\n\n// Temporary user list for the map as it is not yet linked to the database.\n// Better to see how the map screen should look like at the end.\n// Need to be removed in the future.\nval user =\n    listOf(\n        TempUser(\n            latitude = 0.0,\n            longitude = 0.0,\n            listBook =\n                listOf(\n                    DataBook(\n                        uuid = UUID.randomUUID(),\n                        title = \"Book 1\",\n                        author = \"Author 1\",\n                        description = \"Description of Book 1\",\n                        rating = 5,\n                        photo = null,\n                        language = BookLanguages.ENGLISH,\n                        isbn = null,\n                        genres = listOf(BookGenres.FANTASY)),\n                    DataBook(\n                        uuid = UUID.randomUUID(),\n                        title = \"Book 2\",\n                        author = \"Author 2\",\n                        description = \"Description of Book 2\",\n                        rating = 4,\n                        photo = null,\n                        language = BookLanguages.FRENCH,\n                        isbn = null,\n                        genres = listOf(BookGenres.FICTION)),\n                    DataBook(\n                        uuid = UUID.randomUUID(),\n                        title = \"Book 3\",\n                        author = \"Author 3\",\n                        description = \"Description of Book 3\",\n                        rating = null,\n                        photo = null,\n                        language = BookLanguages.GERMAN,\n                        isbn = null,\n                        genres = listOf(BookGenres.SCIENCEFICTION, BookGenres.AUTOBIOGRAPHY)),\n                )))\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/MainActivity.kt b/app/src/main/java/com/android/bookswap/MainActivity.kt
--- a/app/src/main/java/com/android/bookswap/MainActivity.kt	
+++ b/app/src/main/java/com/android/bookswap/MainActivity.kt	
@@ -14,14 +14,18 @@
 import androidx.navigation.compose.composable
 import androidx.navigation.compose.rememberNavController
 import androidx.navigation.navigation
-import com.android.bookswap.data.BookGenres
-import com.android.bookswap.data.BookLanguages
-import com.android.bookswap.data.DataBook
-import com.android.bookswap.data.source.network.BooksFirestoreRepository
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.MessageBox
+import com.android.bookswap.data.repository.BooksRepository
+import com.android.bookswap.data.repository.MessageRepository
+import com.android.bookswap.data.repository.UsersRepository
+import com.android.bookswap.data.source.network.BooksFirestoreSource
 import com.android.bookswap.data.source.network.MessageFirestoreSource
-import com.android.bookswap.model.chat.MessageBox
+import com.android.bookswap.data.source.network.UserFirestoreSource
+import com.android.bookswap.model.UserViewModel
 import com.android.bookswap.model.chat.PermissionHandler
 import com.android.bookswap.model.map.BookFilter
+import com.android.bookswap.model.map.BookManagerViewModel
 import com.android.bookswap.model.map.DefaultGeolocation
 import com.android.bookswap.model.map.Geolocation
 import com.android.bookswap.model.map.IGeolocation
@@ -32,12 +36,15 @@
 import com.android.bookswap.ui.books.add.BookAdditionChoiceScreen
 import com.android.bookswap.ui.chat.ChatScreen
 import com.android.bookswap.ui.chat.ListChatScreen
+import com.android.bookswap.ui.components.TopAppBarComponent
 import com.android.bookswap.ui.map.FilterMapScreen
 import com.android.bookswap.ui.map.MapScreen
-import com.android.bookswap.ui.map.TempUser
+import com.android.bookswap.ui.navigation.BottomNavigationMenu
+import com.android.bookswap.ui.navigation.List_Navigation_Bar_Destinations
 import com.android.bookswap.ui.navigation.NavigationActions
 import com.android.bookswap.ui.navigation.Route
 import com.android.bookswap.ui.navigation.Screen
+import com.android.bookswap.ui.profile.UserProfile
 import com.android.bookswap.ui.theme.BookSwapAppTheme
 import com.google.firebase.firestore.FirebaseFirestore
 import java.util.UUID
@@ -50,123 +57,173 @@
     super.onCreate(savedInstanceState)
     // permissionHandler = PermissionHandler(this)
     // permissionHandler.askNotificationPermission()
+    setContent { BookSwapApp() }
+  }
 
-    // Initialize Firebase Firestore
+  @Composable
+  fun BookSwapApp() {
+
+    // Initialize a Firebase Firestore database instance
     val db = FirebaseFirestore.getInstance()
 
-    // Create the MessageFirestoreSource object
+    // Create the data source objects
     val messageRepository = MessageFirestoreSource(db)
-    val bookRepository = BooksFirestoreRepository(db)
+    val bookRepository = BooksFirestoreSource(db)
+    val userDataSource = UserFirestoreSource(db)
 
     // Initialize the geolocation
     val geolocation = Geolocation(this)
-
-    setContent {
-      BookSwapAppTheme {
-        // A surface container using the 'background' color from the theme
-        Surface(
-            modifier = Modifier.fillMaxSize().semantics { testTag = C.Tag.main_screen_container },
-            color = MaterialTheme.colorScheme.background) {
-              BookSwapApp(messageRepository, bookRepository, geolocation = geolocation)
-            }
-      }
+    BookSwapAppTheme {
+      // A surface container using the 'background' color from the theme
+      Surface(
+          modifier = Modifier.fillMaxSize().semantics { testTag = C.Tag.main_screen_container },
+          color = MaterialTheme.colorScheme.background) {
+            BookSwapApp(
+                messageRepository, bookRepository, userDataSource, geolocation = geolocation)
+          }
     }
   }
 
   @Composable
   fun BookSwapApp(
-      messageRepository: MessageFirestoreSource,
-      bookRepository: BooksFirestoreRepository,
+      messageRepository: MessageRepository,
+      bookRepository: BooksRepository,
+      userRepository: UsersRepository,
       startDestination: String = Route.AUTH,
       geolocation: IGeolocation = DefaultGeolocation()
   ) {
     val navController = rememberNavController()
     val navigationActions = NavigationActions(navController)
     val bookFilter = BookFilter()
+    val userVM = UserViewModel(UUID.randomUUID(), userRepository)
+    val bookManagerViewModel =
+        BookManagerViewModel(geolocation, bookRepository, userRepository, bookFilter)
 
+    val currentUserUUID = UUID.fromString("550e8400-e29b-41d4-a716-446655440000")
+    val otherUserUUID = UUID.fromString("550e8400-e29b-41d4-a716-446655440001")
+    val currentUser =
+        DataUser(
+            currentUserUUID,
+            "Hello",
+            "Jaime",
+            "Oliver Pastor",
+            "",
+            "",
+            42.5717,
+            0.5471,
+            "https://media.istockphoto.com/id/693813718/photo/the-fortress-of-jaca-soain.jpg?s=612x612&w=0&k=20&c=MdnKl1VJIKQRwGdrGwBFx_L00vS8UVphR9J-nS6J90c=",
+            emptyList(),
+            "googleUid")
+
+    val otherUser =
+        DataUser(
+            otherUserUUID,
+            "Hey",
+            "Tho",
+            "Schlaeppi",
+            "",
+            "",
+            46.3,
+            6.43,
+            "https://www.shutterstock.com/image-photo/wonderful-epesses-fairtytale-village-middle-600nw-2174791585.jpg",
+            emptyList(),
+            "googleUid")
     val placeHolder =
-        listOf(
-            MessageBox(
-                contactName = "user124",
-                message = "Welcome message for user124",
-                date = "01.01.24")) +
+        listOf(MessageBox(otherUser, message = "Welcome message for user124", date = "01.01.24")) +
             List(6) {
               MessageBox(
-                  contactName = "Contact ${it + 1}",
+                  DataUser(
+                      UUID.randomUUID(),
+                      "Hello",
+                      "First ${it + 1}",
+                      "Last ${it + 1}",
+                      "",
+                      "",
+                      0.0,
+                      0.0,
+                      "",
+                      emptyList(),
+                      "googleUid"),
                   message = "Test message $it test for the feature of ellipsis in the message",
                   date = "01.01.24")
             }
+    val topAppBar =
+        @Composable { s: String? ->
+          TopAppBarComponent(
+              modifier = Modifier,
+              navigationActions = navigationActions,
+              title = s ?: navigationActions.currentRoute())
+        }
+    val bottomAppBar =
+        @Composable { s: String? ->
+          BottomNavigationMenu(
+              onTabSelect = { destination -> navigationActions.navigateTo(destination) },
+              tabList = List_Navigation_Bar_Destinations,
+              selectedItem = s ?: "")
+        }
 
     NavHost(navController = navController, startDestination = startDestination) {
       navigation(startDestination = Screen.AUTH, route = Route.AUTH) {
         composable(Screen.AUTH) { SignInScreen(navigationActions) }
       }
       navigation(startDestination = Screen.CHATLIST, route = Route.CHAT) {
-        composable(Screen.CHATLIST) { ListChatScreen(placeHolder, navigationActions) }
-        composable("${Screen.CHAT}/{user1}/{user2}") { backStackEntry ->
-          val user1 = backStackEntry.arguments?.getString("user1") ?: ""
-          val user2 = backStackEntry.arguments?.getString("user2") ?: ""
-          ChatScreen(messageRepository, user1, user2, navigationActions)
+        composable(Screen.CHATLIST) {
+          ListChatScreen(
+              placeHolder,
+              navigationActions,
+              topAppBar = { topAppBar("Messages") },
+              bottomAppBar = { bottomAppBar(this@navigation.route ?: "") })
+        }
+        composable("${Screen.CHAT}/{user2}") { backStackEntry ->
+          val user2UUID = UUID.fromString(backStackEntry.arguments?.getString("user2"))
+          val user2 = placeHolder.firstOrNull { it.contact.userUUID == user2UUID }?.contact
+
+          if (user2 != null) {
+            ChatScreen(messageRepository, currentUser, user2, navigationActions)
+          } else {
+            BookAdditionChoiceScreen(
+                navigationActions,
+                topAppBar = { topAppBar("Add a Book") },
+                bottomAppBar = { bottomAppBar(this@navigation.route ?: "") })
+          }
         }
       }
       navigation(startDestination = Screen.MAP, route = Route.MAP) {
         composable(Screen.MAP) {
           MapScreen(
-              user,
+              bookManagerViewModel,
               navigationActions = navigationActions,
-              bookFilter = bookFilter,
-              geolocation = geolocation)
+              geolocation = geolocation,
+              topAppBar = { topAppBar("Map") },
+              bottomAppBar = { bottomAppBar(this@navigation.route ?: "") })
         }
         composable(Screen.FILTER) { FilterMapScreen(navigationActions, bookFilter) }
       }
       navigation(startDestination = Screen.NEWBOOK, route = Route.NEWBOOK) {
-        composable(Screen.NEWBOOK) { BookAdditionChoiceScreen(navigationActions) }
-        composable(Screen.ADD_BOOK_MANUALLY) { AddToBookScreen(bookRepository, navigationActions) }
+        composable(Screen.NEWBOOK) {
+          BookAdditionChoiceScreen(
+              navigationActions,
+              topAppBar = { topAppBar("Add a Book") },
+              bottomAppBar = { bottomAppBar(this@navigation.route ?: "") })
+        }
+        composable(Screen.ADD_BOOK_MANUALLY) {
+          AddToBookScreen(
+              bookRepository,
+              topAppBar = { topAppBar(null) },
+              bottomAppBar = { bottomAppBar(this@navigation.route ?: "") })
+        }
         composable(Screen.ADD_BOOK_SCAN) { /*Todo*/}
-        composable(Screen.ADD_BOOK_ISBN) { AddISBNScreen(navigationActions, bookRepository) }
+        composable(Screen.ADD_BOOK_ISBN) {
+          AddISBNScreen(
+              navigationActions,
+              bookRepository,
+              topAppBar = { topAppBar(null) },
+              bottomAppBar = { bottomAppBar(this@navigation.route ?: "") })
+        }
       }
+      navigation(startDestination = Screen.PROFILE, route = Route.PROFILE) {
+        composable(Screen.PROFILE) { UserProfile(userVM) }
+      }
     }
   }
 }
-
-// Temporary user list for the map as it is not yet linked to the database.
-// Better to see how the map screen should look like at the end.
-// Need to be removed in the future.
-val user =
-    listOf(
-        TempUser(
-            latitude = 0.0,
-            longitude = 0.0,
-            listBook =
-                listOf(
-                    DataBook(
-                        uuid = UUID.randomUUID(),
-                        title = "Book 1",
-                        author = "Author 1",
-                        description = "Description of Book 1",
-                        rating = 5,
-                        photo = null,
-                        language = BookLanguages.ENGLISH,
-                        isbn = null,
-                        genres = listOf(BookGenres.FANTASY)),
-                    DataBook(
-                        uuid = UUID.randomUUID(),
-                        title = "Book 2",
-                        author = "Author 2",
-                        description = "Description of Book 2",
-                        rating = 4,
-                        photo = null,
-                        language = BookLanguages.FRENCH,
-                        isbn = null,
-                        genres = listOf(BookGenres.FICTION)),
-                    DataBook(
-                        uuid = UUID.randomUUID(),
-                        title = "Book 3",
-                        author = "Author 3",
-                        description = "Description of Book 3",
-                        rating = null,
-                        photo = null,
-                        language = BookLanguages.GERMAN,
-                        isbn = null,
-                        genres = listOf(BookGenres.SCIENCEFICTION, BookGenres.AUTOBIOGRAPHY)),
-                )))
Index: app/src/main/java/com/android/bookswap/ui/books/add/AddToBook.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.books.add\n\nimport android.content.Context\nimport android.util.Log\nimport android.widget.Toast\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.DropdownMenuItem\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.ExposedDropdownMenuBox\nimport androidx.compose.material3.ExposedDropdownMenuDefaults\nimport androidx.compose.material3.OutlinedTextField\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TextFieldDefaults\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.platform.testTag\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport com.android.bookswap.data.BookGenres\nimport com.android.bookswap.data.BookLanguages\nimport com.android.bookswap.data.DataBook\nimport com.android.bookswap.data.repository.BooksRepository\nimport com.android.bookswap.ui.components.BackButtonComponent\nimport com.android.bookswap.ui.navigation.NavigationActions\nimport com.android.bookswap.ui.theme.ColorVariable\nimport com.android.bookswap.ui.theme.ColorVariable.Accent\nimport com.android.bookswap.ui.theme.ColorVariable.BackGround\nimport com.android.bookswap.ui.theme.ColorVariable.Primary\nimport com.android.bookswap.ui.theme.ColorVariable.Secondary\nimport java.util.UUID\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun AddToBookScreen(repository: BooksRepository, navController: NavigationActions) {\n  // State variables to store the values entered by the user\n  var title by remember { mutableStateOf(\"\") }\n  var author by remember { mutableStateOf(\"\") }\n  var description by remember { mutableStateOf(\"\") }\n  var rating by remember { mutableStateOf(\"\") }\n  var isbn by remember { mutableStateOf(\"\") }\n  var photo by remember { mutableStateOf(\"\") }\n  var language by remember { mutableStateOf(\"\") }\n  var selectedGenre by remember { mutableStateOf<BookGenres?>(null) } // Genre selection state\n  var expanded by remember { mutableStateOf(false) } // State for dropdown menu\n  // Getting the context for showing Toast messages\n  val context = LocalContext.current\n\n  // Scaffold to provide basic UI structure with a top app bar\n  Scaffold(\n      modifier = Modifier.testTag(\"addBookScreen\").background(BackGround),\n      topBar = {\n        TopAppBar(\n            // Title of the screen\n            title = {\n              Text(\n                  text = \"Add Your Book\",\n                  fontSize = 24.sp,\n                  fontWeight = FontWeight.Bold,\n                  color = Accent,\n                  modifier = Modifier.testTag(\"addBookTitle\"))\n            },\n            // Icon button for navigation (currently no action defined)\n            // navigationIcon = { BackButton(navController) },\n            navigationIcon = {\n              BackButtonComponent(navController)\n              // You can add an icon here for the button\n            })\n      },\n      content = { paddingValues ->\n        // Column layout to stack input fields vertically with spacing\n        Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {\n          // Title Input Field\n          OutlinedTextField(\n              value = title,\n              onValueChange = { title = it },\n              label = { Text(\"Title\") },\n              placeholder = { Text(\"Enter the book title\") },\n              modifier =\n                  Modifier.padding(paddingValues)\n                      .testTag(\"inputBookTitle\")\n                      .testTag(\"Title\"), // Light background color inside the ,\n              colors =\n                  TextFieldDefaults.outlinedTextFieldColors(\n                      focusedBorderColor = Secondary, // Custom green for focused border\n                      unfocusedBorderColor = Secondary, // Lighter green for unfocused border\n                      cursorColor = Secondary, // Custom green for the cursor\n                      focusedLabelColor = Secondary, // Custom green for focused label\n                      unfocusedLabelColor = Secondary, // Lighter color for unfocused label\n                  ) // Adding padding to the input field\n              )\n\n          // Genre Dropdown\n          ExposedDropdownMenuBox(\n              expanded = expanded,\n              onExpandedChange = { expanded = !expanded },\n              modifier = Modifier.background(ColorVariable.BackGround) // Set background color here\n              ) {\n                OutlinedTextField(\n                    value = selectedGenre?.Genre ?: \"Select Genre\",\n                    onValueChange = {},\n                    label = { Text(\"Genre\") },\n                    readOnly = true,\n                    trailingIcon = {\n                      ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)\n                    },\n                    modifier = Modifier.menuAnchor())\n                ExposedDropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {\n                  BookGenres.values().forEach { genre ->\n                    DropdownMenuItem(\n                        text = {\n                          Text(\n                              text = genre.Genre,\n                              // color = ColorVariable.Secondary // Green text in dropdownmenu\n                          )\n                        },\n                        onClick = {\n                          selectedGenre = genre\n                          expanded = false\n                        })\n                  }\n                }\n              }\n\n          // Author Input Field\n          OutlinedTextField(\n              value = author,\n              onValueChange = { author = it },\n              label = { Text(\"Author\") },\n              placeholder = { Text(\"Enter the author's name\") },\n              modifier =\n                  Modifier.padding(paddingValues).testTag(\"inputBookAuthor\").testTag(\"Author\"),\n              colors =\n                  TextFieldDefaults.outlinedTextFieldColors(\n                      focusedBorderColor = Secondary, // Custom green for focused border\n                      unfocusedBorderColor = Secondary, // Lighter green for unfocused border\n                      cursorColor = Secondary, // Custom green for the cursor\n                      focusedLabelColor = Secondary, // Custom green for focused label\n                      unfocusedLabelColor = Secondary // Lighter color for unfocused label\n                      ) // Adding padding to the input field\n              )\n          // Description Input Field\n          OutlinedTextField(\n              value = description,\n              onValueChange = { description = it },\n              label = { Text(\"Description\") },\n              placeholder = { Text(\"Provide a description of the book\") },\n              modifier = Modifier.testTag(\"inputBookDescription\").testTag(\"Description\"),\n              colors =\n                  TextFieldDefaults.outlinedTextFieldColors(\n                      focusedBorderColor = Secondary, // Custom green for focused border\n                      unfocusedBorderColor = Secondary, // Lighter green for unfocused border\n                      cursorColor = Secondary, // Custom green for the cursor\n                      focusedLabelColor = Secondary, // Custom green for focused label\n                      unfocusedLabelColor = Secondary // Lighter color for unfocused label\n                      ))\n          // Rating Input Field\n          OutlinedTextField(\n              value = rating,\n              onValueChange = { rating = it },\n              label = { Text(\"Rating\") },\n              placeholder = { Text(\"Rate the book (e.g. 4.5)\") },\n              modifier = Modifier.testTag(\"inputBookRating\"),\n              colors =\n                  TextFieldDefaults.outlinedTextFieldColors(\n                      focusedBorderColor = Secondary, // Custom green for focused border\n                      unfocusedBorderColor = Secondary, // Lighter green for unfocused border\n                      cursorColor = Secondary, // Custom green for the cursor\n                      focusedLabelColor = Secondary, // Custom green for focused label\n                      unfocusedLabelColor = Secondary // Lighter color for unfocused label\n                      ))\n          // ISBN Input Field\n          OutlinedTextField(\n              value = isbn,\n              onValueChange = { isbn = it },\n              label = { Text(\"ISBN\") },\n              placeholder = { Text(\"Enter the ISBN\") },\n              modifier = Modifier.testTag(\"inputBookISBN\").testTag(\"ISBN\"),\n              colors =\n                  TextFieldDefaults.outlinedTextFieldColors(\n                      focusedBorderColor = Secondary, // Custom green for focused border\n                      unfocusedBorderColor = Secondary, // Lighter green for unfocused border\n                      cursorColor = Secondary, // Custom green for the cursor\n                      focusedLabelColor = Secondary, // Custom green for focused label\n                      unfocusedLabelColor = Secondary // Lighter color for unfocused label\n                      ))\n          // Photo  Input Field\n          OutlinedTextField(\n              value = photo,\n              onValueChange = { photo = it },\n              label = { Text(\"Photo \") },\n              placeholder = { Text(\"Enter a photo of the books\") },\n              modifier = Modifier.testTag(\"inputBookPhoto\").testTag(\"Photo\"),\n              colors =\n                  TextFieldDefaults.outlinedTextFieldColors(\n                      focusedBorderColor = Secondary, // Custom green for focused border\n                      unfocusedBorderColor = Secondary, // Lighter green for unfocused border\n                      cursorColor = Secondary, // Custom green for the cursor\n                      focusedLabelColor = Secondary, // Custom green for focused label\n                      unfocusedLabelColor = Secondary // Lighter color for unfocused label\n                      ))\n          // Language Input Field\n          OutlinedTextField(\n              value = language,\n              onValueChange = { language = it },\n              label = { Text(\"Language \") },\n              placeholder = { Text(\"In which language are the book\") },\n              modifier = Modifier.testTag(\"inputBookLanguage\").testTag(\"Language\"),\n              colors =\n                  TextFieldDefaults.outlinedTextFieldColors(\n                      focusedBorderColor = Secondary, // Custom green for focused border\n                      unfocusedBorderColor = Secondary, // Lighter green for unfocused border\n                      cursorColor = Secondary, // Custom green for the cursor\n                      focusedLabelColor = Secondary, // Custom green for focused label\n                      unfocusedLabelColor = Secondary // Lighter color for unfocused label\n                      ))\n          // Save Button\n          Button(\n              colors =\n                  ButtonDefaults.buttonColors(\n                      containerColor = Primary, // Light green\n                      contentColor = BackGround),\n              onClick = {\n                // Check if title and ISBN are not blank (required fields)\n                if (title.isNotBlank() && isbn.isNotBlank() && selectedGenre != null) {\n                  // You can handle book object creation here (e.g., save the book)\n                  val book =\n                      createDataBook(\n                          context,\n                          repository.getNewUid(),\n                          title,\n                          author,\n                          description,\n                          rating,\n                          photo,\n                          language,\n                          isbn,\n                          listOf(selectedGenre!!))\n                  if (book == null) {\n                    Toast.makeText(context, \"Invalid argument\", Toast.LENGTH_SHORT).show()\n                  } else {\n                    repository.addBook(book, OnSucess = {}, onFailure = {})\n                  }\n                } else {\n                  // Show a Toast message if title or ISBN is empty\n                  Toast.makeText(context, \"Title and ISBN are required.\", Toast.LENGTH_SHORT).show()\n                }\n              },\n              // Enable the button only if title and ISBN are filled\n              enabled = title.isNotBlank() && isbn.isNotBlank(),\n              modifier = Modifier.testTag(\"bookSave\").testTag(\"Save\")) {\n                // Text displayed on the button\n                Text(\"Save\", modifier = Modifier.testTag(\"bookSave\").testTag(\"Save\"))\n              }\n        }\n      })\n}\n\nfun createDataBook(\n    context: Context,\n    uuid: UUID,\n    title: String,\n    author: String,\n    description: String,\n    ratingStr: String,\n    photo: String,\n    bookLanguageStr: String,\n    isbn: String,\n    genres: List<BookGenres>\n): DataBook? {\n  // Validate UUID\n  if (uuid.toString().isBlank()) {\n    Log.e(\"AddToBookScreen\", \"UUID cannot be empty.\")\n    Toast.makeText(context, \"UUID cannot be empty.\", Toast.LENGTH_LONG).show()\n    return null\n  }\n\n  // Validate Title\n  if (title.isBlank()) {\n    Log.e(\"AddToBookScreen\", \"Title cannot be empty.\")\n    Toast.makeText(context, \"Title cannot be empty.\", Toast.LENGTH_LONG).show()\n\n    return null\n  }\n\n  // Validate Author\n  if (author.isBlank()) {\n    Log.e(\"AddToBookScreen\", \"Author cannot be empty.\")\n    Toast.makeText(context, \"Author cannot be empty.\", Toast.LENGTH_LONG).show()\n\n    return null\n  }\n\n  // Validate Rating\n  val rating: Int =\n      try {\n        ratingStr.toInt().also {\n          if (it !in 0..5) {\n            Log.e(\"AddToBookScreen\", \"Rating must be between 0 and 5.\")\n            Toast.makeText(context, \"Rating must be between 0 and 5.\", Toast.LENGTH_LONG).show()\n\n            return null\n          }\n        }\n      } catch (e: NumberFormatException) {\n        Log.e(\"AddToBookScreen\", \"Rating must be a valid number.\")\n        Toast.makeText(context, \"Rating must be a valid number.\", Toast.LENGTH_LONG).show()\n\n        return null\n      }\n\n  // Validate Photo (assuming basic validation here, just checking if not empty)\n  if (photo.isBlank()) {\n    Log.e(\"AddToBookScreen\", \"Photo URL cannot be empty.\")\n    Toast.makeText(context, \"Photo URL cannot be empty.\", Toast.LENGTH_LONG).show()\n\n    return null\n  }\n\n  // Validate Language\n  val languages: BookLanguages =\n      try {\n        BookLanguages.valueOf(bookLanguageStr.uppercase())\n      } catch (e: IllegalArgumentException) {\n        Log.e(\n            \"AddToBookScreen\",\n            \"Invalid language: $bookLanguageStr. Please use one of the supported languages.\")\n        Toast.makeText(context, \"Invalid language: $bookLanguageStr.\", Toast.LENGTH_LONG).show()\n\n        return null\n      }\n\n  // Validate ISBN\n  if (isbn.isBlank()) {\n    Log.e(\"AddToBookScreen\", \"ISBN cannot be empty.\")\n    Toast.makeText(context, \"ISBN cannot be empty.\", Toast.LENGTH_LONG).show()\n\n    return null\n  }\n\n  // If all validations pass, return a new DataBook instance\n  return DataBook(\n      uuid = uuid,\n      title = title,\n      author = author,\n      description = description,\n      rating = rating,\n      photo = photo,\n      language = languages,\n      isbn = isbn,\n      genres = genres)\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/books/add/AddToBook.kt b/app/src/main/java/com/android/bookswap/ui/books/add/AddToBook.kt
--- a/app/src/main/java/com/android/bookswap/ui/books/add/AddToBook.kt	
+++ b/app/src/main/java/com/android/bookswap/ui/books/add/AddToBook.kt	
@@ -14,10 +14,9 @@
 import androidx.compose.material3.ExposedDropdownMenuBox
 import androidx.compose.material3.ExposedDropdownMenuDefaults
 import androidx.compose.material3.OutlinedTextField
+import androidx.compose.material3.OutlinedTextFieldDefaults
 import androidx.compose.material3.Scaffold
 import androidx.compose.material3.Text
-import androidx.compose.material3.TextFieldDefaults
-import androidx.compose.material3.TopAppBar
 import androidx.compose.runtime.Composable
 import androidx.compose.runtime.getValue
 import androidx.compose.runtime.mutableStateOf
@@ -26,17 +25,12 @@
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.platform.LocalContext
 import androidx.compose.ui.platform.testTag
-import androidx.compose.ui.text.font.FontWeight
 import androidx.compose.ui.unit.dp
-import androidx.compose.ui.unit.sp
 import com.android.bookswap.data.BookGenres
 import com.android.bookswap.data.BookLanguages
 import com.android.bookswap.data.DataBook
 import com.android.bookswap.data.repository.BooksRepository
-import com.android.bookswap.ui.components.BackButtonComponent
-import com.android.bookswap.ui.navigation.NavigationActions
 import com.android.bookswap.ui.theme.ColorVariable
-import com.android.bookswap.ui.theme.ColorVariable.Accent
 import com.android.bookswap.ui.theme.ColorVariable.BackGround
 import com.android.bookswap.ui.theme.ColorVariable.Primary
 import com.android.bookswap.ui.theme.ColorVariable.Secondary
@@ -44,7 +38,11 @@
 
 @OptIn(ExperimentalMaterial3Api::class)
 @Composable
-fun AddToBookScreen(repository: BooksRepository, navController: NavigationActions) {
+fun AddToBookScreen(
+    repository: BooksRepository,
+    topAppBar: @Composable () -> Unit = {},
+    bottomAppBar: @Composable () -> Unit = {}
+) {
   // State variables to store the values entered by the user
   var title by remember { mutableStateOf("") }
   var author by remember { mutableStateOf("") }
@@ -61,24 +59,8 @@
   // Scaffold to provide basic UI structure with a top app bar
   Scaffold(
       modifier = Modifier.testTag("addBookScreen").background(BackGround),
-      topBar = {
-        TopAppBar(
-            // Title of the screen
-            title = {
-              Text(
-                  text = "Add Your Book",
-                  fontSize = 24.sp,
-                  fontWeight = FontWeight.Bold,
-                  color = Accent,
-                  modifier = Modifier.testTag("addBookTitle"))
-            },
-            // Icon button for navigation (currently no action defined)
-            // navigationIcon = { BackButton(navController) },
-            navigationIcon = {
-              BackButtonComponent(navController)
-              // You can add an icon here for the button
-            })
-      },
+      topBar = topAppBar,
+      bottomBar = bottomAppBar,
       content = { paddingValues ->
         // Column layout to stack input fields vertically with spacing
         Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
@@ -93,7 +75,7 @@
                       .testTag("inputBookTitle")
                       .testTag("Title"), // Light background color inside the ,
               colors =
-                  TextFieldDefaults.outlinedTextFieldColors(
+                  OutlinedTextFieldDefaults.colors(
                       focusedBorderColor = Secondary, // Custom green for focused border
                       unfocusedBorderColor = Secondary, // Lighter green for unfocused border
                       cursorColor = Secondary, // Custom green for the cursor
@@ -143,7 +125,7 @@
               modifier =
                   Modifier.padding(paddingValues).testTag("inputBookAuthor").testTag("Author"),
               colors =
-                  TextFieldDefaults.outlinedTextFieldColors(
+                  OutlinedTextFieldDefaults.colors(
                       focusedBorderColor = Secondary, // Custom green for focused border
                       unfocusedBorderColor = Secondary, // Lighter green for unfocused border
                       cursorColor = Secondary, // Custom green for the cursor
@@ -159,7 +141,7 @@
               placeholder = { Text("Provide a description of the book") },
               modifier = Modifier.testTag("inputBookDescription").testTag("Description"),
               colors =
-                  TextFieldDefaults.outlinedTextFieldColors(
+                  OutlinedTextFieldDefaults.colors(
                       focusedBorderColor = Secondary, // Custom green for focused border
                       unfocusedBorderColor = Secondary, // Lighter green for unfocused border
                       cursorColor = Secondary, // Custom green for the cursor
@@ -174,7 +156,7 @@
               placeholder = { Text("Rate the book (e.g. 4.5)") },
               modifier = Modifier.testTag("inputBookRating"),
               colors =
-                  TextFieldDefaults.outlinedTextFieldColors(
+                  OutlinedTextFieldDefaults.colors(
                       focusedBorderColor = Secondary, // Custom green for focused border
                       unfocusedBorderColor = Secondary, // Lighter green for unfocused border
                       cursorColor = Secondary, // Custom green for the cursor
@@ -189,7 +171,7 @@
               placeholder = { Text("Enter the ISBN") },
               modifier = Modifier.testTag("inputBookISBN").testTag("ISBN"),
               colors =
-                  TextFieldDefaults.outlinedTextFieldColors(
+                  OutlinedTextFieldDefaults.colors(
                       focusedBorderColor = Secondary, // Custom green for focused border
                       unfocusedBorderColor = Secondary, // Lighter green for unfocused border
                       cursorColor = Secondary, // Custom green for the cursor
@@ -204,7 +186,7 @@
               placeholder = { Text("Enter a photo of the books") },
               modifier = Modifier.testTag("inputBookPhoto").testTag("Photo"),
               colors =
-                  TextFieldDefaults.outlinedTextFieldColors(
+                  OutlinedTextFieldDefaults.colors(
                       focusedBorderColor = Secondary, // Custom green for focused border
                       unfocusedBorderColor = Secondary, // Lighter green for unfocused border
                       cursorColor = Secondary, // Custom green for the cursor
@@ -219,7 +201,7 @@
               placeholder = { Text("In which language are the book") },
               modifier = Modifier.testTag("inputBookLanguage").testTag("Language"),
               colors =
-                  TextFieldDefaults.outlinedTextFieldColors(
+                  OutlinedTextFieldDefaults.colors(
                       focusedBorderColor = Secondary, // Custom green for focused border
                       unfocusedBorderColor = Secondary, // Lighter green for unfocused border
                       cursorColor = Secondary, // Custom green for the cursor
@@ -239,7 +221,7 @@
                   val book =
                       createDataBook(
                           context,
-                          repository.getNewUid(),
+                          repository.getNewUUID(),
                           title,
                           author,
                           description,
@@ -251,7 +233,7 @@
                   if (book == null) {
                     Toast.makeText(context, "Invalid argument", Toast.LENGTH_SHORT).show()
                   } else {
-                    repository.addBook(book, OnSucess = {}, onFailure = {})
+                    repository.addBook(book, callback = {})
                   }
                 } else {
                   // Show a Toast message if title or ISBN is empty
Index: app/src/main/java/com/android/bookswap/ui/chat/ChatScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.chat\r\n\r\nimport android.util.Log\r\nimport android.widget.Toast\r\nimport androidx.compose.foundation.ExperimentalFoundationApi\r\nimport androidx.compose.foundation.background\r\nimport androidx.compose.foundation.border\r\nimport androidx.compose.foundation.combinedClickable\r\nimport androidx.compose.foundation.layout.Arrangement\r\nimport androidx.compose.foundation.layout.Box\r\nimport androidx.compose.foundation.layout.Column\r\nimport androidx.compose.foundation.layout.Row\r\nimport androidx.compose.foundation.layout.fillMaxSize\r\nimport androidx.compose.foundation.layout.fillMaxWidth\r\nimport androidx.compose.foundation.layout.padding\r\nimport androidx.compose.foundation.layout.size\r\nimport androidx.compose.foundation.layout.widthIn\r\nimport androidx.compose.foundation.lazy.LazyColumn\r\nimport androidx.compose.foundation.lazy.items\r\nimport androidx.compose.foundation.shape.RoundedCornerShape\r\nimport androidx.compose.foundation.text.BasicTextField\r\nimport androidx.compose.material.icons.Icons\r\nimport androidx.compose.material.icons.filled.Person\r\nimport androidx.compose.material3.Button\r\nimport androidx.compose.material3.ButtonColors\r\nimport androidx.compose.material3.Card\r\nimport androidx.compose.material3.CardColors\r\nimport androidx.compose.material3.ExperimentalMaterial3Api\r\nimport androidx.compose.material3.Icon\r\nimport androidx.compose.material3.IconButton\r\nimport androidx.compose.material3.MaterialTheme\r\nimport androidx.compose.material3.Text\r\nimport androidx.compose.material3.TopAppBar\r\nimport androidx.compose.material3.TopAppBarDefaults\r\nimport androidx.compose.runtime.Composable\r\nimport androidx.compose.runtime.LaunchedEffect\r\nimport androidx.compose.runtime.getValue\r\nimport androidx.compose.runtime.mutableStateOf\r\nimport androidx.compose.runtime.remember\r\nimport androidx.compose.runtime.setValue\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport androidx.compose.ui.graphics.Color\r\nimport androidx.compose.ui.platform.LocalConfiguration\r\nimport androidx.compose.ui.platform.LocalContext\r\nimport androidx.compose.ui.platform.testTag\r\nimport androidx.compose.ui.text.input.TextFieldValue\r\nimport androidx.compose.ui.unit.dp\r\nimport androidx.compose.ui.window.Popup\r\nimport com.android.bookswap.data.DataMessage\r\nimport com.android.bookswap.data.repository.MessageRepository\r\nimport com.android.bookswap.ui.components.BackButtonComponent\r\nimport com.android.bookswap.ui.navigation.NavigationActions\r\nimport com.android.bookswap.ui.theme.ColorVariable\r\nimport java.text.SimpleDateFormat\r\nimport java.util.Date\r\nimport java.util.Locale\r\nimport kotlinx.coroutines.delay\r\n\r\n@OptIn(ExperimentalMaterial3Api::class)\r\n@Composable\r\nfun ChatScreen(\r\n    messageRepository: MessageRepository,\r\n    currentUserId: String, // To identify the current user for aligning messages\r\n    otherUserId: String,\r\n    navController: NavigationActions\r\n) {\r\n  val context = LocalContext.current\r\n  var messages by remember { mutableStateOf(emptyList<DataMessage>()) }\r\n  var newMessageText by remember { mutableStateOf(TextFieldValue(\"\")) }\r\n  var selectedMessage by remember { mutableStateOf<DataMessage?>(null) }\r\n  var updateActive by remember { mutableStateOf(false) }\r\n\r\n  LaunchedEffect(Unit) {\r\n    while (true) {\r\n      messageRepository.getMessages { result ->\r\n        if (result.isSuccess) {\r\n          messages =\r\n              result\r\n                  .getOrThrow()\r\n                  .filter {\r\n                    (it.senderId == currentUserId && it.receiverId == otherUserId) ||\r\n                        (it.senderId == otherUserId && it.receiverId == currentUserId)\r\n                  }\r\n                  .sortedBy { it.timestamp }\r\n          Log.d(\"ChatScreen\", \"Fetched messages: $messages\")\r\n        } else {\r\n          Log.e(\"ChatScreen\", \"Failed to fetch messages: ${result.exceptionOrNull()?.message}\")\r\n        }\r\n      }\r\n      delay(2000) // Delay for 2 seconds\r\n    }\r\n  }\r\n  Box(modifier = Modifier.fillMaxSize().background(ColorVariable.BackGround)) {\r\n    Column(modifier = Modifier.fillMaxSize()) {\r\n      TopAppBar(\r\n          title = {\r\n            Text(\r\n                text = otherUserId,\r\n                style = MaterialTheme.typography.titleMedium,\r\n                color = ColorVariable.Accent,\r\n                modifier =\r\n                    Modifier.testTag(\"chatName\")\r\n                        .align(Alignment.CenterHorizontally)\r\n                        .padding(start = 24.dp))\r\n          },\r\n          navigationIcon = { BackButtonComponent(navController) },\r\n          actions = {\r\n            IconButton(onClick = { /* Handle profile icon click */}) {\r\n              Icon(\r\n                  imageVector = Icons.Default.Person,\r\n                  contentDescription = \"Profile\",\r\n                  modifier = Modifier.testTag(\"profileIcon\").size(36.dp),\r\n                  tint = ColorVariable.Accent)\r\n            }\r\n          },\r\n          colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent),\r\n          modifier = Modifier.testTag(\"chatTopAppBar\"))\r\n      Column(modifier = Modifier.fillMaxSize(), verticalArrangement = Arrangement.SpaceBetween) {\r\n        // Message list\r\n        LazyColumn(\r\n            modifier = Modifier.weight(1f).padding(8.dp),\r\n            verticalArrangement = Arrangement.Bottom) {\r\n              items(messages) { message ->\r\n                MessageItem(\r\n                    message = message,\r\n                    currentUserId = currentUserId,\r\n                    onLongPress = { selectedMessage = message })\r\n              }\r\n            }\r\n\r\n        // Message input field and send button\r\n        Row(\r\n            modifier =\r\n                Modifier.fillMaxWidth().padding(top = 8.dp).background(ColorVariable.Primary),\r\n            verticalAlignment = Alignment.CenterVertically) {\r\n              BasicTextField(\r\n                  value = newMessageText,\r\n                  onValueChange = { newMessageText = it },\r\n                  modifier =\r\n                      Modifier.weight(1f)\r\n                          .padding(8.dp)\r\n                          .background(ColorVariable.Secondary, MaterialTheme.shapes.small)\r\n                          .border(1.dp, ColorVariable.Accent, MaterialTheme.shapes.small)\r\n                          .padding(8.dp)\r\n                          .testTag(\"message_input_field\"),\r\n              )\r\n              Button(\r\n                  onClick = {\r\n                    if (updateActive) {\r\n                      // Update the message\r\n                      messageRepository.updateMessage(\r\n                          selectedMessage!!.copy(text = newMessageText.text),\r\n                          { result: Result<Unit> ->\r\n                            if (result.isSuccess) {\r\n                              Log.d(\"ChatScreen\", \"Message updated successfully\")\r\n                              selectedMessage = null\r\n                              newMessageText = TextFieldValue(\"\")\r\n                              updateActive = false\r\n                            } else {\r\n                              Log.e(\r\n                                  \"ChatScreen\",\r\n                                  \"Failed to update message: ${result.exceptionOrNull()?.message}\")\r\n                              selectedMessage = null\r\n                              newMessageText = TextFieldValue(\"\")\r\n                              updateActive = false\r\n                            }\r\n                          },\r\n                          context)\r\n                    } else {\r\n                      // Send a new message\r\n                      val messageId = messageRepository.getNewUid()\r\n                      val newMessage =\r\n                          DataMessage(\r\n                              id = messageId,\r\n                              text = newMessageText.text,\r\n                              senderId = currentUserId,\r\n                              receiverId = otherUserId, // Ensure receiverId is set here\r\n                              timestamp = System.currentTimeMillis())\r\n                      // Send the message\r\n                      messageRepository.sendMessage(\r\n                          message = newMessage,\r\n                      ) { result ->\r\n                        if (result.isSuccess) {\r\n                          newMessageText = TextFieldValue(\"\")\r\n                        } else {\r\n                          Toast.makeText(context, \"Message could not be sent.\", Toast.LENGTH_LONG)\r\n                              .show()\r\n                          Log.e(\r\n                              \"MessageView\",\r\n                              \"Failed to send message: ${result.exceptionOrNull()?.message}\")\r\n                        }\r\n                      }\r\n                    }\r\n                  },\r\n                  colors =\r\n                      ButtonColors(\r\n                          ColorVariable.Secondary,\r\n                          ColorVariable.Accent,\r\n                          ColorVariable.Secondary,\r\n                          ColorVariable.Accent),\r\n                  modifier = Modifier.padding(horizontal = 8.dp).testTag(\"send_button\")) {\r\n                    Text(if (updateActive) \"Update\" else \"Send\")\r\n                  }\r\n            }\r\n      }\r\n    }\r\n    if (!updateActive) {\r\n      selectedMessage?.let { message ->\r\n        Popup(\r\n            alignment = Alignment.Center,\r\n            onDismissRequest = {\r\n              if (!updateActive) {\r\n                selectedMessage = null\r\n              }\r\n            }) {\r\n              Column(\r\n                  modifier =\r\n                      Modifier.background(ColorVariable.Primary, shape = RoundedCornerShape(8.dp))\r\n                          .border(2.dp, ColorVariable.Accent, shape = RoundedCornerShape(8.dp))\r\n                          .padding(8.dp),\r\n                  verticalArrangement = Arrangement.Center,\r\n                  horizontalAlignment = Alignment.CenterHorizontally) {\r\n                    Button(\r\n                        onClick = {\r\n                          // Handle edit\r\n                          newMessageText = TextFieldValue(message.text)\r\n                          updateActive = true\r\n                        },\r\n                        modifier =\r\n                            Modifier.background(\r\n                                    ColorVariable.Primary, shape = RoundedCornerShape(50))\r\n                                .padding(8.dp)\r\n                                .testTag(\"editButton\")) {\r\n                          Text(\"Edit\")\r\n                        }\r\n                    Button(\r\n                        onClick = {\r\n                          // Handle delete\r\n                          selectedMessage?.let { message ->\r\n                            messageRepository.deleteMessage(\r\n                                message.id,\r\n                                { result ->\r\n                                  if (result.isSuccess) {\r\n                                    Log.d(\"ChatScreen\", \"Message deleted successfully\")\r\n                                    selectedMessage = null\r\n                                  } else {\r\n                                    Log.e(\r\n                                        \"ChatScreen\",\r\n                                        \"Failed to delete message: ${result.exceptionOrNull()?.message}\")\r\n                                  }\r\n                                },\r\n                                context)\r\n                          }\r\n                        },\r\n                        modifier =\r\n                            Modifier.background(\r\n                                    ColorVariable.Primary, shape = RoundedCornerShape(50))\r\n                                .padding(8.dp)\r\n                                .testTag(\"deleteButton\")) {\r\n                          Text(\"Delete\")\r\n                        }\r\n                  }\r\n            }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n@OptIn(ExperimentalFoundationApi::class)\r\n@Composable\r\nfun MessageItem(message: DataMessage, currentUserId: String, onLongPress: () -> Unit) {\r\n  val isCurrentUser = message.senderId == currentUserId\r\n  val cornerRadius = 25.dp\r\n  val shape =\r\n      if (isCurrentUser) {\r\n        RoundedCornerShape(\r\n            topStart = cornerRadius,\r\n            topEnd = cornerRadius,\r\n            bottomStart = cornerRadius,\r\n            bottomEnd = 5.dp)\r\n      } else {\r\n        RoundedCornerShape(\r\n            topStart = cornerRadius,\r\n            topEnd = cornerRadius,\r\n            bottomStart = 5.dp,\r\n            bottomEnd = cornerRadius)\r\n      }\r\n  Row(\r\n      modifier = Modifier.fillMaxWidth(),\r\n      horizontalArrangement = if (isCurrentUser) Arrangement.End else Arrangement.Start) {\r\n        Card(\r\n            colors =\r\n                if (isCurrentUser) {\r\n                  CardColors(\r\n                      ColorVariable.Primary,\r\n                      ColorVariable.Accent,\r\n                      ColorVariable.Primary,\r\n                      ColorVariable.Accent)\r\n                } else {\r\n                  CardColors(\r\n                      ColorVariable.Secondary,\r\n                      ColorVariable.Accent,\r\n                      ColorVariable.Secondary,\r\n                      ColorVariable.Accent)\r\n                },\r\n            shape = shape,\r\n            modifier =\r\n                Modifier.padding(8.dp)\r\n                    .widthIn(max = (LocalConfiguration.current.screenWidthDp.dp * 2 / 3))\r\n                    .border(1.dp, ColorVariable.Accent, shape)\r\n                    .combinedClickable(onClick = {}, onLongClick = { onLongPress() })\r\n                    .testTag(\"message_item ${message.id}\")) {\r\n              Column(modifier = Modifier.padding(16.dp)) {\r\n                Text(\r\n                    text = message.text,\r\n                    modifier = Modifier.testTag(\"message_text ${message.id}\"),\r\n                    color = ColorVariable.Accent)\r\n                Text(\r\n                    text = formatTimestamp(message.timestamp),\r\n                    color = ColorVariable.AccentSecondary,\r\n                    style = MaterialTheme.typography.bodySmall,\r\n                    modifier =\r\n                        Modifier.align(Alignment.End).testTag(\"message_timestamp ${message.id}\"))\r\n              }\r\n            }\r\n      }\r\n}\r\n\r\nfun formatTimestamp(timestamp: Long): String {\r\n  val messageDate = Date(timestamp)\r\n  val currentDate = Date()\r\n  val dateFormat = SimpleDateFormat(\"yyyyMMdd\", Locale.getDefault())\r\n  val timeFormat = SimpleDateFormat(\"HH:mm\", Locale.getDefault())\r\n  val dateTimeFormat = SimpleDateFormat(\"MMM dd, yyyy\", Locale.getDefault())\r\n\r\n  return if (dateFormat.format(messageDate) == dateFormat.format(currentDate)) {\r\n    timeFormat.format(messageDate)\r\n  } else {\r\n    dateTimeFormat.format(messageDate)\r\n  }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/chat/ChatScreen.kt b/app/src/main/java/com/android/bookswap/ui/chat/ChatScreen.kt
--- a/app/src/main/java/com/android/bookswap/ui/chat/ChatScreen.kt	
+++ b/app/src/main/java/com/android/bookswap/ui/chat/ChatScreen.kt	
@@ -5,7 +5,9 @@
 import androidx.compose.foundation.ExperimentalFoundationApi
 import androidx.compose.foundation.background
 import androidx.compose.foundation.border
+import androidx.compose.foundation.clickable
 import androidx.compose.foundation.combinedClickable
+import androidx.compose.foundation.gestures.detectTransformGestures
 import androidx.compose.foundation.layout.Arrangement
 import androidx.compose.foundation.layout.Box
 import androidx.compose.foundation.layout.Column
@@ -35,19 +37,25 @@
 import androidx.compose.runtime.Composable
 import androidx.compose.runtime.LaunchedEffect
 import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableFloatStateOf
 import androidx.compose.runtime.mutableStateOf
 import androidx.compose.runtime.remember
 import androidx.compose.runtime.setValue
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.graphics.graphicsLayer
+import androidx.compose.ui.input.pointer.pointerInput
 import androidx.compose.ui.platform.LocalConfiguration
 import androidx.compose.ui.platform.LocalContext
 import androidx.compose.ui.platform.testTag
 import androidx.compose.ui.text.input.TextFieldValue
 import androidx.compose.ui.unit.dp
 import androidx.compose.ui.window.Popup
+import coil.compose.AsyncImage
 import com.android.bookswap.data.DataMessage
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.MessageType
 import com.android.bookswap.data.repository.MessageRepository
 import com.android.bookswap.ui.components.BackButtonComponent
 import com.android.bookswap.ui.navigation.NavigationActions
@@ -55,14 +63,15 @@
 import java.text.SimpleDateFormat
 import java.util.Date
 import java.util.Locale
+import java.util.UUID
 import kotlinx.coroutines.delay
 
 @OptIn(ExperimentalMaterial3Api::class)
 @Composable
 fun ChatScreen(
     messageRepository: MessageRepository,
-    currentUserId: String, // To identify the current user for aligning messages
-    otherUserId: String,
+    currentUser: DataUser,
+    otherUser: DataUser,
     navController: NavigationActions
 ) {
   val context = LocalContext.current
@@ -70,7 +79,9 @@
   var newMessageText by remember { mutableStateOf(TextFieldValue("")) }
   var selectedMessage by remember { mutableStateOf<DataMessage?>(null) }
   var updateActive by remember { mutableStateOf(false) }
-
+  val padding8 = 8.dp
+  val padding24 = 24.dp
+  val padding36 = 36.dp
   LaunchedEffect(Unit) {
     while (true) {
       messageRepository.getMessages { result ->
@@ -79,8 +90,10 @@
               result
                   .getOrThrow()
                   .filter {
-                    (it.senderId == currentUserId && it.receiverId == otherUserId) ||
-                        (it.senderId == otherUserId && it.receiverId == currentUserId)
+                    (it.senderUUID == currentUser.userUUID &&
+                        it.receiverUUID == otherUser.userUUID) ||
+                        (it.senderUUID == otherUser.userUUID &&
+                            it.receiverUUID == currentUser.userUUID)
                   }
                   .sortedBy { it.timestamp }
           Log.d("ChatScreen", "Fetched messages: $messages")
@@ -96,13 +109,13 @@
       TopAppBar(
           title = {
             Text(
-                text = otherUserId,
+                text = otherUser.firstName + " " + otherUser.lastName,
                 style = MaterialTheme.typography.titleMedium,
                 color = ColorVariable.Accent,
                 modifier =
                     Modifier.testTag("chatName")
                         .align(Alignment.CenterHorizontally)
-                        .padding(start = 24.dp))
+                        .padding(start = padding24))
           },
           navigationIcon = { BackButtonComponent(navController) },
           actions = {
@@ -110,7 +123,7 @@
               Icon(
                   imageVector = Icons.Default.Person,
                   contentDescription = "Profile",
-                  modifier = Modifier.testTag("profileIcon").size(36.dp),
+                  modifier = Modifier.testTag("profileIcon").size(padding36),
                   tint = ColorVariable.Accent)
             }
           },
@@ -119,12 +132,12 @@
       Column(modifier = Modifier.fillMaxSize(), verticalArrangement = Arrangement.SpaceBetween) {
         // Message list
         LazyColumn(
-            modifier = Modifier.weight(1f).padding(8.dp),
+            modifier = Modifier.weight(1f).padding(padding8).testTag("column"),
             verticalArrangement = Arrangement.Bottom) {
               items(messages) { message ->
                 MessageItem(
                     message = message,
-                    currentUserId = currentUserId,
+                    currentUserUUID = currentUser.userUUID,
                     onLongPress = { selectedMessage = message })
               }
             }
@@ -132,17 +145,17 @@
         // Message input field and send button
         Row(
             modifier =
-                Modifier.fillMaxWidth().padding(top = 8.dp).background(ColorVariable.Primary),
+                Modifier.fillMaxWidth().padding(top = padding8).background(ColorVariable.Primary),
             verticalAlignment = Alignment.CenterVertically) {
               BasicTextField(
                   value = newMessageText,
                   onValueChange = { newMessageText = it },
                   modifier =
                       Modifier.weight(1f)
-                          .padding(8.dp)
+                          .padding(padding8)
                           .background(ColorVariable.Secondary, MaterialTheme.shapes.small)
                           .border(1.dp, ColorVariable.Accent, MaterialTheme.shapes.small)
-                          .padding(8.dp)
+                          .padding(padding8)
                           .testTag("message_input_field"),
               )
               Button(
@@ -169,13 +182,14 @@
                           context)
                     } else {
                       // Send a new message
-                      val messageId = messageRepository.getNewUid()
+                      val messageId = messageRepository.getNewUUID()
                       val newMessage =
                           DataMessage(
-                              id = messageId,
+                              messageType = MessageType.TEXT,
+                              uuid = messageId,
                               text = newMessageText.text,
-                              senderId = currentUserId,
-                              receiverId = otherUserId, // Ensure receiverId is set here
+                              senderUUID = currentUser.userUUID,
+                              receiverUUID = otherUser.userUUID, // Ensure receiverId is set here
                               timestamp = System.currentTimeMillis())
                       // Send the message
                       messageRepository.sendMessage(
@@ -199,7 +213,7 @@
                           ColorVariable.Accent,
                           ColorVariable.Secondary,
                           ColorVariable.Accent),
-                  modifier = Modifier.padding(horizontal = 8.dp).testTag("send_button")) {
+                  modifier = Modifier.padding(horizontal = padding8).testTag("send_button")) {
                     Text(if (updateActive) "Update" else "Send")
                   }
             }
@@ -218,7 +232,7 @@
                   modifier =
                       Modifier.background(ColorVariable.Primary, shape = RoundedCornerShape(8.dp))
                           .border(2.dp, ColorVariable.Accent, shape = RoundedCornerShape(8.dp))
-                          .padding(8.dp),
+                          .padding(padding8),
                   verticalArrangement = Arrangement.Center,
                   horizontalAlignment = Alignment.CenterHorizontally) {
                     Button(
@@ -230,7 +244,7 @@
                         modifier =
                             Modifier.background(
                                     ColorVariable.Primary, shape = RoundedCornerShape(50))
-                                .padding(8.dp)
+                                .padding(padding8)
                                 .testTag("editButton")) {
                           Text("Edit")
                         }
@@ -239,7 +253,7 @@
                           // Handle delete
                           selectedMessage?.let { message ->
                             messageRepository.deleteMessage(
-                                message.id,
+                                message.uuid,
                                 { result ->
                                   if (result.isSuccess) {
                                     Log.d("ChatScreen", "Message deleted successfully")
@@ -256,7 +270,7 @@
                         modifier =
                             Modifier.background(
                                     ColorVariable.Primary, shape = RoundedCornerShape(50))
-                                .padding(8.dp)
+                                .padding(padding8)
                                 .testTag("deleteButton")) {
                           Text("Delete")
                         }
@@ -269,9 +283,12 @@
 
 @OptIn(ExperimentalFoundationApi::class)
 @Composable
-fun MessageItem(message: DataMessage, currentUserId: String, onLongPress: () -> Unit) {
-  val isCurrentUser = message.senderId == currentUserId
+fun MessageItem(message: DataMessage, currentUserUUID: UUID, onLongPress: () -> Unit) {
+  val isCurrentUser = message.senderUUID == currentUserUUID
   val cornerRadius = 25.dp
+  val padding8 = 8.dp
+  val padding16 = 16.dp
+  val imagePopUp = 300.dp
   val shape =
       if (isCurrentUser) {
         RoundedCornerShape(
@@ -286,6 +303,11 @@
             bottomStart = 5.dp,
             bottomEnd = cornerRadius)
       }
+  var showPopup by remember { mutableStateOf(false) }
+  var scale by remember { mutableFloatStateOf(1f) }
+  var offsetX by remember { mutableFloatStateOf(0f) }
+  var offsetY by remember { mutableFloatStateOf(0f) }
+
   Row(
       modifier = Modifier.fillMaxWidth(),
       horizontalArrangement = if (isCurrentUser) Arrangement.End else Arrangement.Start) {
@@ -306,25 +328,88 @@
                 },
             shape = shape,
             modifier =
-                Modifier.padding(8.dp)
+                Modifier.padding(padding8)
                     .widthIn(max = (LocalConfiguration.current.screenWidthDp.dp * 2 / 3))
                     .border(1.dp, ColorVariable.Accent, shape)
-                    .combinedClickable(onClick = {}, onLongClick = { onLongPress() })
-                    .testTag("message_item ${message.id}")) {
-              Column(modifier = Modifier.padding(16.dp)) {
-                Text(
-                    text = message.text,
-                    modifier = Modifier.testTag("message_text ${message.id}"),
-                    color = ColorVariable.Accent)
-                Text(
-                    text = formatTimestamp(message.timestamp),
-                    color = ColorVariable.AccentSecondary,
-                    style = MaterialTheme.typography.bodySmall,
+                    .combinedClickable(
+                        onClick = {
+                          if (message.messageType == MessageType.IMAGE) showPopup = true
+                        },
+                        onLongClick = { onLongPress() })
+                    .testTag("message_item ${message.uuid}")) {
+              Column(
+                  modifier =
+                      Modifier.padding(16.dp).testTag("message_item_column ${message.uuid}")) {
+                    if (message.uuid == imageTestMessageUUID) {
+                      AsyncImage(
+                          model = message.text,
+                          contentDescription = "Message Image",
+                          modifier = Modifier.testTag("hobbit"))
+                    } else {
+                      Text(
+                          text = message.text,
+                          modifier = Modifier.testTag("message_text ${message.uuid}"),
+                          color = ColorVariable.Accent)
+                    }
+                    Text(
+                        text = formatTimestamp(message.timestamp),
+                        color = ColorVariable.AccentSecondary,
+                        style = MaterialTheme.typography.bodySmall,
+                        modifier =
+                            Modifier.align(Alignment.End)
+                                .testTag("message_timestamp ${message.uuid}"))
+                  }
+            }
+      }
+
+  if (showPopup) {
+    Popup(
+        alignment = Alignment.Center,
+        onDismissRequest = {
+          showPopup = false
+          scale = 1f
+          offsetX = 0f
+          offsetY = 0f
+        }) {
+          Box(
+              modifier =
+                  Modifier.fillMaxSize()
+                      .testTag("popupImage")
+                      .background(Color.Black.copy(alpha = 0.8f))
+                      .clickable {
+                        showPopup = false
+                        scale = 1f
+                        offsetX = 0f
+                        offsetY = 0f
+                      }
+                      .padding(padding16)) {
+                Box(
                     modifier =
-                        Modifier.align(Alignment.End).testTag("message_timestamp ${message.id}"))
+                        Modifier.align(Alignment.Center)
+                            .size(imagePopUp * scale)
+                            .graphicsLayer(
+                                scaleX = scale,
+                                scaleY = scale,
+                                translationX = offsetX,
+                                translationY = offsetY)) {
+                      AsyncImage(
+                          model = message.text,
+                          contentDescription = "Enlarged Image",
+                          modifier =
+                              Modifier.size(imagePopUp * scale)
+                                  .pointerInput(Unit) {
+                                    detectTransformGestures { _, _, zoom, _ -> scale *= zoom }
+                                  }
+                                  .graphicsLayer(
+                                      scaleX = scale,
+                                      scaleY = scale,
+                                      translationX = offsetX,
+                                      translationY = offsetY)
+                                  .testTag("HobbitBig"))
+                    }
               }
-            }
-      }
+        }
+  }
 }
 
 fun formatTimestamp(timestamp: Long): String {
@@ -340,3 +425,8 @@
     dateTimeFormat.format(messageDate)
   }
 }
+
+val imageTestMessageUUID: UUID =
+    UUID.fromString(
+        "11111111-aa16-43d1-8c47-082ac787f755") // Placeholder message for testing image (adapted to
+                                                // use UUID)
Index: app/src/main/java/com/android/bookswap/model/map/DefaultGeolocation.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.model.map\n\nimport android.util.Log\nimport androidx.compose.runtime.mutableStateOf\n\n/**\n * Mock implementation of [IGeolocation] for testing purposes.\n *\n * This class provides hardcoded latitude and longitude values and does not interact with real\n * location services. It is useful for testing UI components that rely on geolocation data without\n * requiring actual GPS hardware or permissions.\n *\n * Usage:\n * - This can be passed as a dependency to classes or Composables expecting an [IGeolocation]\n *   implementation, allowing the testing of location-dependent functionality in a controlled\n *   environment.\n */\nclass DefaultGeolocation : IGeolocation {\n  override val latitude = mutableStateOf(0.0)\n  override val longitude = mutableStateOf(0.0)\n  private val isRunning = mutableStateOf(false)\n\n  override fun startLocationUpdates() {\n    isRunning.value = true\n    Log.d(\"DefaultGeolocation\", \"Using default geolocation start\")\n  }\n\n  override fun stopLocationUpdates() {\n    isRunning.value = false\n    Log.d(\"DefaultGeolocation\", \"Using default geolocation stop\")\n  }\n\n  fun moveLocation(latitude: Double, longitude: Double) {\n    if (isRunning.value) {\n      this.latitude.value = latitude\n      this.longitude.value = longitude\n    } else {\n      Log.d(\"DefaultGeolocation\", \"Location updates are not running\")\n    }\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/map/DefaultGeolocation.kt b/app/src/main/java/com/android/bookswap/model/map/DefaultGeolocation.kt
--- a/app/src/main/java/com/android/bookswap/model/map/DefaultGeolocation.kt	
+++ b/app/src/main/java/com/android/bookswap/model/map/DefaultGeolocation.kt	
@@ -2,6 +2,7 @@
 
 import android.util.Log
 import androidx.compose.runtime.mutableStateOf
+import kotlinx.coroutines.flow.MutableStateFlow
 
 /**
  * Mock implementation of [IGeolocation] for testing purposes.
@@ -16,8 +17,8 @@
  *   environment.
  */
 class DefaultGeolocation : IGeolocation {
-  override val latitude = mutableStateOf(0.0)
-  override val longitude = mutableStateOf(0.0)
+  override val latitude = MutableStateFlow(0.0)
+  override val longitude = MutableStateFlow(0.0)
   private val isRunning = mutableStateOf(false)
 
   override fun startLocationUpdates() {
Index: app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreRepositoryTest.kt
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreRepositoryTest.kt b/app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreRepositoryTest.kt
deleted file mode 100644
--- a/app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreRepositoryTest.kt	
+++ /dev/null	
@@ -1,206 +0,0 @@
-package com.android.bookswap.data.source.network
-
-import androidx.test.core.app.ApplicationProvider
-import com.android.bookswap.data.BookLanguages
-import com.android.bookswap.data.DataBook
-import com.google.android.gms.tasks.Tasks
-import com.google.firebase.FirebaseApp
-import com.google.firebase.firestore.CollectionReference
-import com.google.firebase.firestore.DocumentReference
-import com.google.firebase.firestore.DocumentSnapshot
-import com.google.firebase.firestore.FirebaseFirestore
-import com.google.firebase.firestore.QuerySnapshot
-import com.google.firebase.firestore.util.Assert.fail
-import java.util.UUID
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.ArgumentMatchers
-import org.mockito.Mock
-import org.mockito.Mockito.`when`
-import org.mockito.MockitoAnnotations
-import org.mockito.kotlin.doAnswer
-import org.mockito.kotlin.verify
-import org.robolectric.RobolectricTestRunner
-
-@RunWith(RobolectricTestRunner::class)
-class BooksFirestoreRepositoryTest {
-
-  @Mock private lateinit var mockFirestore: FirebaseFirestore
-  @Mock private lateinit var mockCollectionReference: CollectionReference
-  @Mock private lateinit var mockDocumentReference: DocumentReference
-  @Mock private lateinit var mockDocumentSnapshot: DocumentSnapshot
-  @Mock private lateinit var mockQuerySnapshot: QuerySnapshot
-
-  private lateinit var booksFirestorerRepository: BooksFirestoreRepository
-
-  private val testBook =
-      DataBook(
-          uuid = UUID.randomUUID(),
-          title = "Test Book",
-          author = "Test Author",
-          description = "Test Description",
-          rating = 5,
-          photo = "http://example.com/photo.jpg",
-          language = BookLanguages.ENGLISH,
-          isbn = "1234567890")
-
-  @Before
-  fun setUp() {
-    MockitoAnnotations.openMocks(this)
-
-    // Initialize Firebase if necessary
-    if (FirebaseApp.getApps(ApplicationProvider.getApplicationContext()).isEmpty()) {
-      FirebaseApp.initializeApp(ApplicationProvider.getApplicationContext())
-    }
-
-    booksFirestorerRepository = BooksFirestoreRepository(mockFirestore)
-
-    `when`(mockFirestore.collection(ArgumentMatchers.any())).thenReturn(mockCollectionReference)
-    `when`(mockCollectionReference.document(ArgumentMatchers.any()))
-        .thenReturn(mockDocumentReference)
-    `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
-  }
-
-  @Test
-  fun getbook_callsFirestoreGet() {
-    // Arrange
-    `when`(mockQuerySnapshot.documents).thenReturn(listOf(mockDocumentSnapshot))
-    `when`(mockDocumentSnapshot.getString("Title")).thenReturn(testBook.title)
-    `when`(mockDocumentSnapshot.getString("Author")).thenReturn(testBook.author)
-    `when`(mockDocumentSnapshot.getString("Description")).thenReturn(testBook.description)
-    `when`(mockDocumentSnapshot.getString("Rating")).thenReturn(testBook.rating.toString())
-    `when`(mockDocumentSnapshot.getString("Photo")).thenReturn(testBook.photo)
-    `when`(mockDocumentSnapshot.getString("Language")).thenReturn(testBook.language.name)
-    `when`(mockDocumentSnapshot.getString("ISBN")).thenReturn(testBook.isbn)
-
-    // Act
-    booksFirestorerRepository.getBook(
-        OnSucess = { books ->
-          // Assert that the fetched books match the expected values
-          assert(books.isNotEmpty())
-          assert(books.first().title == testBook.title)
-        },
-        onFailure = { fail("Should not fail") })
-
-    // Verify that Firestore collection was called
-    verify(mockCollectionReference).get()
-  }
-
-  @Test
-  fun deletebooks_shouldCallFirestoreDelete() {
-    // Arrange
-    doAnswer { Tasks.forResult(null) }.`when`(mockDocumentReference).delete()
-
-    // Act
-    booksFirestorerRepository.deleteBooks(testBook.isbn!!, testBook, {}, {})
-
-    // Assert
-    verify(mockDocumentReference).delete()
-  }
-
-  @Test
-  fun addBooks_callsFirestoreSet_andOnSuccess() {
-    // Arrange
-    doAnswer { Tasks.forResult(null) }.`when`(mockDocumentReference).set(testBook)
-
-    // Act
-    booksFirestorerRepository.addBook(
-        testBook,
-        {
-          // Assert success callback
-          assert(true)
-        },
-        { fail("Should not fail") })
-
-    // Verify Firestore set operation
-    verify(mockDocumentReference).set(testBook)
-  }
-
-  @Test
-  fun updatebook_callsFirestoreSet_andOnSuccess() {
-    // Arrange
-    doAnswer { Tasks.forResult(null) }.`when`(mockDocumentReference).set(testBook)
-
-    // Act
-    booksFirestorerRepository.updateBook(
-        testBook,
-        {
-          // Assert success callback
-          assert(true)
-        },
-        { fail("Should not fail") })
-
-    // Verify Firestore update operation
-    verify(mockDocumentReference).set(testBook)
-  }
-
-  @Test
-  fun documenttoBooks_returnsDataBook_whenDocumentIsValid() {
-    // Arrange
-    `when`(mockDocumentSnapshot.getString("Title")).thenReturn(testBook.title)
-    `when`(mockDocumentSnapshot.getString("Author")).thenReturn(testBook.author)
-    `when`(mockDocumentSnapshot.getString("Description")).thenReturn(testBook.description)
-    `when`(mockDocumentSnapshot.getString("Rating")).thenReturn(testBook.rating.toString())
-    `when`(mockDocumentSnapshot.getString("Photo")).thenReturn(testBook.photo)
-    `when`(mockDocumentSnapshot.getString("Language")).thenReturn(testBook.language.name)
-    `when`(mockDocumentSnapshot.getString("ISBN")).thenReturn(testBook.isbn)
-
-    // Act
-    val result = booksFirestorerRepository.documentToBooks(mockDocumentSnapshot)
-
-    // Assert
-    assert(result != null)
-    assert(result?.title == testBook.title)
-    assert(result?.author == testBook.author)
-  }
-
-  @Test
-  fun documenttoBooks_returnsNull_whenRequiredFieldIsMissing() {
-    // Arrange - Missing "Title"
-    `when`(mockDocumentSnapshot.getString("Title")).thenReturn(null)
-    `when`(mockDocumentSnapshot.getString("Author")).thenReturn(testBook.author)
-    `when`(mockDocumentSnapshot.getString("Description")).thenReturn(testBook.description)
-    `when`(mockDocumentSnapshot.getString("Rating")).thenReturn(testBook.rating.toString())
-    `when`(mockDocumentSnapshot.getString("Photo")).thenReturn(testBook.photo)
-    `when`(mockDocumentSnapshot.getString("Language")).thenReturn(testBook.language.name)
-    `when`(mockDocumentSnapshot.getString("ISBN")).thenReturn(testBook.isbn)
-
-    // Act
-    val result = booksFirestorerRepository.documentToBooks(mockDocumentSnapshot)
-
-    // Assert
-    assert(result == null)
-  }
-
-  @Test
-  fun documenttoBooks_returnsNull_whenLanguageIsInvalid() {
-    // Arrange - Invalid language value
-    `when`(mockDocumentSnapshot.getString("Title")).thenReturn(testBook.title)
-    `when`(mockDocumentSnapshot.getString("Author")).thenReturn(testBook.author)
-    `when`(mockDocumentSnapshot.getString("Description")).thenReturn(testBook.description)
-    `when`(mockDocumentSnapshot.getString("Rating")).thenReturn(testBook.rating.toString())
-    `when`(mockDocumentSnapshot.getString("Photo")).thenReturn(testBook.photo)
-    `when`(mockDocumentSnapshot.getString("Language")).thenReturn("INVALID_LANGUAGE")
-    `when`(mockDocumentSnapshot.getString("ISBN")).thenReturn(testBook.isbn)
-
-    // Act
-    val result = booksFirestorerRepository.documentToBooks(mockDocumentSnapshot)
-
-    // Assert
-    assert(result == null) // Should return null due to invalid language
-  }
-  /**
-   * @Test fun getNewUid_returnsUniqueDocumentId() { // Arrange val collectionBooks = "Books" val
-   *   mockDocumentReference = mock(DocumentReference::class.java) val expectedUid =
-   *   UUID.randomUUID().toString()
-   *
-   * // Mock Firestore to return a document with the desired ID
-   * `when`(mockFirestore.collection(collectionBooks).document()).thenReturn(mockDocumentReference)
-   * `when`(mockDocumentReference.id).thenReturn(expectedUid)
-   *
-   * // Act val uid = booksFirestorerRepository.getNewUid()
-   *
-   * // Assert assert(uid.toString() == expectedUid) // Ensure the ID matches the expected value }
-   */
-}
Index: app/src/main/java/com/android/bookswap/model/chat/Chat.kt
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/chat/Chat.kt b/app/src/main/java/com/android/bookswap/model/chat/Chat.kt
deleted file mode 100644
--- a/app/src/main/java/com/android/bookswap/model/chat/Chat.kt	
+++ /dev/null	
@@ -1,4 +0,0 @@
-package com.android.bookswap.model.chat
-
-/** Data class for the message box */
-data class MessageBox(val contactName: String, val message: String, val date: String)
Index: app/src/main/java/com/android/bookswap/data/repository/PhotoRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/repository/PhotoRepository.kt b/app/src/main/java/com/android/bookswap/data/repository/PhotoRepository.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/data/repository/PhotoRepository.kt	
@@ -0,0 +1,51 @@
+package com.android.bookswap.data.repository
+
+import android.graphics.Bitmap
+import com.android.bookswap.data.DataPhoto
+import java.util.UUID
+
+interface PhotoRepository {
+  /** Generates a new unique id for a message */
+  fun getNewUUID(): UUID
+
+  /**
+   * Initialize the repository
+   *
+   * @param callback callback function that receives Result.success() when operation succeed of
+   *   Result.failure(exception) if error
+   */
+  fun init(callback: (Result<Unit>) -> Unit)
+
+  /**
+   * Fetches a specific photo from Firestore by UUID
+   *
+   * @param uuid the UUID of the photo to fetch
+   * @param callback callback function that receives Result.success(DataPhoto) when operation
+   *   succeed of Result.failure(exception) if error
+   */
+  fun getPhoto(uuid: UUID, callback: (Result<DataPhoto>) -> Unit)
+
+  /**
+   * Converts a Bitmap to a Base64 encoded string.
+   *
+   * @param bitmap the Bitmap to convert.
+   * @return the Base64 encoded string.
+   */
+  fun bitmapToBase64(bitmap: Bitmap): String
+
+  /**
+   * Converts a Base64 encoded string to a Bitmap.
+   *
+   * @param base64 the Base64 encoded string to convert.
+   * @return the Bitmap.
+   */
+  fun base64ToBitmap(base64: String): Bitmap
+
+  /**
+   * Uploads a photo to Firestore.
+   *
+   * @param dataPhoto the photo data to upload.
+   * @param callback callback function that receives Unit if success or an an exception if error.
+   */
+  fun addPhoto(dataPhoto: DataPhoto, callback: (Result<Unit>) -> Unit)
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/profile/NewUserScreenTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/profile/NewUserScreenTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/profile/NewUserScreenTest.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/androidTest/java/com/android/bookswap/ui/profile/NewUserScreenTest.kt	
@@ -0,0 +1,93 @@
+package com.android.bookswap.ui.profile
+
+import androidx.compose.ui.test.assertHasClickAction
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.assertTextContains
+import androidx.compose.ui.test.assertTextEquals
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.compose.ui.test.performClick
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.navigation.Route
+import io.mockk.mockk
+import io.mockk.verify
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+class NewUserScreenTest {
+  @get:Rule val composeTestRule = createComposeRule()
+  private lateinit var navigationActions: NavigationActions
+
+  @Before
+  fun setUp() {
+    navigationActions = mockk(relaxed = true)
+  }
+
+  @Test
+  fun allComponentsAreDisplayedWithCorrectTexts() {
+    composeTestRule.setContent { NewUserScreen(navigationActions) }
+    composeTestRule
+        .onNodeWithTag("welcomeTxt")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextEquals("Welcome")
+
+    composeTestRule
+        .onNodeWithTag("personalInfoTxt")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextEquals("Please fill in your personal information to start BookSwapping")
+
+    composeTestRule
+        .onNodeWithTag("profilPics")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertHasClickAction()
+
+    composeTestRule
+        .onNodeWithTag("greetingTF")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Greeting")
+
+    composeTestRule
+        .onNodeWithTag("firstnameTF")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Firstname")
+
+    composeTestRule
+        .onNodeWithTag("lastnameTF")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Lastname")
+
+    composeTestRule
+        .onNodeWithTag("emailTF")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Email")
+
+    composeTestRule
+        .onNodeWithTag("phoneTF")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Phone")
+
+    composeTestRule
+        .onNodeWithTag("CreateButton")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextEquals("Create")
+        .assertHasClickAction()
+  }
+
+  @Test
+  fun clickOnCreateButtonNavigatesToMap() {
+    composeTestRule.setContent { NewUserScreen(navigationActions) }
+
+    composeTestRule.onNodeWithTag("CreateButton").performClick()
+    verify { navigationActions.navigateTo(Route.MAP) }
+  }
+}
Index: app/src/test/java/com/android/bookswap/model/map/BookManagerViewModelTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/model/map/BookManagerViewModelTest.kt b/app/src/test/java/com/android/bookswap/model/map/BookManagerViewModelTest.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/test/java/com/android/bookswap/model/map/BookManagerViewModelTest.kt	
@@ -0,0 +1,179 @@
+package com.android.bookswap.model.map
+
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.UserBooksWithLocation
+import com.android.bookswap.data.repository.UsersRepository
+import com.android.bookswap.data.source.network.BooksFirestoreSource
+import io.mockk.every
+import io.mockk.mockk
+import java.util.UUID
+import junit.framework.TestCase.assertEquals
+import kotlin.math.abs
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.first
+import kotlinx.coroutines.test.runTest
+import org.junit.Before
+import org.junit.Test
+
+class BookManagerViewModelTest {
+
+  private val user1 =
+      DataUser(
+          userUUID = UUID(1, 1),
+          bookList = listOf(UUID(1, 2), UUID(2, 1)),
+          longitude = 50.0,
+          latitude = 50.0)
+  private val user2 =
+      DataUser(
+          userUUID = UUID(2, 2), bookList = listOf(UUID(1, 1)), longitude = 0.0, latitude = 0.0)
+  private val users = listOf(user2, user1)
+
+  private val book1 =
+      DataBook(
+          uuid = UUID(1, 2),
+          title = "Book 1",
+          author = "Author 1",
+          description = "Description of Book 1",
+          rating = 5,
+          photo = "url_to_photo_1",
+          language = BookLanguages.ENGLISH,
+          isbn = "123-456-789",
+          genres = listOf(BookGenres.FICTION, BookGenres.HORROR))
+
+  private val book2 =
+      DataBook(
+          uuid = UUID(2, 1),
+          title = "Book 2",
+          author = "Author 2",
+          description = "Description of Book 2",
+          rating = 4,
+          photo = "url_to_photo_2",
+          language = BookLanguages.GERMAN,
+          isbn = "234-567-890",
+          genres = listOf(BookGenres.FICTION))
+
+  private val book3 =
+      DataBook(
+          uuid = UUID(1, 1),
+          title = "Book 3",
+          author = "Author 3",
+          description = "Description of Book 3",
+          rating = 4,
+          photo = "url_to_photo_3",
+          language = BookLanguages.GERMAN,
+          isbn = "234-567-890",
+          genres = listOf(BookGenres.NONFICTION, BookGenres.HORROR))
+
+  private val books = listOf(book3, book1, book2)
+
+  private val userBooksWithLocation1 =
+      UserBooksWithLocation(user1.userUUID, user1.longitude, user1.latitude, listOf(book1, book2))
+
+  private val userBooksWithLocation2 =
+      UserBooksWithLocation(user2.userUUID, user2.longitude, user2.latitude, listOf(book3))
+
+  private val userBooksWithLocation = listOf(userBooksWithLocation2, userBooksWithLocation1)
+
+  private val filteredBooksWithLocation =
+      listOf(
+          userBooksWithLocation2,
+          UserBooksWithLocation(user1.userUUID, user1.longitude, user1.latitude, emptyList()))
+
+  private val geolocation1 = listOf(0.0, 0.0)
+  private val geolocation2 = listOf(100.0, 100.0)
+
+  private val sortingTest: (Double, Double, Double, Double) -> Double =
+      { startLatitude, _, endLatitude, _ ->
+        abs(endLatitude - startLatitude)
+      }
+
+  private val mockBookRepository: BooksFirestoreSource = mockk()
+  private val mockUsersRepository: UsersRepository = mockk()
+  private val mockGeolocation1: IGeolocation = mockk()
+  private val mockGeolocation2: IGeolocation = mockk()
+  private val mockBookFilter: BookFilter = mockk()
+  private val mockBookFilterEmpty: BookFilter = mockk()
+
+  @Before
+  fun setup() {
+    every { mockBookRepository.getBook(any()) } answers
+        {
+          firstArg<(Result<List<DataBook>>) -> Unit>().invoke(Result.success(books))
+        }
+    every { mockUsersRepository.getUsers(any()) } answers
+        {
+          firstArg<(Result<List<DataUser>>) -> Unit>().invoke(Result.success(users))
+        }
+
+    every { mockGeolocation1.longitude } answers { MutableStateFlow(geolocation1[0]) }
+    every { mockGeolocation1.latitude } answers { MutableStateFlow(geolocation1[1]) }
+
+    every { mockGeolocation2.longitude } answers { MutableStateFlow(geolocation2[0]) }
+    every { mockGeolocation2.latitude } answers { MutableStateFlow(geolocation2[1]) }
+
+    every { mockBookFilter.genresFilter } answers { MutableStateFlow(listOf(BookGenres.HORROR)) }
+    every { mockBookFilter.languagesFilter } answers
+        {
+          MutableStateFlow(listOf(BookLanguages.GERMAN))
+        }
+    every { mockBookFilter.filterBooks(any()) } answers { listOf(book3) }
+
+    every { mockBookFilterEmpty.genresFilter } answers { MutableStateFlow(emptyList()) }
+    every { mockBookFilterEmpty.languagesFilter } answers { MutableStateFlow(emptyList()) }
+    every { mockBookFilterEmpty.filterBooks(any()) } answers { firstArg() }
+  }
+
+  @Test
+  fun defaultCaseNoFilterOrSortingNecessary() = runTest {
+    val bookManagerViewModel =
+        BookManagerViewModel(
+            mockGeolocation1, mockBookRepository, mockUsersRepository, mockBookFilterEmpty) {
+                _,
+                _,
+                _,
+                _ ->
+              0.0
+            }
+    bookManagerViewModel.startUpdatingBooks()
+    bookManagerViewModel.filteredBooks.first { it != emptyList<DataBook>() }
+    bookManagerViewModel.filteredUsers.first { it != emptyList<UserBooksWithLocation>() }
+    assertEquals(books, bookManagerViewModel.filteredBooks.value)
+    assertEquals(userBooksWithLocation, bookManagerViewModel.filteredUsers.value)
+    bookManagerViewModel.stopUpdatingBooks()
+  }
+
+  @Test
+  fun returnFilteredListOfBooks() = runTest {
+    val bookManagerViewModel =
+        BookManagerViewModel(
+            mockGeolocation1, mockBookRepository, mockUsersRepository, mockBookFilter, sortingTest)
+    bookManagerViewModel.startUpdatingBooks()
+    bookManagerViewModel.filteredBooks.first { it != emptyList<DataBook>() }
+    bookManagerViewModel.filteredUsers.first { it != emptyList<UserBooksWithLocation>() }
+    assertEquals(listOf(book3), bookManagerViewModel.filteredBooks.value)
+    assertEquals(filteredBooksWithLocation, bookManagerViewModel.filteredUsers.value)
+    bookManagerViewModel.stopUpdatingBooks()
+  }
+
+  @Test
+  fun sortTheUsers() = runTest {
+    val bookManagerViewModel =
+        BookManagerViewModel(
+            mockGeolocation2,
+            mockBookRepository,
+            mockUsersRepository,
+            mockBookFilterEmpty,
+            sortingTest)
+    bookManagerViewModel.startUpdatingBooks()
+    bookManagerViewModel.filteredBooks.first { it != emptyList<DataBook>() }
+    bookManagerViewModel.filteredUsers.first { it != emptyList<UserBooksWithLocation>() }
+    assertEquals(listOf(book1, book2, book3), bookManagerViewModel.filteredBooks.value)
+    assertEquals(
+        listOf(userBooksWithLocation1, userBooksWithLocation2),
+        bookManagerViewModel.filteredUsers.value)
+    bookManagerViewModel.stopUpdatingBooks()
+  }
+}
Index: app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreSourceTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreSourceTest.kt b/app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreSourceTest.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreSourceTest.kt	
@@ -0,0 +1,157 @@
+package com.android.bookswap.data.source.network
+
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.utils.assertBookEquals
+import com.google.android.gms.tasks.Tasks
+import com.google.firebase.firestore.CollectionReference
+import com.google.firebase.firestore.DocumentReference
+import com.google.firebase.firestore.DocumentSnapshot
+import com.google.firebase.firestore.FirebaseFirestore
+import com.google.firebase.firestore.QuerySnapshot
+import io.mockk.every
+import io.mockk.mockk
+import io.mockk.verify
+import java.util.UUID
+import org.junit.Assert.*
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.RobolectricTestRunner
+
+@RunWith(RobolectricTestRunner::class)
+class BooksFirestoreSourceTest {
+
+  private val mockFirestore: FirebaseFirestore = mockk()
+  private val mockCollectionReference: CollectionReference = mockk()
+  private val mockDocumentReference: DocumentReference = mockk()
+  private val mockDocumentSnapshot: DocumentSnapshot = mockk()
+  private val mockQuerySnapshot: QuerySnapshot = mockk()
+
+  private val testBook =
+      DataBook(
+          uuid = UUID.randomUUID(),
+          title = "Test Book",
+          author = "Test Author",
+          description = "Test Description",
+          rating = 5,
+          photo = "http://example.com/photo.jpg",
+          language = BookLanguages.ENGLISH,
+          isbn = "1234567890")
+
+  @Before
+  fun setUp() {
+    every { mockFirestore.collection(any()) }.returns(mockCollectionReference)
+    every { mockCollectionReference.document(any()) }.returns(mockDocumentReference)
+    every { mockCollectionReference.get() }.returns(Tasks.forResult(mockQuerySnapshot))
+
+    // Mock of snapshot
+    every { mockDocumentSnapshot.getString("title") }.returns(testBook.title)
+    every { mockDocumentSnapshot.getString("author") }.returns(testBook.author)
+    every { mockDocumentSnapshot.getString("description") }.returns(testBook.description)
+    every { mockDocumentSnapshot.getLong("rating") }.returns(testBook.rating?.toLong())
+    every { mockDocumentSnapshot.getString("photo") }.returns(testBook.photo)
+    every { mockDocumentSnapshot.getString("language") }.returns(testBook.language.name)
+    every { mockDocumentSnapshot.getString("isbn") }.returns(testBook.isbn)
+    every { mockDocumentSnapshot.getString("uuid") }.returns(testBook.uuid.toString())
+    every { mockDocumentSnapshot.get("genres") }.returns(emptyList<String>())
+  }
+
+  @Test
+  fun `book get returns correct result`() {
+    val bookSource = BooksFirestoreSource(mockFirestore)
+    bookSource.getBook(
+        callback = { result ->
+          assertTrue(result.isSuccess)
+          val books = result.getOrThrow()
+          // Assert that the fetched books match the expected values
+          assertTrue(books.isNotEmpty())
+          assertBookEquals(books.first(), testBook, true)
+        })
+
+    // Verify that Firestore collection was called
+    verify { mockCollectionReference.get() }
+  }
+
+  @Test
+  fun `delete call firestore delete`() {
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    // Arrange
+    every { mockDocumentReference.delete() }.returns(Tasks.forResult(null))
+
+    // Act
+    bookSource.deleteBooks(testBook.uuid, testBook) {}
+
+    // Assert
+    verify { mockDocumentReference.delete() }
+  }
+
+  @Test
+  fun `book set is success`() {
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    // Arrange
+    every { mockDocumentReference.set(testBook) }.returns(Tasks.forResult(null))
+
+    // Act
+    bookSource.addBook(testBook) { result -> assertTrue(result.isSuccess) }
+
+    // Verify Firestore set operation
+    verify { mockDocumentReference.set(testBook) }
+  }
+
+  @Test
+  fun `book update success`() {
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    // Arrange
+    every { mockDocumentReference.set(testBook) }.returns(Tasks.forResult(null))
+
+    // Act
+    bookSource.updateBook(testBook) { result -> assertTrue(result.isSuccess) }
+
+    // Verify Firestore update operation
+    verify { mockDocumentReference.set(testBook) }
+  }
+
+  @Test
+  fun `documentToBooks is valid`() {
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    // Act
+    val result = bookSource.documentToBooks(mockDocumentSnapshot)
+
+    // Assert
+    assertNotNull(result)
+    assertBookEquals(testBook, result)
+  }
+
+  @Test
+  fun `documentToBooks null when missing value`() {
+    // Arrange - Missing "Title"
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    every { mockDocumentSnapshot.getString("title") }.returns(null)
+
+    // Act
+    val result = bookSource.documentToBooks(mockDocumentSnapshot)
+
+    // Assert
+    assertNull(result)
+  }
+
+  @Test
+  fun `documentToBooks null when invalid value`() {
+    // Arrange - Invalid language value
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    every { mockDocumentSnapshot.getString("language") }.returns("INVALID_LANGUAGE")
+
+    // Act
+    val result = bookSource.documentToBooks(mockDocumentSnapshot)
+
+    // Assert
+    assertNull(result) // Should return null due to invalid language
+  }
+}
Index: app/src/test/java/com/android/bookswap/data/source/network/PhotoFirestoreSourceTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/source/network/PhotoFirestoreSourceTest.kt b/app/src/test/java/com/android/bookswap/data/source/network/PhotoFirestoreSourceTest.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/test/java/com/android/bookswap/data/source/network/PhotoFirestoreSourceTest.kt	
@@ -0,0 +1,142 @@
+package com.android.bookswap.data.source.network
+
+import android.content.Context
+import android.graphics.BitmapFactory
+import androidx.test.core.app.ApplicationProvider
+import com.android.bookswap.R
+import com.android.bookswap.data.DataPhoto
+import com.google.android.gms.tasks.Tasks
+import com.google.firebase.FirebaseApp
+import com.google.firebase.firestore.CollectionReference
+import com.google.firebase.firestore.DocumentReference
+import com.google.firebase.firestore.DocumentSnapshot
+import com.google.firebase.firestore.FirebaseFirestore
+import com.google.firebase.firestore.QuerySnapshot
+import java.util.UUID
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.ArgumentMatchers
+import org.mockito.Mock
+import org.mockito.Mockito.`when`
+import org.mockito.MockitoAnnotations
+import org.mockito.kotlin.doAnswer
+import org.mockito.kotlin.verify
+import org.robolectric.RobolectricTestRunner
+
+@RunWith(RobolectricTestRunner::class)
+class PhotoFirestoreSourceTest {
+  @Mock private lateinit var mockFirestore: FirebaseFirestore
+  @Mock private lateinit var mockCollectionReference: CollectionReference
+  @Mock private lateinit var mockDocumentReference: DocumentReference
+  @Mock private lateinit var mockDocumentSnapshot: DocumentSnapshot
+  @Mock private lateinit var mockQuerySnapshot: QuerySnapshot
+
+  private lateinit var PhotoFirestoreSource: PhotoFirestoreSource
+  private lateinit var testPhoto: DataPhoto
+
+  @Before
+  fun setUp() {
+    MockitoAnnotations.openMocks(this)
+
+    // Initialize Firebase if necessary
+    if (FirebaseApp.getApps(ApplicationProvider.getApplicationContext()).isEmpty()) {
+      FirebaseApp.initializeApp(ApplicationProvider.getApplicationContext())
+    }
+
+    PhotoFirestoreSource = PhotoFirestoreSource(mockFirestore)
+
+    `when`(mockFirestore.collection(ArgumentMatchers.anyString()))
+        .thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(ArgumentMatchers.anyString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
+
+    val context = ApplicationProvider.getApplicationContext<Context>()
+    val bitmap = BitmapFactory.decodeResource(context.resources, R.drawable.etranger_test)
+
+    testPhoto =
+        DataPhoto(
+            uuid = UUID.randomUUID(),
+            url = "", // Optional url field (don't know if it is really useful)
+            timestamp = System.currentTimeMillis(),
+            base64 = PhotoFirestoreSource.bitmapToBase64(bitmap))
+  }
+
+  @Test
+  fun getPhoto_callsFirestoreGet() {
+    // Arrange
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
+
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(testPhoto.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("url")).thenReturn(testPhoto.url)
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(testPhoto.timestamp)
+    `when`(mockDocumentSnapshot.getString("base64")).thenReturn(testPhoto.base64)
+
+    // Act
+    PhotoFirestoreSource.getPhoto(
+        testPhoto.uuid,
+        callback = { result ->
+          assert(result.isSuccess)
+          val photo = result.getOrThrow()
+          // Assert that the fetched photo matches the expected values
+          assert(photo.uuid == testPhoto.uuid)
+          assert(photo.url == testPhoto.url)
+          assert(photo.timestamp == testPhoto.timestamp)
+          assert(photo.base64 == testPhoto.base64)
+        })
+
+    // Verify Firestore collection was called
+    verify(mockCollectionReference).document(testPhoto.uuid.toString())
+  }
+
+  @Test
+  fun addPhoto_callsFirestoreSet_andOnSuccess() {
+    // Arrange
+    doAnswer { Tasks.forResult(null) }.`when`(mockDocumentReference).set(testPhoto)
+
+    // Act
+    PhotoFirestoreSource.addPhoto(
+        testPhoto,
+        callback = { result ->
+          // Assert success callback
+          assert(result.isSuccess)
+        })
+    // Verify Firestore set operation
+    verify(mockDocumentReference).set(testPhoto)
+  }
+
+  @Test
+  fun documentToPhoto_returnsDataPhoto_whenDocumentIsValid() {
+    // Arrange
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(testPhoto.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("url")).thenReturn(testPhoto.url)
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(testPhoto.timestamp)
+    `when`(mockDocumentSnapshot.getString("base64")).thenReturn(testPhoto.base64)
+
+    // Act
+    val result = PhotoFirestoreSource.documentToPhoto(mockDocumentSnapshot)
+
+    // Assert
+    assert(result != null)
+    assert(result?.uuid == testPhoto.uuid)
+    assert(result?.url == testPhoto.url)
+    assert(result?.timestamp == testPhoto.timestamp)
+    assert(result?.base64 == testPhoto.base64)
+  }
+
+  @Test
+  fun documentToPhoto_returnsNull_whenRequiredFieldIsMissing() {
+    // Arrange - Missing "base64" field
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(testPhoto.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("url")).thenReturn(testPhoto.url)
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(testPhoto.timestamp)
+    `when`(mockDocumentSnapshot.getString("base64")).thenReturn(null)
+
+    // Act
+    val result = PhotoFirestoreSource.documentToPhoto(mockDocumentSnapshot)
+
+    // Assert
+    assert(result == null) // Should return null due to missing "base64"
+  }
+}
Index: app/src/test/java/com/android/bookswap/data/source/network/ImageToDataSourceTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/source/network/ImageToDataSourceTest.kt b/app/src/test/java/com/android/bookswap/data/source/network/ImageToDataSourceTest.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/test/java/com/android/bookswap/data/source/network/ImageToDataSourceTest.kt	
@@ -0,0 +1,130 @@
+package com.android.bookswap.data.source.network
+
+import com.android.bookswap.R
+import com.android.bookswap.data.source.api.ApiService
+import io.mockk.every
+import io.mockk.invoke
+import io.mockk.mockk
+import io.mockk.verify
+import junit.framework.TestCase.assertEquals
+import junit.framework.TestCase.fail
+import org.junit.Assert.assertTrue
+import org.junit.Before
+import org.junit.Test
+
+class ImageToDataSourceTest {
+  private lateinit var apiService: ApiService
+  private lateinit var imageToDataSource: ImageToDataSource
+  private val imageUrl = "https://example.com/book-cover.jpg"
+  private val expectedPrompt = "${R.string.prompt} $imageUrl"
+
+  @Before
+  fun setup() {
+    apiService = mockk()
+    imageToDataSource = ImageToDataSource(apiService)
+  }
+
+  @Test
+  fun `analyzeImage should return parsed data on success`() {
+
+    // Mock API response
+    val mockResponse =
+        """
+        {
+          "title": "Example Title",
+          "author": "Example Author",
+          "description": "An example description of the book.",
+          "language": "EN",
+          "isbn": "1234567890"
+        }
+    """
+            .trimIndent()
+
+    // Mock successful response
+    every {
+      apiService.sendChatRequest(
+          listOf(expectedPrompt), // This should now match the exact prompt
+          captureLambda(),
+          any())
+    } answers { lambda<(String) -> Unit>().invoke(mockResponse) }
+
+    // Test analyzeImage
+    imageToDataSource.analyzeImage(
+        imageUrl,
+        onSuccess = { result ->
+          assertEquals("Example Title", result["title"])
+          assertEquals("Example Author", result["author"])
+          assertEquals("An example description of the book.", result["description"])
+          assertEquals("EN", result["language"])
+          assertEquals("1234567890", result["isbn"])
+        },
+        onError = { fail("Expected success callback but got error: $it") })
+
+    // Verify that sendChatRequest was called with the exact prompt
+    verify { apiService.sendChatRequest(listOf(expectedPrompt), any(), any()) }
+  }
+
+  @Test
+  fun `analyzeImage should call onError when API fails`() {
+    val errorMessage = "Network error"
+    every { apiService.sendChatRequest(any(), any(), captureLambda()) } answers
+        {
+          lambda<(String) -> Unit>().invoke(errorMessage)
+        }
+
+    val imageUrl = "https://example.com/book-cover.jpg"
+
+    // Test analyzeImage
+    imageToDataSource.analyzeImage(
+        imageUrl,
+        onSuccess = { fail("Expected error callback but got success") },
+        onError = { error -> assertEquals("API Request Error: $errorMessage", error) })
+
+    // Verify that sendChatRequest was called
+    verify { apiService.sendChatRequest(any(), any(), any()) }
+  }
+
+  @Test
+  fun `analyzeImage should handle partial data in response`() {
+    val mockPartialResponse =
+        """
+        {
+          "title": "Partial Title",
+          "author": "Partial Author",
+          "language": "EN"
+        }
+    """
+            .trimIndent()
+
+    every { apiService.sendChatRequest(listOf(expectedPrompt), captureLambda(), any()) } answers
+        {
+          lambda<(String) -> Unit>().invoke(mockPartialResponse)
+        }
+
+    imageToDataSource.analyzeImage(
+        imageUrl,
+        onSuccess = { result ->
+          assertEquals("Partial Title", result["title"])
+          assertEquals("Partial Author", result["author"])
+          assertEquals("N/A", result["description"]) // Missing field should default to "N/A"
+          assertEquals("EN", result["language"])
+          assertEquals("N/A", result["isbn"]) // Missing field should default to "N/A"
+        },
+        onError = { fail("Expected success callback but got error: $it") })
+  }
+
+  @Test
+  fun `analyzeImage should handle non-JSON response from API`() {
+    val mockNonJsonResponse = "This is not JSON"
+
+    every { apiService.sendChatRequest(listOf(expectedPrompt), captureLambda(), any()) } answers
+        {
+          lambda<(String) -> Unit>().invoke(mockNonJsonResponse)
+        }
+
+    imageToDataSource.analyzeImage(
+        imageUrl,
+        onSuccess = { fail("Expected error callback but got success with data: $it") },
+        onError = { error -> assertTrue(error.contains("Parsing error")) })
+  }
+}
Index: app/src/test/java/com/android/bookswap/data/source/api/ChatGptApiCallTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/source/api/ChatGptApiCallTest.kt b/app/src/test/java/com/android/bookswap/data/source/api/ChatGptApiCallTest.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/test/java/com/android/bookswap/data/source/api/ChatGptApiCallTest.kt	
@@ -0,0 +1,51 @@
+package com.android.bookswap.data.source.api
+
+import android.content.Context
+import com.android.volley.Request
+import com.android.volley.RequestQueue
+import com.android.volley.toolbox.Volley
+import io.mockk.every
+import io.mockk.mockk
+import io.mockk.mockkStatic
+import junit.framework.TestCase.assertEquals
+import org.junit.Before
+import org.junit.Test
+
+class ChatGptApiCallTest {
+  private lateinit var mockContext: Context
+  private lateinit var mockRequestQueue: RequestQueue
+  private lateinit var chatGPTApiService: ChatGPTApiService
+  private lateinit var request: Request<*>
+
+  @Before
+  fun setUp() {
+
+    mockContext = mockk()
+
+    mockRequestQueue = mockk()
+    request = mockk()
+
+    mockkStatic(Volley::class)
+    every { Volley.newRequestQueue(any()) } returns mockRequestQueue
+
+    chatGPTApiService = ChatGPTApiService(mockContext, mode = false)
+  }
+
+  @Test
+  fun `test sendChatRequest adds request to requestQueue`() {
+
+    val userMessages = listOf("Hello")
+    val onSuccess: (String) -> Unit = mockk(relaxed = true)
+    val onError: (String) -> Unit = mockk(relaxed = true)
+    var check = 0
+    every { mockRequestQueue.add(any<Request<*>>()) } answers
+        {
+          check++
+          return@answers request
+        }
+
+    chatGPTApiService.sendChatRequest(userMessages, onSuccess, onError)
+
+    assertEquals(1, check)
+  }
+}
Index: app/src/main/java/com/android/bookswap/ui/components/TopAppBarComponent.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/components/TopAppBarComponent.kt b/app/src/main/java/com/android/bookswap/ui/components/TopAppBarComponent.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/ui/components/TopAppBarComponent.kt	
@@ -0,0 +1,28 @@
+package com.android.bookswap.ui.components
+
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.Text
+import androidx.compose.material3.TopAppBar
+import androidx.compose.material3.TopAppBarDefaults
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.platform.testTag
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.profile.ProfileIcon
+import com.android.bookswap.ui.theme.ColorVariable
+
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun TopAppBarComponent(
+    modifier: Modifier = Modifier,
+    navigationActions: NavigationActions,
+    title: String = navigationActions.currentRoute()
+) {
+  TopAppBar(
+      title = { Text(text = title, Modifier.testTag("TopAppBar_Title")) },
+      modifier = modifier.testTag("TopAppBar"),
+      { BackButtonComponent(navActions = navigationActions) },
+      { ProfileIcon(navigationActions = navigationActions) },
+      TopAppBarDefaults.windowInsets,
+      TopAppBarDefaults.topAppBarColors(ColorVariable.BackGround))
+}
Index: app/src/main/java/com/android/bookswap/ui/profile/NewUser.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/profile/NewUser.kt b/app/src/main/java/com/android/bookswap/ui/profile/NewUser.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/ui/profile/NewUser.kt	
@@ -0,0 +1,186 @@
+package com.android.bookswap.ui.profile
+
+import androidx.compose.foundation.background
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.PaddingValues
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.layout.width
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.foundation.text.KeyboardOptions
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.filled.AccountCircle
+import androidx.compose.material3.Button
+import androidx.compose.material3.ButtonDefaults
+import androidx.compose.material3.Card
+import androidx.compose.material3.Icon
+import androidx.compose.material3.IconButton
+import androidx.compose.material3.OutlinedTextField
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.text.TextStyle
+import androidx.compose.ui.text.font.FontWeight
+import androidx.compose.ui.text.input.KeyboardType
+import androidx.compose.ui.text.style.TextAlign
+import androidx.compose.ui.unit.dp
+import androidx.compose.ui.unit.sp
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.navigation.Route
+import com.android.bookswap.ui.theme.ColorVariable
+
+// Constants for magic numbers used in the UI layout
+private val CONTENT_PADDING = 16.dp
+private val ICON_SIZE = 80.dp
+private val TEXT_PADDING = PaddingValues(8.dp, 4.dp)
+private val BUTTON_WIDTH = 200.dp
+private val BUTTON_HEIGHT = 50.dp
+private val WELCOME_FONT_SIZE = 40.sp
+private val INFO_FONT_SIZE = 18.sp
+private val WELCOME_FONT_WEIGHT = FontWeight(600)
+private val INFO_FONT_WEIGHT = FontWeight(400)
+
+/**
+ * NewUserScreen is the screen where the user can create a new account by filling in his personal
+ * information
+ *
+ * @param navigationActions: NavigationActions
+ */
+@Composable
+fun NewUserScreen(navigationActions: NavigationActions) {
+  val email = remember { mutableStateOf("") }
+  val phone = remember { mutableStateOf("") }
+  val greeting = remember { mutableStateOf("") }
+  val firstName = remember { mutableStateOf("") }
+  val lastName = remember { mutableStateOf("") }
+
+  LazyColumn(
+      contentPadding = PaddingValues(CONTENT_PADDING),
+      modifier =
+          Modifier.fillMaxSize()
+              .background(color = ColorVariable.BackGround)
+              .testTag("chat_messageList")) {
+        item {
+          // The welcome text
+          Text(
+              "Welcome",
+              modifier = Modifier.testTag("welcomeTxt").fillMaxWidth(),
+              style =
+                  TextStyle(
+                      color = ColorVariable.Accent,
+                      fontWeight = WELCOME_FONT_WEIGHT,
+                      textAlign = TextAlign.Center,
+                      fontSize = WELCOME_FONT_SIZE,
+                  ))
+        }
+        item {
+          // The personal information text
+          Text(
+              "Please fill in your personal information to start BookSwapping",
+              modifier = Modifier.testTag("personalInfoTxt").fillMaxWidth(),
+              style =
+                  TextStyle(
+                      color = ColorVariable.Accent,
+                      fontWeight = INFO_FONT_WEIGHT,
+                      textAlign = TextAlign.Center,
+                      fontSize = INFO_FONT_SIZE,
+                  ))
+        }
+        item {
+          // The card containing the form to fill in the personal information
+          Card(
+              Modifier.testTag("editProfileContainer").background(ColorVariable.BackGround),
+              colors =
+                  androidx.compose.material3.CardDefaults.cardColors()
+                      .copy(containerColor = ColorVariable.BackGround)) {
+                Column(
+                    Modifier.fillMaxWidth()
+                        .padding(CONTENT_PADDING)
+                        .background(ColorVariable.BackGround),
+                    Arrangement.Center,
+                    Alignment.CenterHorizontally) {
+                      IconButton(
+                          onClick = { /* TODO */},
+                          modifier = Modifier.size(ICON_SIZE).testTag("profilPics")) {
+                            Icon(
+                                imageVector = Icons.Default.AccountCircle,
+                                contentDescription = "profile picture",
+                                tint = ColorVariable.Accent,
+                                modifier = Modifier.size(ICON_SIZE))
+                          }
+                      OutlinedTextField(
+                          greeting.value,
+                          { greeting.value = it },
+                          Modifier.testTag("greetingTF").fillMaxWidth().padding(TEXT_PADDING),
+                          label = { Text("Greeting") },
+                          placeholder = { Text("Mr.", Modifier, Color.Gray) },
+                          keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Text),
+                          singleLine = true)
+
+                      OutlinedTextField(
+                          firstName.value,
+                          { firstName.value = it },
+                          Modifier.testTag("firstnameTF").fillMaxWidth().padding(TEXT_PADDING),
+                          label = { Text("Firstname") },
+                          placeholder = { Text("John", Modifier, Color.Gray) },
+                          keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Text),
+                          singleLine = true)
+
+                      OutlinedTextField(
+                          lastName.value,
+                          { lastName.value = it },
+                          Modifier.testTag("lastnameTF").fillMaxWidth().padding(TEXT_PADDING),
+                          label = { Text("Lastname") },
+                          placeholder = { Text("Doe", Modifier, Color.Gray) },
+                          keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Text),
+                          singleLine = true)
+
+                      OutlinedTextField(
+                          email.value,
+                          { email.value = it },
+                          Modifier.testTag("emailTF").fillMaxWidth().padding(TEXT_PADDING),
+                          label = { Text("Email") },
+                          placeholder = { Text("John.Doe@example.com", Modifier, Color.Gray) },
+                          keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),
+                          singleLine = true)
+
+                      OutlinedTextField(
+                          phone.value,
+                          { phone.value = it },
+                          Modifier.testTag("phoneTF").fillMaxWidth().padding(TEXT_PADDING),
+                          label = { Text("Phone") },
+                          placeholder = { Text("+4122345678", Modifier, Color.Gray) },
+                          keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Phone),
+                          singleLine = true)
+                    }
+              }
+        }
+        item {
+          Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
+            Button(
+                onClick = { navigationActions.navigateTo(Route.MAP) },
+                colors = ButtonDefaults.buttonColors(ColorVariable.Primary),
+                modifier =
+                    Modifier.width(BUTTON_WIDTH).height(BUTTON_HEIGHT).testTag("CreateButton")) {
+                  Text(
+                      text = "Create",
+                      textAlign = TextAlign.Center,
+                      style =
+                          TextStyle(
+                              color = ColorVariable.BackGround,
+                          ))
+                }
+          }
+        }
+      }
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/books/edit/EditBookTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/books/edit/EditBookTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/books/edit/EditBookTest.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/androidTest/java/com/android/bookswap/ui/books/edit/EditBookTest.kt	
@@ -0,0 +1,161 @@
+package com.android.bookswap.ui.books.edit
+
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.assertTextContains
+import androidx.compose.ui.test.assertTextEquals
+import androidx.compose.ui.test.hasTestTag
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.compose.ui.test.performClick
+import androidx.compose.ui.test.performScrollToNode
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.source.network.BooksFirestoreSource
+import com.android.bookswap.ui.navigation.NavigationActions
+import io.mockk.MockKAnnotations
+import io.mockk.every
+import io.mockk.impl.annotations.MockK
+import java.util.UUID
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+class EditBookScreenTest {
+
+  @MockK private lateinit var booksRepository: BooksFirestoreSource
+
+  @MockK private lateinit var navigationActions: NavigationActions
+
+  @get:Rule val composeTestRule = createComposeRule()
+
+  private val sampleBook =
+      DataBook(
+          uuid = UUID.randomUUID(),
+          title = "Sample Book",
+          author = "Sample Author",
+          description = "Sample Description",
+          rating = 4,
+          photo = "sample_photo_url",
+          language = BookLanguages.ENGLISH,
+          isbn = "123456789",
+          genres = listOf(BookGenres.FANTASY))
+
+  @Before
+  fun setUp() {
+    MockKAnnotations.init(this)
+
+    every { navigationActions.currentRoute() } returns "EDIT_BOOK"
+  }
+
+  @Test
+  fun displayEditScreenComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("editBookScreen").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditTitleComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("editBookTitle").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditTitleValueComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("editBookTitle").assertTextEquals("Edit your Book")
+  }
+
+  @Test
+  fun displayEditButtonComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("goBackButton").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditSaveValueComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule
+        .onNodeWithTag("editBookScreenColumn")
+        .performScrollToNode(hasTestTag("bookSave"))
+    composeTestRule.onNodeWithTag("bookSave").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("bookSave").assertTextEquals("Save")
+  }
+
+  @Test
+  fun displayEditDeleteValueComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule
+        .onNodeWithTag("editBookScreenColumn")
+        .performScrollToNode(hasTestTag("bookDelete"))
+    composeTestRule.onNodeWithTag("bookDelete").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("bookDelete").assertTextEquals("Delete")
+  }
+
+  @Test
+  fun displayEditBookTitleComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("inputBookTitle").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookAuthorComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookAuthor").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookDescriptionComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookDescription").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookRatingComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookRating").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookPhotoComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookPhoto").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookLanguageComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookLanguage").assertIsDisplayed()
+  }
+
+  @Test
+  fun inputsHaveInitialValue() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("inputBookTitle").assertTextContains(sampleBook.title)
+    composeTestRule.onNodeWithTag("inputBookAuthor").assertTextContains(sampleBook.author ?: "")
+    composeTestRule
+        .onNodeWithTag("inputBookDescription")
+        .assertTextContains(sampleBook.description ?: "")
+    composeTestRule.onNodeWithTag("inputBookPhoto").assertTextContains(sampleBook.photo ?: "")
+    composeTestRule
+        .onNodeWithTag("inputBookLanguage")
+        .assertTextContains(sampleBook.language.toString())
+  }
+
+  @Test
+  fun genreDropdownWorks() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    // opens genre dropdown and select a genre
+    composeTestRule.onNodeWithTag("GenreDropdown").performClick()
+    composeTestRule.onNodeWithTag("GenreDropdownItem_Fantasy").performClick()
+
+    // verify the selected genre
+    composeTestRule.onNodeWithTag("SelectedGenre").assertTextContains("Fantasy")
+  }
+}
Index: app/src/test/java/com/android/bookswap/utils/BookUtils.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/utils/BookUtils.kt b/app/src/test/java/com/android/bookswap/utils/BookUtils.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/test/java/com/android/bookswap/utils/BookUtils.kt	
@@ -0,0 +1,15 @@
+package com.android.bookswap.utils
+
+import com.android.bookswap.data.DataBook
+import org.junit.Assert.assertEquals
+
+/**
+ * Assert that two books are identical (uuid can be checked or not)
+ *
+ * @param expected the expected result
+ * @param result the result
+ * @param strict true if the two books should have the same UUID
+ */
+fun assertBookEquals(expected: DataBook, result: DataBook?, strict: Boolean = false) {
+  assertEquals(expected, if (strict) result else result?.copy(uuid = expected.uuid))
+}
Index: app/src/main/res/xml/filepaths.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/xml/filepaths.xml b/app/src/main/res/xml/filepaths.xml
new file mode 100644
--- /dev/null	
+++ b/app/src/main/res/xml/filepaths.xml	
@@ -0,0 +1,4 @@
+<paths>
+    <!-- creates a reference to the cache folder that the system maintains -->
+    <cache-path name="temporary_camera_images" path="/" />
+</paths>
\ No newline at end of file
Index: app/src/androidTest/java/com/android/bookswap/ui/authentication/LoginTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.authentication\n\nimport androidx.compose.ui.test.assertHasClickAction\nimport androidx.compose.ui.test.assertIsDisplayed\nimport androidx.compose.ui.test.assertTextEquals\nimport androidx.compose.ui.test.junit4.createAndroidComposeRule\nimport androidx.compose.ui.test.onNodeWithTag\nimport androidx.compose.ui.test.performClick\nimport androidx.test.espresso.intent.Intents\nimport androidx.test.espresso.intent.Intents.intended\nimport androidx.test.espresso.intent.matcher.IntentMatchers.toPackage\nimport androidx.test.ext.junit.runners.AndroidJUnit4\nimport com.android.bookswap.MainActivity\nimport com.kaspersky.kaspresso.testcases.api.testcase.TestCase\nimport org.junit.After\nimport org.junit.Before\nimport org.junit.Rule\nimport org.junit.Test\nimport org.junit.runner.RunWith\n\n@RunWith(AndroidJUnit4::class)\nclass LoginTest : TestCase() {\n  @get:Rule val composeTestRule = createAndroidComposeRule<MainActivity>()\n\n  // The IntentsTestRule may not reliable.\n  @Before\n  fun setUp() {\n    Intents.init()\n  }\n\n  // Release Intents after each test\n  @After\n  fun tearDown() {\n    Intents.release()\n  }\n\n  @Test\n  fun titleAndButtonAreCorrectlyDisplayed() {\n    composeTestRule.onNodeWithTag(\"login_loginTitle1\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"login_loginTitle1\").assertTextEquals(\"Welcome to\")\n    composeTestRule.onNodeWithTag(\"login_loginTitle2\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"login_loginTitle2\").assertTextEquals(\"BookSwap\")\n\n    composeTestRule.onNodeWithTag(\"loginButton\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"loginButton\").assertHasClickAction()\n  }\n\n  @Test\n  fun googleSignInReturnsValidActivityResult() {\n    composeTestRule.onNodeWithTag(\"loginButton\").performClick()\n    composeTestRule.waitForIdle()\n    // assert that an Intent resolving to Google Mobile Services has been sent (for sign-in)\n    intended(toPackage(\"com.google.android.gms\"))\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/authentication/LoginTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/authentication/LoginTest.kt
--- a/app/src/androidTest/java/com/android/bookswap/ui/authentication/LoginTest.kt	
+++ b/app/src/androidTest/java/com/android/bookswap/ui/authentication/LoginTest.kt	
@@ -3,14 +3,15 @@
 import androidx.compose.ui.test.assertHasClickAction
 import androidx.compose.ui.test.assertIsDisplayed
 import androidx.compose.ui.test.assertTextEquals
-import androidx.compose.ui.test.junit4.createAndroidComposeRule
+import androidx.compose.ui.test.junit4.createComposeRule
 import androidx.compose.ui.test.onNodeWithTag
 import androidx.compose.ui.test.performClick
+import androidx.navigation.compose.rememberNavController
 import androidx.test.espresso.intent.Intents
 import androidx.test.espresso.intent.Intents.intended
 import androidx.test.espresso.intent.matcher.IntentMatchers.toPackage
 import androidx.test.ext.junit.runners.AndroidJUnit4
-import com.android.bookswap.MainActivity
+import com.android.bookswap.ui.navigation.NavigationActions
 import com.kaspersky.kaspresso.testcases.api.testcase.TestCase
 import org.junit.After
 import org.junit.Before
@@ -20,8 +21,7 @@
 
 @RunWith(AndroidJUnit4::class)
 class LoginTest : TestCase() {
-  @get:Rule val composeTestRule = createAndroidComposeRule<MainActivity>()
-
+  @get:Rule val composeTestRule = createComposeRule()
   // The IntentsTestRule may not reliable.
   @Before
   fun setUp() {
@@ -36,6 +36,11 @@
 
   @Test
   fun titleAndButtonAreCorrectlyDisplayed() {
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      SignInScreen(navigationActions)
+    }
     composeTestRule.onNodeWithTag("login_loginTitle1").assertIsDisplayed()
     composeTestRule.onNodeWithTag("login_loginTitle1").assertTextEquals("Welcome to")
     composeTestRule.onNodeWithTag("login_loginTitle2").assertIsDisplayed()
@@ -47,6 +52,11 @@
 
   @Test
   fun googleSignInReturnsValidActivityResult() {
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      SignInScreen(navigationActions)
+    }
     composeTestRule.onNodeWithTag("loginButton").performClick()
     composeTestRule.waitForIdle()
     // assert that an Intent resolving to Google Mobile Services has been sent (for sign-in)
Index: app/src/main/java/com/android/bookswap/ui/map/Map.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.map\n\nimport androidx.compose.foundation.BorderStroke\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\nimport androidx.compose.foundation.gestures.detectVerticalDragGestures\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxHeight\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.heightIn\nimport androidx.compose.foundation.layout.offset\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.layout.wrapContentSize\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.itemsIndexed\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Star\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.HorizontalDivider\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.input.pointer.pointerInput\nimport androidx.compose.ui.platform.LocalConfiguration\nimport androidx.compose.ui.platform.testTag\nimport androidx.compose.ui.semantics.SemanticsPropertyKey\nimport androidx.compose.ui.semantics.SemanticsPropertyReceiver\nimport androidx.compose.ui.semantics.semantics\nimport androidx.compose.ui.unit.IntOffset\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport com.android.bookswap.data.DataBook\nimport com.android.bookswap.model.map.BookFilter\nimport com.android.bookswap.model.map.DefaultGeolocation\nimport com.android.bookswap.model.map.IGeolocation\nimport com.android.bookswap.ui.navigation.BOTTOM_NAV_HEIGHT\nimport com.android.bookswap.ui.navigation.BottomNavigationMenu\nimport com.android.bookswap.ui.navigation.List_Navigation_Bar_Destinations\nimport com.android.bookswap.ui.navigation.NavigationActions\nimport com.android.bookswap.ui.navigation.Screen\nimport com.android.bookswap.ui.theme.ColorVariable\nimport com.google.android.gms.maps.model.BitmapDescriptorFactory\nimport com.google.android.gms.maps.model.CameraPosition\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.*\nimport com.google.maps.android.compose.GoogleMap\nimport kotlin.math.roundToInt\nimport kotlinx.coroutines.launch\n\nconst val INIT_ZOOM = 10F\n\nval CameraPositionKey = SemanticsPropertyKey<CameraPositionState>(\"CameraPosition\")\nvar SemanticsPropertyReceiver.cameraPosition by CameraPositionKey\n\n/**\n * Composable function to display a map with user locations and associated book information.\n *\n * This screen renders a GoogleMap that shows books locations as markers. Upon clicking a marker, it\n * displays a custom info window with the list of books at this location.\n *\n * @param listUser List of users [TempUser] to display on the map, each containing their location\n *   (latitude, longitude) and a list of books they own (listBook). This argument will later be\n *   deleted as the code should in the future use a class to get the user from the database.\n * @param selectedUser An optional user [TempUser] to be initially selected and focused on the map.\n *   This users info window will be shown if not null.\n * @param navigationActions An instance of [NavigationActions] to handle navigation actions.\n * @param bookFilter An instance of [BookFilter] to filter the books displayed on the map.\n * @param geolocation An instance of [IGeolocation] to get the user's current location.\n */\n@Composable\nfun MapScreen(\n    listUser: List<TempUser>,\n    selectedUser: TempUser? = null,\n    navigationActions: NavigationActions,\n    bookFilter: BookFilter,\n    geolocation: IGeolocation = DefaultGeolocation(),\n) {\n  val cameraPositionState = rememberCameraPositionState()\n  // Get the user's current location\n  val latitude by remember { geolocation.latitude }\n  val longitude by remember { geolocation.longitude }\n  // Start location updates\n  LaunchedEffect(Unit) {\n    geolocation.startLocationUpdates()\n    cameraPositionState.position =\n        CameraPosition.fromLatLngZoom(LatLng(latitude, longitude), INIT_ZOOM)\n  }\n  // Stop location updates when the screen is disposed\n  DisposableEffect(Unit) { onDispose { geolocation.stopLocationUpdates() } }\n\n  var mutableStateSelectedUser by remember { mutableStateOf(selectedUser) }\n  var markerScreenPosition by remember { mutableStateOf<Offset?>(null) }\n  val listAllBooks = listUser.flatMap { it.listBook }\n\n  // Filter the books based on the selected filters\n  val genresFilter by bookFilter.genresFilter.collectAsState()\n  val languagesFilter by bookFilter.languagesFilter.collectAsState()\n\n  val filteredBooks =\n      remember(genresFilter, languagesFilter) { bookFilter.filterBooks(listAllBooks) }\n\n  val filteredUsers =\n      listUser.filter { user -> user.listBook.any { book -> filteredBooks.contains(book) } }\n\n  // compute the position of the marker on the screen given the camera position and the marker's\n  // position on the map\n  fun computePositionOfMarker(cameraPositionState: CameraPositionState, markerLatLng: LatLng) {\n    val projection = cameraPositionState.projection\n    projection?.let {\n      val screenPosition = it.toScreenLocation(markerLatLng)\n      markerScreenPosition = Offset(screenPosition.x.toFloat(), screenPosition.y.toFloat())\n    }\n  }\n\n  if (mutableStateSelectedUser != null) {\n    computePositionOfMarker(\n        cameraPositionState,\n        LatLng(mutableStateSelectedUser!!.latitude, mutableStateSelectedUser!!.longitude))\n  }\n\n  val coroutineScope = rememberCoroutineScope()\n\n  // Recalculate marker screen position during camera movement\n  LaunchedEffect(cameraPositionState.position) {\n    if (mutableStateSelectedUser != null) {\n      computePositionOfMarker(\n          cameraPositionState,\n          LatLng(mutableStateSelectedUser!!.latitude, mutableStateSelectedUser!!.longitude))\n    }\n  }\n\n  Scaffold(\n      modifier = Modifier.testTag(\"mapScreen\"),\n      bottomBar = {\n        BottomNavigationMenu(\n            onTabSelect = { destination -> navigationActions.navigateTo(destination) },\n            tabList = List_Navigation_Bar_Destinations,\n            selectedItem = navigationActions.currentRoute())\n      },\n      content = { pd ->\n        GoogleMap(\n            onMapClick = { mutableStateSelectedUser = null },\n            modifier =\n                Modifier.fillMaxSize().padding(pd).testTag(\"mapGoogleMap\").semantics {\n                  cameraPosition = cameraPositionState\n                },\n            cameraPositionState = cameraPositionState,\n            uiSettings = MapUiSettings(zoomControlsEnabled = false),\n        ) {\n          // Marker for user's current location\n          if (!latitude.isNaN() && !longitude.isNaN()) {\n            Marker(\n                state = MarkerState(position = LatLng(latitude, longitude)),\n                title = \"Your Location\",\n                icon = BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_BLUE))\n          }\n          filteredUsers\n              .filter { !it.longitude.isNaN() && !it.latitude.isNaN() && it.listBook.isNotEmpty() }\n              .forEach { item ->\n                val markerState = MarkerState(position = LatLng(item.latitude, item.longitude))\n\n                Marker(\n                    state = markerState,\n                    onClick = {\n                      mutableStateSelectedUser = item\n                      coroutineScope.launch {\n                        computePositionOfMarker(cameraPositionState, markerState.position)\n                      }\n                      false\n                    })\n              }\n        }\n        FilterButton { navigationActions.navigateTo(Screen.FILTER) }\n\n        // Custom info window linked to the marker\n        markerScreenPosition?.let { screenPos ->\n          mutableStateSelectedUser?.let { user ->\n            CustomInfoWindow(\n                modifier =\n                    Modifier.offset {\n                      IntOffset(screenPos.x.roundToInt(), screenPos.y.roundToInt())\n                    },\n                userBooks = bookFilter.filterBooks(user.listBook))\n          }\n        }\n        // Draggable Bottom List\n        DraggableMenu(filteredBooks)\n      })\n}\n\nconst val PADDING_VERTICAL_DP = 4\nconst val PADDING_HORIZONTAL_DP = 8\nconst val DIVIDER_THICKNESS_DP = 1\nconst val CARD_CORNER_RADIUS = 10\nconst val CARD_WIDTH_DP = 200\nconst val CARD_HEIGHT_DP = CARD_WIDTH_DP * 2\n\nconst val PRIMARY_TEXT_FONT_SP = 20\nconst val SECONDARY_TEXT_FONT_SP = 16\n\n/**\n * Composable function to display a custom info window for a selected book's list marker on the map.\n *\n * This function creates a card that shows detailed information about a user's list of books when\n * the corresponding map marker is clicked.\n *\n * @param modifier A [Modifier] to apply to the card containing the custom info window. It can be\n *   used to modify the position, size, and appearance of the info window, but is mainly intended to\n *   give the position of the CustomInfoWindow. Default is `Modifier`.\n * @param user The `TempUser` object containing the list of books to be displayed inside the info\n *   window.\n */\n@Composable\nprivate fun CustomInfoWindow(modifier: Modifier = Modifier, userBooks: List<DataBook>) {\n  Card(\n      modifier =\n          modifier\n              .wrapContentSize()\n              .width(CARD_WIDTH_DP.dp)\n              .border(\n                  BorderStroke(width = DIVIDER_THICKNESS_DP.dp, color = ColorVariable.Accent),\n                  shape =\n                      RoundedCornerShape(\n                          0.dp,\n                          CARD_CORNER_RADIUS.dp,\n                          CARD_CORNER_RADIUS.dp,\n                          CARD_CORNER_RADIUS.dp))\n              .heightIn(max = CARD_HEIGHT_DP.dp)\n              .testTag(\"mapBoxMarker\")\n              .background(Color.Transparent),\n      colors = CardDefaults.cardColors(containerColor = ColorVariable.Secondary),\n      shape =\n          RoundedCornerShape(\n              0.dp, CARD_CORNER_RADIUS.dp, CARD_CORNER_RADIUS.dp, CARD_CORNER_RADIUS.dp)) {\n        Spacer(modifier.height(CARD_CORNER_RADIUS.dp))\n        LazyColumn(modifier = Modifier.fillMaxWidth().testTag(\"mapBoxMarkerList\")) {\n          itemsIndexed(userBooks) { index, book ->\n            Column(\n                modifier =\n                    Modifier.padding(horizontal = PADDING_HORIZONTAL_DP.dp)\n                        .testTag(\"mapBoxMarkerListBox\")) {\n                  Text(\n                      text = book.title,\n                      color = ColorVariable.Accent,\n                      fontSize = PRIMARY_TEXT_FONT_SP.sp,\n                      modifier = Modifier.testTag(\"mapBoxMarkerListBoxTitle\"))\n                  Spacer(modifier = Modifier.height(PADDING_VERTICAL_DP.dp))\n                  Text(\n                      text = book.author ?: \"\",\n                      color = ColorVariable.AccentSecondary,\n                      fontSize = SECONDARY_TEXT_FONT_SP.sp,\n                      modifier = Modifier.testTag(\"mapBoxMarkerListBoxAuthor\"))\n                }\n            if (index < userBooks.size - 1)\n                HorizontalDivider(\n                    modifier =\n                        Modifier.fillMaxWidth()\n                            .height(PADDING_VERTICAL_DP.dp)\n                            .testTag(\"mapBoxMarkerListDivider\"),\n                    thickness = DIVIDER_THICKNESS_DP.dp,\n                    color = ColorVariable.Accent)\n          }\n        }\n        Spacer(modifier.height(PADDING_VERTICAL_DP.dp))\n      }\n}\n\nconst val HEIGHT_RETRACTED_DRAGGABLE_MENU_DP = 50\nconst val MIN_BOX_BOOK_HEIGHT_DP = 90\nconst val IMAGE_HEIGHT_DP = MIN_BOX_BOOK_HEIGHT_DP - PADDING_VERTICAL_DP * 2\n// 1.5:1 ratio + the padding\nconst val IMAGE_WIDTH_DP = MIN_BOX_BOOK_HEIGHT_DP * 2 / 3 + PADDING_HORIZONTAL_DP * 2\nconst val HANDLE_WIDTH_DP = 120\nconst val HANDLE_HEIGHT_DP = 15\nconst val HANDLE_CORNER_RADIUS_DP = 10\nconst val SPACER_HEIGHT_DP = 20\nconst val STAR_HEIGHT_DP = 30\nconst val STAR_SIZE_DP = 26\nconst val STAR_INNER_SIZE_DP = STAR_SIZE_DP / 2\nconst val WIDTH_TITLE_BOX_DP = 150\nconst val MAX_RATING = 5\n\n/**\n * Composable function to display a draggable menu containing all the nearest books available.\n *\n * @param listAllBooks A [List] of all [DataBook] sorted with the nearest book at the first position\n *   and the furthest one at the last position.\n */\n@Composable\nprivate fun DraggableMenu(listAllBooks: List<DataBook>) {\n\n  // State for menu drag offset\n  val configuration = LocalConfiguration.current\n  val maxSheetOffsetY = configuration.screenHeightDp.dp - BOTTOM_NAV_HEIGHT\n  var sheetOffsetY by remember {\n    mutableStateOf((maxSheetOffsetY - HEIGHT_RETRACTED_DRAGGABLE_MENU_DP.dp) / 3 * 2)\n  }\n\n  Box(\n      modifier =\n          Modifier.offset {\n                IntOffset(\n                    0,\n                    sheetOffsetY\n                        .toPx()\n                        .roundToInt()\n                        .coerceIn(\n                            0,\n                            (maxSheetOffsetY - HEIGHT_RETRACTED_DRAGGABLE_MENU_DP.dp)\n                                .toPx()\n                                .toInt()))\n              }\n              .fillMaxWidth()\n              .height(\n                  (maxSheetOffsetY - sheetOffsetY).coerceIn(maxSheetOffsetY / 10, maxSheetOffsetY))\n              .pointerInput(Unit) {\n                detectVerticalDragGestures { change, dragAmount ->\n                  change.consume()\n                  val dragAmountInDp = dragAmount / density\n                  sheetOffsetY = (sheetOffsetY + dragAmountInDp.dp)\n                }\n              }\n              .background(\n                  color = ColorVariable.BackGround,\n                  shape =\n                      RoundedCornerShape(\n                          topStart = HEIGHT_RETRACTED_DRAGGABLE_MENU_DP.dp,\n                          topEnd = HEIGHT_RETRACTED_DRAGGABLE_MENU_DP.dp))\n              .testTag(\"mapDraggableMenu\")) {\n        Column(modifier = Modifier.fillMaxWidth().testTag(\"mapDraggableMenuStructure\")) {\n          // draggable handle\n          Spacer(modifier = Modifier.height(HANDLE_HEIGHT_DP.dp))\n          Box(\n              modifier =\n                  Modifier.align(Alignment.CenterHorizontally)\n                      .width(HANDLE_WIDTH_DP.dp)\n                      .height(HANDLE_HEIGHT_DP.dp)\n                      .background(\n                          color = ColorVariable.AccentSecondary,\n                          shape = RoundedCornerShape(HANDLE_CORNER_RADIUS_DP.dp))\n                      .testTag(\"mapDraggableMenuHandle\"))\n          Spacer(modifier = Modifier.height(SPACER_HEIGHT_DP.dp))\n          HorizontalDivider(\n              modifier = Modifier.fillMaxWidth().testTag(\"mapDraggableMenuHandleDivider\"),\n              thickness = DIVIDER_THICKNESS_DP.dp,\n              color = ColorVariable.Accent)\n          LazyColumn(userScrollEnabled = true, modifier = Modifier.fillMaxHeight()) {\n            if (listAllBooks.isEmpty()) {\n              item {\n                Text(\n                    text = \"No books found\",\n                    color = ColorVariable.Accent,\n                    fontSize = PRIMARY_TEXT_FONT_SP.sp,\n                    textAlign = androidx.compose.ui.text.style.TextAlign.Center,\n                    modifier =\n                        Modifier.padding(PADDING_HORIZONTAL_DP.dp)\n                            .fillMaxWidth()\n                            .align(Alignment.CenterHorizontally)\n                            .testTag(\"mapDraggableMenuNoBook\"))\n              }\n            } else {\n              itemsIndexed(listAllBooks) { index, book ->\n                Spacer(modifier = Modifier.height(PADDING_VERTICAL_DP.dp))\n                Row(\n                    modifier =\n                        Modifier.heightIn(min = MIN_BOX_BOOK_HEIGHT_DP.dp)\n                            .testTag(\"mapDraggableMenuBookBox${index}\")) {\n                      // Image Box\n                      Box(\n                          modifier =\n                              Modifier.height(IMAGE_HEIGHT_DP.dp)\n                                  .width(IMAGE_WIDTH_DP.dp)\n                                  .padding(\n                                      start = PADDING_HORIZONTAL_DP.dp,\n                                      end = PADDING_HORIZONTAL_DP.dp)\n                                  .testTag(\"mapDraggableMenuBookBoxImage\")) {\n                            // Image of the books, will be added at a later date\n                            // We didn't discussed about how we will store the image or how we\n                            // will\n                            // encode them\n                            Box(\n                                modifier =\n                                    Modifier.fillMaxSize()\n                                        .background(Color.Gray) // Placeholder for the image\n                                )\n                          }\n\n                      // Column for text content\n                      Column(\n                          modifier =\n                              Modifier.padding(vertical = PADDING_VERTICAL_DP.dp)\n                                  .width(WIDTH_TITLE_BOX_DP.dp)\n                                  .testTag(\"mapDraggableMenuBookBoxMiddle\")) {\n                            Text(\n                                text = book.title,\n                                color = ColorVariable.Accent,\n                                fontSize = PRIMARY_TEXT_FONT_SP.sp,\n                                modifier =\n                                    Modifier.padding(bottom = PADDING_VERTICAL_DP.dp)\n                                        .width(WIDTH_TITLE_BOX_DP.dp)\n                                        .testTag(\"mapDraggableMenuBookBoxTitle\"))\n                            Text(\n                                text = book.author ?: \"\",\n                                color = ColorVariable.AccentSecondary,\n                                fontSize = SECONDARY_TEXT_FONT_SP.sp,\n                                modifier =\n                                    Modifier.width(WIDTH_TITLE_BOX_DP.dp)\n                                        .testTag(\"mapDraggableMenuBookBoxAuthor\"))\n                          }\n                      Column(\n                          modifier = Modifier.fillMaxWidth().testTag(\"mapDraggableMenuBookRight\")) {\n                            Row(\n                                modifier =\n                                    Modifier.fillMaxWidth()\n                                        .height(STAR_HEIGHT_DP.dp)\n                                        .testTag(\"mapDraggableMenuBookBoxRating\")) {\n                                  // leave all stars empty if no rating\n                                  DisplayStarReview(book.rating ?: 0)\n                                }\n                            // text for the tags of the book, will be added at a later date\n                            // It isn't decided how we will handle the tag for the books\n                            Text(\n                                text = book.genres.joinToString(separator = \", \") { it.Genre },\n                                modifier =\n                                    Modifier.fillMaxWidth().testTag(\"mapDraggableMenuBookBoxTag\"),\n                                fontSize = SECONDARY_TEXT_FONT_SP.sp,\n                                color = ColorVariable.AccentSecondary)\n                          }\n                    }\n\n                // Divider below each item\n                HorizontalDivider(\n                    modifier = Modifier.fillMaxWidth().testTag(\"mapDraggableMenuBookBoxDivider\"),\n                    thickness = DIVIDER_THICKNESS_DP.dp,\n                    color = ColorVariable.Accent)\n              }\n            }\n          }\n        }\n      }\n}\n\n/**\n * Composable function that displays a row of 5 stars, the n first are filled then the rest are\n * empty stars.\n *\n * @param rating A [Int] from 1 to 5, used to know how many filled star should be displayed\n */\n@Composable\nprivate fun DisplayStarReview(rating: Int) {\n  for (i in 1..rating) {\n    Icon(\n        imageVector = Icons.Filled.Star,\n        contentDescription = \"Star Icon\",\n        tint = Color.Black,\n        modifier = Modifier.size(STAR_SIZE_DP.dp).testTag(\"mapDraggableMenuBookBoxStar\"))\n  }\n  for (i in rating + 1..MAX_RATING) {\n    // Hollow star\n    // Icons.Outlined.Star doesn't work, it displays the\n    // Icons.Filled.Star\n    Box(modifier = Modifier.width(STAR_SIZE_DP.dp).testTag(\"mapDraggableMenuBookBoxEmptyStar\")) {\n      Icon(\n          imageVector = Icons.Filled.Star,\n          contentDescription = \"Star Icon\",\n          tint = Color.Black,\n          modifier = Modifier.size(STAR_SIZE_DP.dp))\n      Icon(\n          imageVector = Icons.Filled.Star,\n          contentDescription = \"Star Icon\",\n          tint = ColorVariable.BackGround,\n          modifier = Modifier.size(STAR_INNER_SIZE_DP.dp).align(Alignment.Center))\n    }\n  }\n}\n\n// need to be removed when user dataclass will be created\ndata class TempUser(val latitude: Double, val longitude: Double, val listBook: List<DataBook>)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/map/Map.kt b/app/src/main/java/com/android/bookswap/ui/map/Map.kt
--- a/app/src/main/java/com/android/bookswap/ui/map/Map.kt	
+++ b/app/src/main/java/com/android/bookswap/ui/map/Map.kt	
@@ -45,11 +45,10 @@
 import androidx.compose.ui.unit.sp
 import com.android.bookswap.data.DataBook
 import com.android.bookswap.model.map.BookFilter
+import com.android.bookswap.model.map.BookManagerViewModel
 import com.android.bookswap.model.map.DefaultGeolocation
 import com.android.bookswap.model.map.IGeolocation
 import com.android.bookswap.ui.navigation.BOTTOM_NAV_HEIGHT
-import com.android.bookswap.ui.navigation.BottomNavigationMenu
-import com.android.bookswap.ui.navigation.List_Navigation_Bar_Destinations
 import com.android.bookswap.ui.navigation.NavigationActions
 import com.android.bookswap.ui.navigation.Screen
 import com.android.bookswap.ui.theme.ColorVariable
@@ -62,6 +61,7 @@
 import kotlinx.coroutines.launch
 
 const val INIT_ZOOM = 10F
+const val NO_USER_SELECTED = -1
 
 val CameraPositionKey = SemanticsPropertyKey<CameraPositionState>("CameraPosition")
 var SemanticsPropertyReceiver.cameraPosition by CameraPositionKey
@@ -72,49 +72,46 @@
  * This screen renders a GoogleMap that shows books locations as markers. Upon clicking a marker, it
  * displays a custom info window with the list of books at this location.
  *
- * @param listUser List of users [TempUser] to display on the map, each containing their location
- *   (latitude, longitude) and a list of books they own (listBook). This argument will later be
- *   deleted as the code should in the future use a class to get the user from the database.
- * @param selectedUser An optional user [TempUser] to be initially selected and focused on the map.
- *   This users info window will be shown if not null.
- * @param navigationActions An instance of [NavigationActions] to handle navigation actions.
+ * @param bookManagerViewModel the view model that give the mapScreen the list of books to display
  * @param bookFilter An instance of [BookFilter] to filter the books displayed on the map.
+ * @param selectedUser An optional user, it will display the infoWindow related to this user. This
+ *   users info window will be shown if it is bigger or equal to 0.
  * @param geolocation An instance of [IGeolocation] to get the user's current location.
  */
 @Composable
 fun MapScreen(
-    listUser: List<TempUser>,
-    selectedUser: TempUser? = null,
+    bookManagerViewModel: BookManagerViewModel,
     navigationActions: NavigationActions,
-    bookFilter: BookFilter,
+    selectedUser: Int = NO_USER_SELECTED,
     geolocation: IGeolocation = DefaultGeolocation(),
+    topAppBar: @Composable () -> Unit = {},
+    bottomAppBar: @Composable () -> Unit = {},
 ) {
   val cameraPositionState = rememberCameraPositionState()
   // Get the user's current location
-  val latitude by remember { geolocation.latitude }
-  val longitude by remember { geolocation.longitude }
-  // Start location updates
+  val latitude = geolocation.latitude.collectAsState()
+  val longitude = geolocation.longitude.collectAsState()
+  // Start location and books updates
   LaunchedEffect(Unit) {
+    bookManagerViewModel.startUpdatingBooks()
     geolocation.startLocationUpdates()
     cameraPositionState.position =
-        CameraPosition.fromLatLngZoom(LatLng(latitude, longitude), INIT_ZOOM)
+        CameraPosition.fromLatLngZoom(LatLng(latitude.value, longitude.value), INIT_ZOOM)
   }
-  // Stop location updates when the screen is disposed
-  DisposableEffect(Unit) { onDispose { geolocation.stopLocationUpdates() } }
+  // Stop location and books updates when the screen is disposed
+  DisposableEffect(Unit) {
+    onDispose {
+      geolocation.stopLocationUpdates()
+      bookManagerViewModel.stopUpdatingBooks()
+    }
+  }
 
   var mutableStateSelectedUser by remember { mutableStateOf(selectedUser) }
   var markerScreenPosition by remember { mutableStateOf<Offset?>(null) }
-  val listAllBooks = listUser.flatMap { it.listBook }
 
-  // Filter the books based on the selected filters
-  val genresFilter by bookFilter.genresFilter.collectAsState()
-  val languagesFilter by bookFilter.languagesFilter.collectAsState()
+  val filteredBooks = bookManagerViewModel.filteredBooks.collectAsState()
 
-  val filteredBooks =
-      remember(genresFilter, languagesFilter) { bookFilter.filterBooks(listAllBooks) }
-
-  val filteredUsers =
-      listUser.filter { user -> user.listBook.any { book -> filteredBooks.contains(book) } }
+  val filteredUsers = bookManagerViewModel.filteredUsers.collectAsState()
 
   // compute the position of the marker on the screen given the camera position and the marker's
   // position on the map
@@ -126,79 +123,89 @@
     }
   }
 
-  if (mutableStateSelectedUser != null) {
+  if (mutableStateSelectedUser >= 0 && mutableStateSelectedUser < filteredUsers.value.size) {
     computePositionOfMarker(
         cameraPositionState,
-        LatLng(mutableStateSelectedUser!!.latitude, mutableStateSelectedUser!!.longitude))
+        LatLng(
+            filteredUsers.value[mutableStateSelectedUser].latitude,
+            filteredUsers.value[mutableStateSelectedUser].longitude))
   }
 
   val coroutineScope = rememberCoroutineScope()
 
   // Recalculate marker screen position during camera movement
   LaunchedEffect(cameraPositionState.position) {
-    if (mutableStateSelectedUser != null) {
+    if (mutableStateSelectedUser >= 0 && mutableStateSelectedUser < filteredUsers.value.size) {
       computePositionOfMarker(
           cameraPositionState,
-          LatLng(mutableStateSelectedUser!!.latitude, mutableStateSelectedUser!!.longitude))
+          LatLng(
+              filteredUsers.value[mutableStateSelectedUser].latitude,
+              filteredUsers.value[mutableStateSelectedUser].longitude))
     }
   }
 
   Scaffold(
       modifier = Modifier.testTag("mapScreen"),
-      bottomBar = {
-        BottomNavigationMenu(
-            onTabSelect = { destination -> navigationActions.navigateTo(destination) },
-            tabList = List_Navigation_Bar_Destinations,
-            selectedItem = navigationActions.currentRoute())
-      },
+      topBar = topAppBar,
+      bottomBar = bottomAppBar,
       content = { pd ->
-        GoogleMap(
-            onMapClick = { mutableStateSelectedUser = null },
-            modifier =
-                Modifier.fillMaxSize().padding(pd).testTag("mapGoogleMap").semantics {
-                  cameraPosition = cameraPositionState
-                },
-            cameraPositionState = cameraPositionState,
-            uiSettings = MapUiSettings(zoomControlsEnabled = false),
-        ) {
-          // Marker for user's current location
-          if (!latitude.isNaN() && !longitude.isNaN()) {
-            Marker(
-                state = MarkerState(position = LatLng(latitude, longitude)),
-                title = "Your Location",
-                icon = BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_BLUE))
-          }
-          filteredUsers
-              .filter { !it.longitude.isNaN() && !it.latitude.isNaN() && it.listBook.isNotEmpty() }
-              .forEach { item ->
-                val markerState = MarkerState(position = LatLng(item.latitude, item.longitude))
+        Box(
+            Modifier.padding(
+                top = pd.calculateTopPadding(), bottom = pd.calculateBottomPadding())) {
+              GoogleMap(
+                  onMapClick = { mutableStateSelectedUser = NO_USER_SELECTED },
+                  modifier =
+                      Modifier.fillMaxSize().testTag("mapGoogleMap").semantics {
+                        cameraPosition = cameraPositionState
+                      },
+                  cameraPositionState = cameraPositionState,
+                  uiSettings = MapUiSettings(zoomControlsEnabled = false),
+              ) {
+                // Marker for user's current location
+                if (!latitude.value.isNaN() && !longitude.value.isNaN()) {
+                  Marker(
+                      state = MarkerState(position = LatLng(latitude.value, longitude.value)),
+                      title = "Your Location",
+                      icon =
+                          BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_BLUE))
+                }
+                filteredUsers.value
+                    .filter {
+                      !it.longitude.isNaN() && !it.latitude.isNaN() && it.books.isNotEmpty()
+                    }
+                    .forEachIndexed { index, item ->
+                      val markerState =
+                          MarkerState(position = LatLng(item.latitude, item.longitude))
 
-                Marker(
-                    state = markerState,
-                    onClick = {
-                      mutableStateSelectedUser = item
-                      coroutineScope.launch {
-                        computePositionOfMarker(cameraPositionState, markerState.position)
-                      }
-                      false
-                    })
-              }
-        }
-        FilterButton { navigationActions.navigateTo(Screen.FILTER) }
+                      Marker(
+                          state = markerState,
+                          onClick = {
+                            mutableStateSelectedUser = index
+                            coroutineScope.launch {
+                              computePositionOfMarker(cameraPositionState, markerState.position)
+                            }
+                            false
+                          })
+                    }
+              }
+              FilterButton { navigationActions.navigateTo(Screen.FILTER) }
 
-        // Custom info window linked to the marker
-        markerScreenPosition?.let { screenPos ->
-          mutableStateSelectedUser?.let { user ->
-            CustomInfoWindow(
-                modifier =
-                    Modifier.offset {
-                      IntOffset(screenPos.x.roundToInt(), screenPos.y.roundToInt())
-                    },
-                userBooks = bookFilter.filterBooks(user.listBook))
-          }
-        }
-        // Draggable Bottom List
-        DraggableMenu(filteredBooks)
+              // Custom info window linked to the marker
+              markerScreenPosition?.let { screenPos ->
+                if (mutableStateSelectedUser >= 0 &&
+                    mutableStateSelectedUser < filteredUsers.value.size &&
+                    filteredUsers.value[mutableStateSelectedUser].books.isNotEmpty()) {
+                  CustomInfoWindow(
+                      modifier =
+                          Modifier.offset {
+                            IntOffset(screenPos.x.roundToInt(), screenPos.y.roundToInt())
+                          },
+                      userBooks = filteredUsers.value[mutableStateSelectedUser].books)
+                }
+              }
+              // Draggable Bottom List
+              DraggableMenu(filteredBooks.value)
+            }
       })
 }
 
@@ -305,7 +312,7 @@
 
   // State for menu drag offset
   val configuration = LocalConfiguration.current
-  val maxSheetOffsetY = configuration.screenHeightDp.dp - BOTTOM_NAV_HEIGHT
+  val maxSheetOffsetY = configuration.screenHeightDp.dp - BOTTOM_NAV_HEIGHT * 2
   var sheetOffsetY by remember {
     mutableStateOf((maxSheetOffsetY - HEIGHT_RETRACTED_DRAGGABLE_MENU_DP.dp) / 3 * 2)
   }
@@ -487,6 +494,3 @@
     }
   }
 }
-
-// need to be removed when user dataclass will be created
-data class TempUser(val latitude: Double, val longitude: Double, val listBook: List<DataBook>)
Index: app/src/androidTest/java/com/android/bookswap/ui/chat/ChatScreenTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.chat\r\n\r\nimport android.content.Context\r\nimport androidx.compose.ui.semantics.SemanticsActions\r\nimport androidx.compose.ui.semantics.SemanticsProperties\r\nimport androidx.compose.ui.semantics.getOrNull\r\nimport androidx.compose.ui.test.assertHasClickAction\r\nimport androidx.compose.ui.test.assertIsDisplayed\r\nimport androidx.compose.ui.test.assertTextEquals\r\nimport androidx.compose.ui.test.junit4.createComposeRule\r\nimport androidx.compose.ui.test.onAllNodesWithTag\r\nimport androidx.compose.ui.test.onNodeWithTag\r\nimport androidx.compose.ui.test.performClick\r\nimport androidx.compose.ui.test.performSemanticsAction\r\nimport androidx.compose.ui.test.performTextClearance\r\nimport androidx.compose.ui.test.performTextInput\r\nimport com.android.bookswap.data.DataMessage\r\nimport com.android.bookswap.data.repository.MessageRepository\r\nimport com.android.bookswap.ui.navigation.NavigationActions\r\nimport com.android.bookswap.ui.theme.ColorVariable\r\nimport com.google.firebase.firestore.ListenerRegistration\r\nimport io.mockk.mockk\r\nimport java.text.SimpleDateFormat\r\nimport java.util.Date\r\nimport java.util.Locale\r\nimport org.junit.Before\r\nimport org.junit.Rule\r\nimport org.junit.Test\r\n\r\nclass ChatScreenTest {\r\n\r\n  @get:Rule val composeTestRule = createComposeRule()\r\n  private lateinit var placeHolderData: List<DataMessage>\r\n  private lateinit var mockMessageRepository: MessageRepository\r\n  private val currentUserId = \"current-user-id\"\r\n  private val otherUserId = \"other-user-id\"\r\n  private lateinit var mockNavigationActions: NavigationActions\r\n\r\n  @Before\r\n  fun setUp() {\r\n    mockNavigationActions = mockk()\r\n    placeHolderData =\r\n        List(6) {\r\n          DataMessage(\r\n              id = it.toString(),\r\n              senderId = \"current-user-id\",\r\n              receiverId = \"other-user-id\",\r\n              text = \"Test message $it\",\r\n              timestamp = it.toLong())\r\n        }\r\n    mockMessageRepository =\r\n        MockMessageFirestoreSource().apply { messages = placeHolderData.toMutableList() }\r\n  }\r\n\r\n  private val palette =\r\n      listOf(\r\n          ColorVariable.Primary,\r\n          ColorVariable.Secondary,\r\n          ColorVariable.Accent,\r\n          ColorVariable.AccentSecondary,\r\n          ColorVariable.BackGround)\r\n\r\n  @Test\r\n  fun testFormatTimeStamps() {\r\n    val timestamp = System.currentTimeMillis()\r\n    val formattedTimestamp = formatTimestamp(timestamp)\r\n    val expectedTimestamp = SimpleDateFormat(\"HH:mm\", Locale.getDefault()).format(Date(timestamp))\r\n    assert(formattedTimestamp == expectedTimestamp)\r\n  }\r\n\r\n  @Test\r\n  fun hasRequiredComponentsWithoutMessage() {\r\n    composeTestRule.setContent {\r\n      ChatScreen(\r\n          messageRepository = mockMessageRepository,\r\n          currentUserId = currentUserId,\r\n          otherUserId = otherUserId,\r\n          mockNavigationActions)\r\n    }\r\n    composeTestRule.onNodeWithTag(\"message_input_field\").assertIsDisplayed()\r\n    composeTestRule.onNodeWithTag(\"send_button\").assertIsDisplayed()\r\n  }\r\n\r\n  @Test\r\n  fun hasRequiredComponentsAndShowsMessages() {\r\n    val mockMessageRepository =\r\n        MockMessageFirestoreSource().apply { messages = placeHolderData.toMutableList() }\r\n\r\n    composeTestRule.setContent {\r\n      ChatScreen(\r\n          messageRepository = mockMessageRepository,\r\n          currentUserId = currentUserId,\r\n          otherUserId = otherUserId,\r\n          mockNavigationActions)\r\n    }\r\n    composeTestRule.onNodeWithTag(\"message_input_field\").assertIsDisplayed()\r\n    composeTestRule.onNodeWithTag(\"send_button\").assertIsDisplayed()\r\n    placeHolderData.forEach { message ->\r\n      composeTestRule.waitUntil {\r\n        composeTestRule\r\n            .onAllNodesWithTag(\"message_item ${message.id}\", useUnmergedTree = true)\r\n            .fetchSemanticsNodes()\r\n            .isNotEmpty()\r\n      }\r\n      composeTestRule\r\n          .onNodeWithTag(\"message_item ${message.id}\", useUnmergedTree = true)\r\n          .assertIsDisplayed()\r\n      composeTestRule\r\n          .onNodeWithTag(\"message_text ${message.id}\", useUnmergedTree = true)\r\n          .assertIsDisplayed()\r\n      composeTestRule\r\n          .onNodeWithTag(\"message_text ${message.id}\", useUnmergedTree = true)\r\n          .assertTextEquals(message.text)\r\n      composeTestRule\r\n          .onNodeWithTag(\"message_timestamp ${message.id}\", useUnmergedTree = true)\r\n          .assertIsDisplayed()\r\n      composeTestRule\r\n          .onNodeWithTag(\"message_timestamp ${message.id}\", useUnmergedTree = true)\r\n          .assertTextEquals(formatTimestamp(message.timestamp))\r\n    }\r\n  }\r\n\r\n  @Test\r\n  fun hasClickableButton() {\r\n    composeTestRule.setContent {\r\n      ChatScreen(\r\n          messageRepository = mockMessageRepository,\r\n          currentUserId = currentUserId,\r\n          otherUserId = otherUserId,\r\n          mockNavigationActions)\r\n    }\r\n    composeTestRule.onNodeWithTag(\"send_button\").assertHasClickAction()\r\n  }\r\n\r\n  @Test\r\n  fun hasCompletableTextField() {\r\n    composeTestRule.setContent {\r\n      ChatScreen(\r\n          messageRepository = mockMessageRepository,\r\n          currentUserId = currentUserId,\r\n          otherUserId = otherUserId,\r\n          mockNavigationActions)\r\n    }\r\n    val testInput = \"Hello, World!\"\r\n    composeTestRule.onNodeWithTag(\"message_input_field\").performTextInput(testInput)\r\n    composeTestRule.onNodeWithTag(\"message_input_field\").assertTextEquals(testInput)\r\n  }\r\n\r\n  @Test\r\n  fun testSendMessage() {\r\n    val testMessageId = \"test-message-id\"\r\n    val mockMessageRepository = MockMessageFirestoreSource().apply { mockNewUid = testMessageId }\r\n\r\n    composeTestRule.setContent {\r\n      ChatScreen(\r\n          messageRepository = mockMessageRepository,\r\n          currentUserId = currentUserId,\r\n          otherUserId = otherUserId,\r\n          mockNavigationActions)\r\n    }\r\n\r\n    val testInput = \"Hello, World!\"\r\n\r\n    composeTestRule.onNodeWithTag(\"message_input_field\").performTextInput(testInput)\r\n    composeTestRule.onNodeWithTag(\"send_button\").performClick()\r\n\r\n    // Verify that the message was sent\r\n    val sentMessage = mockMessageRepository.messages.find { it.id == testMessageId }\r\n    assert(sentMessage != null) { \"Message was not sent\" }\r\n    assert(sentMessage?.text == testInput) { \"Message text does not match\" }\r\n    assert(sentMessage?.senderId == currentUserId) { \"Sender ID does not match\" }\r\n    assert(sentMessage?.receiverId == otherUserId) { \"Receiver ID does not match\" }\r\n  }\r\n\r\n  @Test\r\n  fun testTopAppBar() {\r\n    composeTestRule.setContent {\r\n      ChatScreen(\r\n          messageRepository = mockMessageRepository,\r\n          currentUserId = currentUserId,\r\n          otherUserId = otherUserId,\r\n          mockNavigationActions)\r\n    }\r\n\r\n    composeTestRule.onNodeWithTag(\"chatTopAppBar\").assertIsDisplayed()\r\n    composeTestRule.onNodeWithTag(\"chatName\").assertIsDisplayed()\r\n    composeTestRule.onNodeWithTag(\"chatName\").assertTextEquals(otherUserId)\r\n    composeTestRule.onNodeWithTag(\"profileIcon\", useUnmergedTree = true).assertIsDisplayed()\r\n  }\r\n\r\n  @Test\r\n  fun testPopUpExists() {\r\n    composeTestRule.setContent {\r\n      ChatScreen(\r\n          messageRepository = mockMessageRepository,\r\n          currentUserId = currentUserId,\r\n          otherUserId = otherUserId,\r\n          navController = mockNavigationActions)\r\n    }\r\n\r\n    composeTestRule.waitForIdle()\r\n\r\n    val messageNode =\r\n        composeTestRule.onNodeWithTag(\r\n            \"message_item ${placeHolderData.first().id}\", useUnmergedTree = true)\r\n    messageNode.assertExists(\"Message item not found\")\r\n\r\n    messageNode.performSemanticsAction(SemanticsActions.OnLongClick)\r\n\r\n    composeTestRule.waitUntil(timeoutMillis = 5000) {\r\n      composeTestRule\r\n          .onAllNodesWithTag(\"editButton\", useUnmergedTree = true)\r\n          .fetchSemanticsNodes()\r\n          .isNotEmpty() &&\r\n          composeTestRule\r\n              .onAllNodesWithTag(\"deleteButton\", useUnmergedTree = true)\r\n              .fetchSemanticsNodes()\r\n              .isNotEmpty()\r\n    }\r\n\r\n    composeTestRule.onNodeWithTag(\"editButton\", useUnmergedTree = true).assertIsDisplayed()\r\n    composeTestRule.onNodeWithTag(\"deleteButton\", useUnmergedTree = true).assertIsDisplayed()\r\n\r\n    composeTestRule.onNodeWithTag(\"editButton\", useUnmergedTree = true).assertHasClickAction()\r\n    composeTestRule.onNodeWithTag(\"deleteButton\", useUnmergedTree = true).assertHasClickAction()\r\n  }\r\n\r\n  @Test\r\n  fun testDelete() {\r\n    val mockMessageRepository =\r\n        MockMessageFirestoreSource().apply { messages = placeHolderData.toMutableList() }\r\n\r\n    composeTestRule.setContent {\r\n      ChatScreen(\r\n          messageRepository = mockMessageRepository,\r\n          currentUserId = currentUserId,\r\n          otherUserId = otherUserId,\r\n          mockNavigationActions)\r\n    }\r\n\r\n    val message = placeHolderData.first()\r\n    val messageNode =\r\n        composeTestRule.onNodeWithTag(\"message_item ${message.id}\", useUnmergedTree = true)\r\n    messageNode.assertExists(\"Message item not found\")\r\n\r\n    messageNode.performSemanticsAction(SemanticsActions.OnLongClick)\r\n\r\n    composeTestRule.waitUntil(timeoutMillis = 5000) {\r\n      composeTestRule\r\n          .onAllNodesWithTag(\"deleteButton\", useUnmergedTree = true)\r\n          .fetchSemanticsNodes()\r\n          .isNotEmpty()\r\n    }\r\n\r\n    composeTestRule.onNodeWithTag(\"deleteButton\", useUnmergedTree = true).performClick()\r\n\r\n    val deletedMessage = mockMessageRepository.messages.find { it.id == message.id }\r\n    assert(deletedMessage == null) { \"Message was not deleted\" }\r\n\r\n    composeTestRule.waitUntil(timeoutMillis = 5000) {\r\n      composeTestRule\r\n          .onAllNodesWithTag(\"message_item ${message.id}\", useUnmergedTree = true)\r\n          .fetchSemanticsNodes()\r\n          .isEmpty()\r\n    }\r\n\r\n    composeTestRule\r\n        .onNodeWithTag(\"message_item ${message.id}\", useUnmergedTree = true)\r\n        .assertDoesNotExist()\r\n  }\r\n\r\n  @Test\r\n  fun testEdit() {\r\n    val mockMessageRepository =\r\n        MockMessageFirestoreSource().apply { messages = placeHolderData.toMutableList() }\r\n\r\n    composeTestRule.setContent {\r\n      ChatScreen(\r\n          messageRepository = mockMessageRepository,\r\n          currentUserId = currentUserId,\r\n          otherUserId = otherUserId,\r\n          navController = mockNavigationActions)\r\n    }\r\n\r\n    val message = placeHolderData.first()\r\n    val newText = \"Updated message text\"\r\n\r\n    val messageNode =\r\n        composeTestRule.onNodeWithTag(\"message_item ${message.id}\", useUnmergedTree = true)\r\n    messageNode.assertExists(\"Message item not found\")\r\n\r\n    messageNode.performSemanticsAction(SemanticsActions.OnLongClick)\r\n\r\n    composeTestRule.waitUntil(timeoutMillis = 5000) {\r\n      composeTestRule\r\n          .onAllNodesWithTag(\"editButton\", useUnmergedTree = true)\r\n          .fetchSemanticsNodes()\r\n          .isNotEmpty()\r\n    }\r\n\r\n    composeTestRule.onNodeWithTag(\"editButton\", useUnmergedTree = true).performClick()\r\n\r\n    composeTestRule\r\n        .onNodeWithTag(\"message_input_field\", useUnmergedTree = true)\r\n        .assertTextEquals(message.text)\r\n\r\n    composeTestRule\r\n        .onNodeWithTag(\"message_input_field\", useUnmergedTree = true)\r\n        .performTextClearance()\r\n    composeTestRule\r\n        .onNodeWithTag(\"message_input_field\", useUnmergedTree = true)\r\n        .performTextInput(newText)\r\n    composeTestRule.onNodeWithTag(\"send_button\", useUnmergedTree = true).performClick()\r\n\r\n    composeTestRule.waitUntil(timeoutMillis = 5000) {\r\n      mockMessageRepository.messages.find { it.id == message.id }?.text == newText\r\n    }\r\n\r\n    val updatedMessage = mockMessageRepository.messages.find { it.id == message.id }\r\n    assert(updatedMessage != null && updatedMessage.text == newText) {\r\n      \"Message was not updated correctly\"\r\n    }\r\n\r\n    composeTestRule.waitUntil(timeoutMillis = 5000) {\r\n      composeTestRule\r\n          .onNodeWithTag(\"message_text ${message.id}\", useUnmergedTree = true)\r\n          .fetchSemanticsNode()\r\n          .config\r\n          .getOrNull(SemanticsProperties.Text)\r\n          ?.joinToString() == newText\r\n    }\r\n\r\n    composeTestRule\r\n        .onNodeWithTag(\"message_text ${message.id}\", useUnmergedTree = true)\r\n        .assertTextEquals(newText)\r\n\r\n    composeTestRule\r\n        .onNodeWithTag(\"message_input_field\", useUnmergedTree = true)\r\n        .assertTextEquals(\"\")\r\n  }\r\n\r\n  @Test\r\n  fun testAllColorsBelongToPalette() {\r\n    composeTestRule.setContent {\r\n      ChatScreen(\r\n          messageRepository = mockMessageRepository,\r\n          currentUserId = currentUserId,\r\n          otherUserId = otherUserId,\r\n          mockNavigationActions)\r\n    }\r\n\r\n    val uiColors =\r\n        listOf(\r\n            ColorVariable.Primary,\r\n            ColorVariable.Secondary,\r\n            ColorVariable.Accent,\r\n            ColorVariable.AccentSecondary,\r\n            ColorVariable.BackGround)\r\n\r\n    uiColors.forEach { color ->\r\n      assert(palette.contains(color)) { \"Color $color does not belong to the palette\" }\r\n    }\r\n  }\r\n\r\n  class MockMessageFirestoreSource : MessageRepository {\r\n    var mockNewUid: String = \"mock-uid\"\r\n    var messages: MutableList<DataMessage> = mutableListOf()\r\n    private var sendMessageResult: Result<Unit> = Result.success(Unit)\r\n\r\n    override fun init(callback: (Result<Unit>) -> Unit) {\r\n      callback(Result.success(Unit))\r\n    }\r\n\r\n    override fun getNewUid(): String {\r\n      return mockNewUid\r\n    }\r\n\r\n    override fun getMessages(callback: (Result<List<DataMessage>>) -> Unit) {\r\n      callback(Result.success(messages))\r\n    }\r\n\r\n    override fun sendMessage(message: DataMessage, callback: (Result<Unit>) -> Unit) {\r\n      messages.add(message)\r\n      callback(sendMessageResult)\r\n    }\r\n\r\n    override fun deleteMessage(\r\n        messageId: String,\r\n        callback: (Result<Unit>) -> Unit,\r\n        context: Context\r\n    ) {\r\n      messages.removeIf { it.id == messageId }\r\n      callback(Result.success(Unit))\r\n    }\r\n\r\n    override fun deleteAllMessages(\r\n        user1Id: String,\r\n        user2Id: String,\r\n        callback: (Result<Unit>) -> Unit\r\n    ) {\r\n      messages.removeIf { it.senderId == user1Id && it.receiverId == user2Id }\r\n      messages.removeIf { it.senderId == user2Id && it.receiverId == user1Id }\r\n      callback(Result.success(Unit))\r\n    }\r\n\r\n    override fun updateMessage(\r\n        message: DataMessage,\r\n        callback: (Result<Unit>) -> Unit,\r\n        context: Context\r\n    ) {\r\n      val index = messages.indexOfFirst { it.id == message.id }\r\n      if (index != -1) {\r\n        messages[index] = message.copy(text = message.text) // Update the message text\r\n        callback(Result.success(Unit)) // Simulate success\r\n      } else {\r\n        callback(Result.failure(Exception(\"Message not found\")))\r\n      }\r\n    }\r\n\r\n    override fun addMessagesListener(\r\n        otherUserId: String,\r\n        currentUserId: String,\r\n        callback: (Result<List<DataMessage>>) -> Unit\r\n    ): ListenerRegistration {\r\n      requireNotNull(otherUserId) { \"otherUserId must not be null\" }\r\n      requireNotNull(currentUserId) { \"currentUserId must not be null\" }\r\n\r\n      callback(Result.success(messages)) // Or whatever logic you'd like to simulate\r\n      return mockk()\r\n    }\r\n  }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/chat/ChatScreenTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/chat/ChatScreenTest.kt
--- a/app/src/androidTest/java/com/android/bookswap/ui/chat/ChatScreenTest.kt	
+++ b/app/src/androidTest/java/com/android/bookswap/ui/chat/ChatScreenTest.kt	
@@ -11,10 +11,13 @@
 import androidx.compose.ui.test.onAllNodesWithTag
 import androidx.compose.ui.test.onNodeWithTag
 import androidx.compose.ui.test.performClick
+import androidx.compose.ui.test.performScrollToIndex
 import androidx.compose.ui.test.performSemanticsAction
 import androidx.compose.ui.test.performTextClearance
 import androidx.compose.ui.test.performTextInput
 import com.android.bookswap.data.DataMessage
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.MessageType
 import com.android.bookswap.data.repository.MessageRepository
 import com.android.bookswap.ui.navigation.NavigationActions
 import com.android.bookswap.ui.theme.ColorVariable
@@ -23,33 +26,51 @@
 import java.text.SimpleDateFormat
 import java.util.Date
 import java.util.Locale
+import java.util.UUID
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 
 class ChatScreenTest {
-
   @get:Rule val composeTestRule = createComposeRule()
   private lateinit var placeHolderData: List<DataMessage>
   private lateinit var mockMessageRepository: MessageRepository
-  private val currentUserId = "current-user-id"
-  private val otherUserId = "other-user-id"
+  private val currentUserUUID = UUID.randomUUID()
+  private val otherUserUUID = UUID.randomUUID()
   private lateinit var mockNavigationActions: NavigationActions
+  private val currentUser =
+      DataUser(
+          currentUserUUID, "Hello", "Jaime", "Oliver Pastor", "", "", 0.0, 0.0, "", emptyList(), "")
+  private val otherUser =
+      DataUser(otherUserUUID, "Hey", "Matias", "Salvade", "", "", 0.0, 0.0, "", emptyList(), "")
 
   @Before
   fun setUp() {
     mockNavigationActions = mockk()
+
     placeHolderData =
         List(6) {
-          DataMessage(
-              id = it.toString(),
-              senderId = "current-user-id",
-              receiverId = "other-user-id",
-              text = "Test message $it",
-              timestamp = it.toLong())
-        }
+              DataMessage(
+                  messageType = MessageType.TEXT,
+                  uuid = UUID.randomUUID(),
+                  senderUUID = currentUserUUID,
+                  receiverUUID = otherUserUUID,
+                  text = "Test message $it",
+                  timestamp = it.toLong())
+            }
+            .toMutableList()
+    (placeHolderData as MutableList<DataMessage>).add(
+        DataMessage(
+            messageType = MessageType.IMAGE,
+            uuid = imageTestMessageUUID,
+            senderUUID = currentUserUUID,
+            receiverUUID = otherUserUUID,
+            text = "Test message 101",
+            timestamp = 101L))
     mockMessageRepository =
-        MockMessageFirestoreSource().apply { messages = placeHolderData.toMutableList() }
+        MockMessageFirestoreSource().apply {
+          messages = placeHolderData as MutableList<DataMessage>
+        }
   }
 
   private val palette =
@@ -73,8 +94,8 @@
     composeTestRule.setContent {
       ChatScreen(
           messageRepository = mockMessageRepository,
-          currentUserId = currentUserId,
-          otherUserId = otherUserId,
+          currentUser = currentUser,
+          otherUser = otherUser,
           mockNavigationActions)
     }
     composeTestRule.onNodeWithTag("message_input_field").assertIsDisplayed()
@@ -89,44 +110,68 @@
     composeTestRule.setContent {
       ChatScreen(
           messageRepository = mockMessageRepository,
-          currentUserId = currentUserId,
-          otherUserId = otherUserId,
+          currentUser = currentUser,
+          otherUser = otherUser,
           mockNavigationActions)
     }
     composeTestRule.onNodeWithTag("message_input_field").assertIsDisplayed()
     composeTestRule.onNodeWithTag("send_button").assertIsDisplayed()
     placeHolderData.forEach { message ->
-      composeTestRule.waitUntil {
-        composeTestRule
-            .onAllNodesWithTag("message_item ${message.id}", useUnmergedTree = true)
-            .fetchSemanticsNodes()
-            .isNotEmpty()
-      }
-      composeTestRule
-          .onNodeWithTag("message_item ${message.id}", useUnmergedTree = true)
-          .assertIsDisplayed()
-      composeTestRule
-          .onNodeWithTag("message_text ${message.id}", useUnmergedTree = true)
-          .assertIsDisplayed()
-      composeTestRule
-          .onNodeWithTag("message_text ${message.id}", useUnmergedTree = true)
-          .assertTextEquals(message.text)
-      composeTestRule
-          .onNodeWithTag("message_timestamp ${message.id}", useUnmergedTree = true)
-          .assertIsDisplayed()
-      composeTestRule
-          .onNodeWithTag("message_timestamp ${message.id}", useUnmergedTree = true)
-          .assertTextEquals(formatTimestamp(message.timestamp))
+      if (message.uuid != imageTestMessageUUID) {
+        composeTestRule.waitUntil {
+          composeTestRule
+              .onAllNodesWithTag("message_item ${message.uuid}", useUnmergedTree = true)
+              .fetchSemanticsNodes()
+              .isNotEmpty()
+        }
+        composeTestRule
+            .onNodeWithTag("message_item ${message.uuid}", useUnmergedTree = true)
+            .assertIsDisplayed()
+        composeTestRule
+            .onNodeWithTag("message_text ${message.uuid}", useUnmergedTree = true)
+            .assertIsDisplayed()
+        composeTestRule
+            .onNodeWithTag("message_text ${message.uuid}", useUnmergedTree = true)
+            .assertTextEquals(message.text)
+        composeTestRule
+            .onNodeWithTag("message_timestamp ${message.uuid}", useUnmergedTree = true)
+            .assertIsDisplayed()
+        composeTestRule
+            .onNodeWithTag("message_timestamp ${message.uuid}", useUnmergedTree = true)
+            .assertTextEquals(formatTimestamp(message.timestamp))
+      }
     }
   }
+
+  @Test
+  fun checkLastMessageIsImage() {
+    val mockMessageRepository =
+        MockMessageFirestoreSource().apply { messages = placeHolderData.toMutableList() }
+
+    composeTestRule.setContent {
+      ChatScreen(
+          messageRepository = mockMessageRepository,
+          currentUser = currentUser,
+          otherUser = otherUser,
+          mockNavigationActions)
+    }
+
+    composeTestRule
+        .onNodeWithTag("column", useUnmergedTree = true)
+        .performScrollToIndex(mockMessageRepository.messages.size - 1)
+
+    composeTestRule
+        .onNodeWithTag("hobbit", useUnmergedTree = true)
+        .assertExists("The last message should be an image with the test tag 'hobbit'")
+  }
 
   @Test
   fun hasClickableButton() {
     composeTestRule.setContent {
       ChatScreen(
           messageRepository = mockMessageRepository,
-          currentUserId = currentUserId,
-          otherUserId = otherUserId,
+          currentUser = currentUser,
+          otherUser = otherUser,
           mockNavigationActions)
     }
     composeTestRule.onNodeWithTag("send_button").assertHasClickAction()
@@ -137,8 +182,8 @@
     composeTestRule.setContent {
       ChatScreen(
           messageRepository = mockMessageRepository,
-          currentUserId = currentUserId,
-          otherUserId = otherUserId,
+          currentUser = currentUser,
+          otherUser = otherUser,
           mockNavigationActions)
     }
     val testInput = "Hello, World!"
@@ -148,14 +193,14 @@
 
   @Test
   fun testSendMessage() {
-    val testMessageId = "test-message-id"
-    val mockMessageRepository = MockMessageFirestoreSource().apply { mockNewUid = testMessageId }
+    val testMessageId = UUID.randomUUID()
+    val mockMessageRepository = MockMessageFirestoreSource().apply { mockNewUUID = testMessageId }
 
     composeTestRule.setContent {
       ChatScreen(
           messageRepository = mockMessageRepository,
-          currentUserId = currentUserId,
-          otherUserId = otherUserId,
+          currentUser = currentUser,
+          otherUser = otherUser,
           mockNavigationActions)
     }
 
@@ -165,11 +210,11 @@
     composeTestRule.onNodeWithTag("send_button").performClick()
 
     // Verify that the message was sent
-    val sentMessage = mockMessageRepository.messages.find { it.id == testMessageId }
+    val sentMessage = mockMessageRepository.messages.find { it.uuid == testMessageId }
     assert(sentMessage != null) { "Message was not sent" }
     assert(sentMessage?.text == testInput) { "Message text does not match" }
-    assert(sentMessage?.senderId == currentUserId) { "Sender ID does not match" }
-    assert(sentMessage?.receiverId == otherUserId) { "Receiver ID does not match" }
+    assert(sentMessage?.senderUUID == currentUserUUID) { "Sender UUID does not match" }
+    assert(sentMessage?.receiverUUID == otherUserUUID) { "Receiver UUID does not match" }
   }
 
   @Test
@@ -177,14 +222,16 @@
     composeTestRule.setContent {
       ChatScreen(
           messageRepository = mockMessageRepository,
-          currentUserId = currentUserId,
-          otherUserId = otherUserId,
+          currentUser = currentUser,
+          otherUser = otherUser,
           mockNavigationActions)
     }
 
     composeTestRule.onNodeWithTag("chatTopAppBar").assertIsDisplayed()
     composeTestRule.onNodeWithTag("chatName").assertIsDisplayed()
-    composeTestRule.onNodeWithTag("chatName").assertTextEquals(otherUserId)
+    composeTestRule
+        .onNodeWithTag("chatName")
+        .assertTextEquals(otherUser.firstName + " " + otherUser.lastName)
     composeTestRule.onNodeWithTag("profileIcon", useUnmergedTree = true).assertIsDisplayed()
   }
 
@@ -193,8 +240,8 @@
     composeTestRule.setContent {
       ChatScreen(
           messageRepository = mockMessageRepository,
-          currentUserId = currentUserId,
-          otherUserId = otherUserId,
+          currentUser = currentUser,
+          otherUser = otherUser,
           navController = mockNavigationActions)
     }
 
@@ -202,7 +249,7 @@
 
     val messageNode =
         composeTestRule.onNodeWithTag(
-            "message_item ${placeHolderData.first().id}", useUnmergedTree = true)
+            "message_item ${placeHolderData.first().uuid}", useUnmergedTree = true)
     messageNode.assertExists("Message item not found")
 
     messageNode.performSemanticsAction(SemanticsActions.OnLongClick)
@@ -233,14 +280,14 @@
     composeTestRule.setContent {
       ChatScreen(
           messageRepository = mockMessageRepository,
-          currentUserId = currentUserId,
-          otherUserId = otherUserId,
+          currentUser = currentUser,
+          otherUser = otherUser,
           mockNavigationActions)
     }
 
     val message = placeHolderData.first()
     val messageNode =
-        composeTestRule.onNodeWithTag("message_item ${message.id}", useUnmergedTree = true)
+        composeTestRule.onNodeWithTag("message_item ${message.uuid}", useUnmergedTree = true)
     messageNode.assertExists("Message item not found")
 
     messageNode.performSemanticsAction(SemanticsActions.OnLongClick)
@@ -254,18 +301,18 @@
 
     composeTestRule.onNodeWithTag("deleteButton", useUnmergedTree = true).performClick()
 
-    val deletedMessage = mockMessageRepository.messages.find { it.id == message.id }
+    val deletedMessage = mockMessageRepository.messages.find { it.uuid == message.uuid }
     assert(deletedMessage == null) { "Message was not deleted" }
 
     composeTestRule.waitUntil(timeoutMillis = 5000) {
       composeTestRule
-          .onAllNodesWithTag("message_item ${message.id}", useUnmergedTree = true)
+          .onAllNodesWithTag("message_item ${message.uuid}", useUnmergedTree = true)
           .fetchSemanticsNodes()
           .isEmpty()
     }
 
     composeTestRule
-        .onNodeWithTag("message_item ${message.id}", useUnmergedTree = true)
+        .onNodeWithTag("message_item ${message.uuid}", useUnmergedTree = true)
         .assertDoesNotExist()
   }
 
@@ -277,8 +324,8 @@
     composeTestRule.setContent {
       ChatScreen(
           messageRepository = mockMessageRepository,
-          currentUserId = currentUserId,
-          otherUserId = otherUserId,
+          currentUser = currentUser,
+          otherUser = otherUser,
           navController = mockNavigationActions)
     }
 
@@ -286,7 +333,7 @@
     val newText = "Updated message text"
 
     val messageNode =
-        composeTestRule.onNodeWithTag("message_item ${message.id}", useUnmergedTree = true)
+        composeTestRule.onNodeWithTag("message_item ${message.uuid}", useUnmergedTree = true)
     messageNode.assertExists("Message item not found")
 
     messageNode.performSemanticsAction(SemanticsActions.OnLongClick)
@@ -313,17 +360,17 @@
     composeTestRule.onNodeWithTag("send_button", useUnmergedTree = true).performClick()
 
     composeTestRule.waitUntil(timeoutMillis = 5000) {
-      mockMessageRepository.messages.find { it.id == message.id }?.text == newText
+      mockMessageRepository.messages.find { it.uuid == message.uuid }?.text == newText
     }
 
-    val updatedMessage = mockMessageRepository.messages.find { it.id == message.id }
+    val updatedMessage = mockMessageRepository.messages.find { it.uuid == message.uuid }
     assert(updatedMessage != null && updatedMessage.text == newText) {
       "Message was not updated correctly"
     }
 
     composeTestRule.waitUntil(timeoutMillis = 5000) {
       composeTestRule
-          .onNodeWithTag("message_text ${message.id}", useUnmergedTree = true)
+          .onNodeWithTag("message_text ${message.uuid}", useUnmergedTree = true)
           .fetchSemanticsNode()
           .config
           .getOrNull(SemanticsProperties.Text)
@@ -331,7 +378,7 @@
     }
 
     composeTestRule
-        .onNodeWithTag("message_text ${message.id}", useUnmergedTree = true)
+        .onNodeWithTag("message_text ${message.uuid}", useUnmergedTree = true)
         .assertTextEquals(newText)
 
     composeTestRule
@@ -339,13 +386,53 @@
         .assertTextEquals("")
   }
 
+  @Test
+  fun scrollToBottomClickImageAndCheckPopup() {
+    val mockMessageRepository =
+        MockMessageFirestoreSource().apply { messages = placeHolderData.toMutableList() }
+
+    composeTestRule.setContent {
+      ChatScreen(
+          messageRepository = mockMessageRepository,
+          currentUser = currentUser,
+          otherUser = otherUser,
+          mockNavigationActions)
+    }
+
+    composeTestRule
+        .onNodeWithTag("column", useUnmergedTree = true)
+        .performScrollToIndex(mockMessageRepository.messages.size - 1)
+
+    composeTestRule
+        .onNodeWithTag("message_item_column $imageTestMessageUUID", useUnmergedTree = true)
+        .performClick()
+
+    composeTestRule.waitUntil(timeoutMillis = 5000) {
+      composeTestRule
+          .onAllNodesWithTag("popupImage", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isNotEmpty()
+    }
+    composeTestRule.onNodeWithTag("popupImage", useUnmergedTree = true).assertIsDisplayed()
+
+    composeTestRule.onNodeWithTag("popupImage", useUnmergedTree = true).performClick()
+
+    composeTestRule.waitUntil(timeoutMillis = 5000) {
+      composeTestRule
+          .onAllNodesWithTag("popupImage", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isEmpty()
+    }
+    composeTestRule.onNodeWithTag("popupImage", useUnmergedTree = true).assertDoesNotExist()
+  }
+
   @Test
   fun testAllColorsBelongToPalette() {
     composeTestRule.setContent {
       ChatScreen(
           messageRepository = mockMessageRepository,
-          currentUserId = currentUserId,
-          otherUserId = otherUserId,
+          currentUser = currentUser,
+          otherUser = otherUser,
           mockNavigationActions)
     }
 
@@ -363,7 +450,7 @@
   }
 
   class MockMessageFirestoreSource : MessageRepository {
-    var mockNewUid: String = "mock-uid"
+    var mockNewUUID: UUID = UUID.randomUUID()
     var messages: MutableList<DataMessage> = mutableListOf()
     private var sendMessageResult: Result<Unit> = Result.success(Unit)
 
@@ -371,8 +458,8 @@
       callback(Result.success(Unit))
     }
 
-    override fun getNewUid(): String {
-      return mockNewUid
+    override fun getNewUUID(): UUID {
+      return mockNewUUID
     }
 
     override fun getMessages(callback: (Result<List<DataMessage>>) -> Unit) {
@@ -385,21 +472,21 @@
     }
 
     override fun deleteMessage(
-        messageId: String,
+        messageUUID: UUID,
         callback: (Result<Unit>) -> Unit,
         context: Context
     ) {
-      messages.removeIf { it.id == messageId }
+      messages.removeIf { it.uuid == messageUUID }
       callback(Result.success(Unit))
     }
 
     override fun deleteAllMessages(
-        user1Id: String,
-        user2Id: String,
+        user1UUID: UUID,
+        user2UUID: UUID,
         callback: (Result<Unit>) -> Unit
     ) {
-      messages.removeIf { it.senderId == user1Id && it.receiverId == user2Id }
-      messages.removeIf { it.senderId == user2Id && it.receiverId == user1Id }
+      messages.removeIf { it.senderUUID == user1UUID && it.receiverUUID == user2UUID }
+      messages.removeIf { it.senderUUID == user2UUID && it.receiverUUID == user1UUID }
       callback(Result.success(Unit))
     }
 
@@ -408,7 +495,7 @@
         callback: (Result<Unit>) -> Unit,
         context: Context
     ) {
-      val index = messages.indexOfFirst { it.id == message.id }
+      val index = messages.indexOfFirst { it.uuid == message.uuid }
       if (index != -1) {
         messages[index] = message.copy(text = message.text) // Update the message text
         callback(Result.success(Unit)) // Simulate success
@@ -418,12 +505,12 @@
     }
 
     override fun addMessagesListener(
-        otherUserId: String,
-        currentUserId: String,
+        otherUserUUID: UUID,
+        currentUserUUID: UUID,
         callback: (Result<List<DataMessage>>) -> Unit
     ): ListenerRegistration {
-      requireNotNull(otherUserId) { "otherUserId must not be null" }
-      requireNotNull(currentUserId) { "currentUserId must not be null" }
+      requireNotNull(otherUserUUID) { "otherUserId must not be null" }
+      requireNotNull(currentUserUUID) { "currentUserId must not be null" }
 
       callback(Result.success(messages)) // Or whatever logic you'd like to simulate
       return mockk()
Index: app/src/main/java/com/android/bookswap/ui/theme/Theme.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.theme\n\nimport android.app.Activity\nimport android.os.Build\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.darkColorScheme\nimport androidx.compose.material3.dynamicDarkColorScheme\nimport androidx.compose.material3.dynamicLightColorScheme\nimport androidx.compose.material3.lightColorScheme\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.SideEffect\nimport androidx.compose.ui.graphics.toArgb\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.platform.LocalView\nimport androidx.core.view.WindowCompat\n\nprivate val DarkColorScheme =\n    darkColorScheme(\n        primary = ColorVariable.Purple80,\n        secondary = ColorVariable.PurpleGrey80,\n        tertiary = ColorVariable.Pink80)\n\nprivate val LightColorScheme =\n    lightColorScheme(\n        primary = ColorVariable.Purple40,\n        secondary = ColorVariable.PurpleGrey40,\n        tertiary = ColorVariable.Pink40\n\n        /* Other default colors to override\n        background = Color(0xFFFFFBFE),\n        surface = Color(0xFFFFFBFE),\n        onPrimary = Color.White,\n        onSecondary = Color.White,\n        onTertiary = Color.White,\n        onBackground = Color(0xFF1C1B1F),\n        onSurface = Color(0xFF1C1B1F),\n        */\n        )\n\n@Composable\nfun BookSwapAppTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    // Dynamic color is available on Android 12+\n    dynamicColor: Boolean = true,\n    content: @Composable () -> Unit\n) {\n  val colorScheme =\n      when {\n        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {\n          val context = LocalContext.current\n          if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)\n        }\n        darkTheme -> DarkColorScheme\n        else -> LightColorScheme\n      }\n  val view = LocalView.current\n  if (!view.isInEditMode) {\n    SideEffect {\n      val window = (view.context as Activity).window\n      window.statusBarColor = colorScheme.primary.toArgb()\n      WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = darkTheme\n    }\n  }\n\n  MaterialTheme(colorScheme = colorScheme, typography = Typography, content = content)\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/theme/Theme.kt b/app/src/main/java/com/android/bookswap/ui/theme/Theme.kt
--- a/app/src/main/java/com/android/bookswap/ui/theme/Theme.kt	
+++ b/app/src/main/java/com/android/bookswap/ui/theme/Theme.kt	
@@ -9,40 +9,264 @@
 import androidx.compose.material3.dynamicLightColorScheme
 import androidx.compose.material3.lightColorScheme
 import androidx.compose.runtime.Composable
+import androidx.compose.runtime.Immutable
 import androidx.compose.runtime.SideEffect
+import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.graphics.toArgb
 import androidx.compose.ui.platform.LocalContext
 import androidx.compose.ui.platform.LocalView
 import androidx.core.view.WindowCompat
 
-private val DarkColorScheme =
+private val lightScheme =
+    lightColorScheme(
+        primary = primaryLight,
+        onPrimary = onPrimaryLight,
+        primaryContainer = primaryContainerLight,
+        onPrimaryContainer = onPrimaryContainerLight,
+        secondary = secondaryLight,
+        onSecondary = onSecondaryLight,
+        secondaryContainer = secondaryContainerLight,
+        onSecondaryContainer = onSecondaryContainerLight,
+        tertiary = tertiaryLight,
+        onTertiary = onTertiaryLight,
+        tertiaryContainer = tertiaryContainerLight,
+        onTertiaryContainer = onTertiaryContainerLight,
+        error = errorLight,
+        onError = onErrorLight,
+        errorContainer = errorContainerLight,
+        onErrorContainer = onErrorContainerLight,
+        background = backgroundLight,
+        onBackground = onBackgroundLight,
+        surface = surfaceLight,
+        onSurface = onSurfaceLight,
+        surfaceVariant = surfaceVariantLight,
+        onSurfaceVariant = onSurfaceVariantLight,
+        outline = outlineLight,
+        outlineVariant = outlineVariantLight,
+        scrim = scrimLight,
+        inverseSurface = inverseSurfaceLight,
+        inverseOnSurface = inverseOnSurfaceLight,
+        inversePrimary = inversePrimaryLight,
+        surfaceDim = surfaceDimLight,
+        surfaceBright = surfaceBrightLight,
+        surfaceContainerLowest = surfaceContainerLowestLight,
+        surfaceContainerLow = surfaceContainerLowLight,
+        surfaceContainer = surfaceContainerLight,
+        surfaceContainerHigh = surfaceContainerHighLight,
+        surfaceContainerHighest = surfaceContainerHighestLight,
+    )
+
+private val darkScheme =
     darkColorScheme(
-        primary = ColorVariable.Purple80,
-        secondary = ColorVariable.PurpleGrey80,
-        tertiary = ColorVariable.Pink80)
+        primary = primaryDark,
+        onPrimary = onPrimaryDark,
+        primaryContainer = primaryContainerDark,
+        onPrimaryContainer = onPrimaryContainerDark,
+        secondary = secondaryDark,
+        onSecondary = onSecondaryDark,
+        secondaryContainer = secondaryContainerDark,
+        onSecondaryContainer = onSecondaryContainerDark,
+        tertiary = tertiaryDark,
+        onTertiary = onTertiaryDark,
+        tertiaryContainer = tertiaryContainerDark,
+        onTertiaryContainer = onTertiaryContainerDark,
+        error = errorDark,
+        onError = onErrorDark,
+        errorContainer = errorContainerDark,
+        onErrorContainer = onErrorContainerDark,
+        background = backgroundDark,
+        onBackground = onBackgroundDark,
+        surface = surfaceDark,
+        onSurface = onSurfaceDark,
+        surfaceVariant = surfaceVariantDark,
+        onSurfaceVariant = onSurfaceVariantDark,
+        outline = outlineDark,
+        outlineVariant = outlineVariantDark,
+        scrim = scrimDark,
+        inverseSurface = inverseSurfaceDark,
+        inverseOnSurface = inverseOnSurfaceDark,
+        inversePrimary = inversePrimaryDark,
+        surfaceDim = surfaceDimDark,
+        surfaceBright = surfaceBrightDark,
+        surfaceContainerLowest = surfaceContainerLowestDark,
+        surfaceContainerLow = surfaceContainerLowDark,
+        surfaceContainer = surfaceContainerDark,
+        surfaceContainerHigh = surfaceContainerHighDark,
+        surfaceContainerHighest = surfaceContainerHighestDark,
+    )
 
-private val LightColorScheme =
+private val mediumContrastLightColorScheme =
+    lightColorScheme(
+        primary = primaryLightMediumContrast,
+        onPrimary = onPrimaryLightMediumContrast,
+        primaryContainer = primaryContainerLightMediumContrast,
+        onPrimaryContainer = onPrimaryContainerLightMediumContrast,
+        secondary = secondaryLightMediumContrast,
+        onSecondary = onSecondaryLightMediumContrast,
+        secondaryContainer = secondaryContainerLightMediumContrast,
+        onSecondaryContainer = onSecondaryContainerLightMediumContrast,
+        tertiary = tertiaryLightMediumContrast,
+        onTertiary = onTertiaryLightMediumContrast,
+        tertiaryContainer = tertiaryContainerLightMediumContrast,
+        onTertiaryContainer = onTertiaryContainerLightMediumContrast,
+        error = errorLightMediumContrast,
+        onError = onErrorLightMediumContrast,
+        errorContainer = errorContainerLightMediumContrast,
+        onErrorContainer = onErrorContainerLightMediumContrast,
+        background = backgroundLightMediumContrast,
+        onBackground = onBackgroundLightMediumContrast,
+        surface = surfaceLightMediumContrast,
+        onSurface = onSurfaceLightMediumContrast,
+        surfaceVariant = surfaceVariantLightMediumContrast,
+        onSurfaceVariant = onSurfaceVariantLightMediumContrast,
+        outline = outlineLightMediumContrast,
+        outlineVariant = outlineVariantLightMediumContrast,
+        scrim = scrimLightMediumContrast,
+        inverseSurface = inverseSurfaceLightMediumContrast,
+        inverseOnSurface = inverseOnSurfaceLightMediumContrast,
+        inversePrimary = inversePrimaryLightMediumContrast,
+        surfaceDim = surfaceDimLightMediumContrast,
+        surfaceBright = surfaceBrightLightMediumContrast,
+        surfaceContainerLowest = surfaceContainerLowestLightMediumContrast,
+        surfaceContainerLow = surfaceContainerLowLightMediumContrast,
+        surfaceContainer = surfaceContainerLightMediumContrast,
+        surfaceContainerHigh = surfaceContainerHighLightMediumContrast,
+        surfaceContainerHighest = surfaceContainerHighestLightMediumContrast,
+    )
+
+private val highContrastLightColorScheme =
     lightColorScheme(
-        primary = ColorVariable.Purple40,
-        secondary = ColorVariable.PurpleGrey40,
-        tertiary = ColorVariable.Pink40
+        primary = primaryLightHighContrast,
+        onPrimary = onPrimaryLightHighContrast,
+        primaryContainer = primaryContainerLightHighContrast,
+        onPrimaryContainer = onPrimaryContainerLightHighContrast,
+        secondary = secondaryLightHighContrast,
+        onSecondary = onSecondaryLightHighContrast,
+        secondaryContainer = secondaryContainerLightHighContrast,
+        onSecondaryContainer = onSecondaryContainerLightHighContrast,
+        tertiary = tertiaryLightHighContrast,
+        onTertiary = onTertiaryLightHighContrast,
+        tertiaryContainer = tertiaryContainerLightHighContrast,
+        onTertiaryContainer = onTertiaryContainerLightHighContrast,
+        error = errorLightHighContrast,
+        onError = onErrorLightHighContrast,
+        errorContainer = errorContainerLightHighContrast,
+        onErrorContainer = onErrorContainerLightHighContrast,
+        background = backgroundLightHighContrast,
+        onBackground = onBackgroundLightHighContrast,
+        surface = surfaceLightHighContrast,
+        onSurface = onSurfaceLightHighContrast,
+        surfaceVariant = surfaceVariantLightHighContrast,
+        onSurfaceVariant = onSurfaceVariantLightHighContrast,
+        outline = outlineLightHighContrast,
+        outlineVariant = outlineVariantLightHighContrast,
+        scrim = scrimLightHighContrast,
+        inverseSurface = inverseSurfaceLightHighContrast,
+        inverseOnSurface = inverseOnSurfaceLightHighContrast,
+        inversePrimary = inversePrimaryLightHighContrast,
+        surfaceDim = surfaceDimLightHighContrast,
+        surfaceBright = surfaceBrightLightHighContrast,
+        surfaceContainerLowest = surfaceContainerLowestLightHighContrast,
+        surfaceContainerLow = surfaceContainerLowLightHighContrast,
+        surfaceContainer = surfaceContainerLightHighContrast,
+        surfaceContainerHigh = surfaceContainerHighLightHighContrast,
+        surfaceContainerHighest = surfaceContainerHighestLightHighContrast,
+    )
+
+private val mediumContrastDarkColorScheme =
+    darkColorScheme(
+        primary = primaryDarkMediumContrast,
+        onPrimary = onPrimaryDarkMediumContrast,
+        primaryContainer = primaryContainerDarkMediumContrast,
+        onPrimaryContainer = onPrimaryContainerDarkMediumContrast,
+        secondary = secondaryDarkMediumContrast,
+        onSecondary = onSecondaryDarkMediumContrast,
+        secondaryContainer = secondaryContainerDarkMediumContrast,
+        onSecondaryContainer = onSecondaryContainerDarkMediumContrast,
+        tertiary = tertiaryDarkMediumContrast,
+        onTertiary = onTertiaryDarkMediumContrast,
+        tertiaryContainer = tertiaryContainerDarkMediumContrast,
+        onTertiaryContainer = onTertiaryContainerDarkMediumContrast,
+        error = errorDarkMediumContrast,
+        onError = onErrorDarkMediumContrast,
+        errorContainer = errorContainerDarkMediumContrast,
+        onErrorContainer = onErrorContainerDarkMediumContrast,
+        background = backgroundDarkMediumContrast,
+        onBackground = onBackgroundDarkMediumContrast,
+        surface = surfaceDarkMediumContrast,
+        onSurface = onSurfaceDarkMediumContrast,
+        surfaceVariant = surfaceVariantDarkMediumContrast,
+        onSurfaceVariant = onSurfaceVariantDarkMediumContrast,
+        outline = outlineDarkMediumContrast,
+        outlineVariant = outlineVariantDarkMediumContrast,
+        scrim = scrimDarkMediumContrast,
+        inverseSurface = inverseSurfaceDarkMediumContrast,
+        inverseOnSurface = inverseOnSurfaceDarkMediumContrast,
+        inversePrimary = inversePrimaryDarkMediumContrast,
+        surfaceDim = surfaceDimDarkMediumContrast,
+        surfaceBright = surfaceBrightDarkMediumContrast,
+        surfaceContainerLowest = surfaceContainerLowestDarkMediumContrast,
+        surfaceContainerLow = surfaceContainerLowDarkMediumContrast,
+        surfaceContainer = surfaceContainerDarkMediumContrast,
+        surfaceContainerHigh = surfaceContainerHighDarkMediumContrast,
+        surfaceContainerHighest = surfaceContainerHighestDarkMediumContrast,
+    )
+
+private val highContrastDarkColorScheme =
+    darkColorScheme(
+        primary = primaryDarkHighContrast,
+        onPrimary = onPrimaryDarkHighContrast,
+        primaryContainer = primaryContainerDarkHighContrast,
+        onPrimaryContainer = onPrimaryContainerDarkHighContrast,
+        secondary = secondaryDarkHighContrast,
+        onSecondary = onSecondaryDarkHighContrast,
+        secondaryContainer = secondaryContainerDarkHighContrast,
+        onSecondaryContainer = onSecondaryContainerDarkHighContrast,
+        tertiary = tertiaryDarkHighContrast,
+        onTertiary = onTertiaryDarkHighContrast,
+        tertiaryContainer = tertiaryContainerDarkHighContrast,
+        onTertiaryContainer = onTertiaryContainerDarkHighContrast,
+        error = errorDarkHighContrast,
+        onError = onErrorDarkHighContrast,
+        errorContainer = errorContainerDarkHighContrast,
+        onErrorContainer = onErrorContainerDarkHighContrast,
+        background = backgroundDarkHighContrast,
+        onBackground = onBackgroundDarkHighContrast,
+        surface = surfaceDarkHighContrast,
+        onSurface = onSurfaceDarkHighContrast,
+        surfaceVariant = surfaceVariantDarkHighContrast,
+        onSurfaceVariant = onSurfaceVariantDarkHighContrast,
+        outline = outlineDarkHighContrast,
+        outlineVariant = outlineVariantDarkHighContrast,
+        scrim = scrimDarkHighContrast,
+        inverseSurface = inverseSurfaceDarkHighContrast,
+        inverseOnSurface = inverseOnSurfaceDarkHighContrast,
+        inversePrimary = inversePrimaryDarkHighContrast,
+        surfaceDim = surfaceDimDarkHighContrast,
+        surfaceBright = surfaceBrightDarkHighContrast,
+        surfaceContainerLowest = surfaceContainerLowestDarkHighContrast,
+        surfaceContainerLow = surfaceContainerLowDarkHighContrast,
+        surfaceContainer = surfaceContainerDarkHighContrast,
+        surfaceContainerHigh = surfaceContainerHighDarkHighContrast,
+        surfaceContainerHighest = surfaceContainerHighestDarkHighContrast,
+    )
 
-        /* Other default colors to override
-        background = Color(0xFFFFFBFE),
-        surface = Color(0xFFFFFBFE),
-        onPrimary = Color.White,
-        onSecondary = Color.White,
-        onTertiary = Color.White,
-        onBackground = Color(0xFF1C1B1F),
-        onSurface = Color(0xFF1C1B1F),
-        */
-        )
+@Immutable
+data class ColorFamily(
+    val color: Color,
+    val onColor: Color,
+    val colorContainer: Color,
+    val onColorContainer: Color
+)
+
+val unspecified_scheme =
+    ColorFamily(Color.Unspecified, Color.Unspecified, Color.Unspecified, Color.Unspecified)
 
 @Composable
 fun BookSwapAppTheme(
     darkTheme: Boolean = isSystemInDarkTheme(),
     // Dynamic color is available on Android 12+
-    dynamicColor: Boolean = true,
+    dynamicColor: Boolean = false,
     content: @Composable () -> Unit
 ) {
   val colorScheme =
@@ -51,8 +275,8 @@
           val context = LocalContext.current
           if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
         }
-        darkTheme -> DarkColorScheme
-        else -> LightColorScheme
+        darkTheme -> darkScheme
+        else -> lightScheme
       }
   val view = LocalView.current
   if (!view.isInEditMode) {
@@ -63,5 +287,5 @@
     }
   }
 
-  MaterialTheme(colorScheme = colorScheme, typography = Typography, content = content)
+  MaterialTheme(colorScheme = colorScheme, typography = BookSwapTypography, content = content)
 }
Index: app/src/main/java/com/android/bookswap/ui/theme/Type.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.theme\n\nimport androidx.compose.material3.Typography\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.sp\n\n// Set of Material typography styles to start with\nval Typography =\n    Typography(\n        bodyLarge =\n            TextStyle(\n                fontFamily = FontFamily.Default,\n                fontWeight = FontWeight.Normal,\n                fontSize = 16.sp,\n                lineHeight = 24.sp,\n                letterSpacing = 0.5.sp)\n        /* Other default text styles to override\n        titleLarge = TextStyle(\n            fontFamily = FontFamily.Default,\n            fontWeight = FontWeight.Normal,\n            fontSize = 22.sp,\n            lineHeight = 28.sp,\n            letterSpacing = 0.sp\n        ),\n        labelSmall = TextStyle(\n            fontFamily = FontFamily.Default,\n            fontWeight = FontWeight.Medium,\n            fontSize = 11.sp,\n            lineHeight = 16.sp,\n            letterSpacing = 0.5.sp\n        )\n        */\n        )\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/theme/Type.kt b/app/src/main/java/com/android/bookswap/ui/theme/Type.kt
--- a/app/src/main/java/com/android/bookswap/ui/theme/Type.kt	
+++ b/app/src/main/java/com/android/bookswap/ui/theme/Type.kt	
@@ -1,35 +1,23 @@
 package com.android.bookswap.ui.theme
 
 import androidx.compose.material3.Typography
-import androidx.compose.ui.text.TextStyle
-import androidx.compose.ui.text.font.FontFamily
-import androidx.compose.ui.text.font.FontWeight
-import androidx.compose.ui.unit.sp
 
 // Set of Material typography styles to start with
-val Typography =
+val BookSwapTypography =
     Typography(
-        bodyLarge =
-            TextStyle(
-                fontFamily = FontFamily.Default,
-                fontWeight = FontWeight.Normal,
-                fontSize = 16.sp,
-                lineHeight = 24.sp,
-                letterSpacing = 0.5.sp)
-        /* Other default text styles to override
-        titleLarge = TextStyle(
-            fontFamily = FontFamily.Default,
-            fontWeight = FontWeight.Normal,
-            fontSize = 22.sp,
-            lineHeight = 28.sp,
-            letterSpacing = 0.sp
-        ),
-        labelSmall = TextStyle(
-            fontFamily = FontFamily.Default,
-            fontWeight = FontWeight.Medium,
-            fontSize = 11.sp,
-            lineHeight = 16.sp,
-            letterSpacing = 0.5.sp
-        )
-        */
-        )
+        displayLarge = Typography().displayLarge.copy(),
+        displayMedium = Typography().displayMedium.copy(),
+        displaySmall = Typography().displaySmall.copy(),
+        headlineLarge = Typography().headlineLarge.copy(),
+        headlineMedium = Typography().headlineMedium.copy(),
+        headlineSmall = Typography().headlineSmall.copy(),
+        titleLarge = Typography().titleLarge.copy(),
+        titleMedium = Typography().titleMedium.copy(),
+        titleSmall = Typography().titleSmall.copy(),
+        bodyLarge = Typography().bodyLarge.copy(),
+        bodyMedium = Typography().bodyMedium.copy(),
+        bodySmall = Typography().bodySmall.copy(),
+        labelLarge = Typography().labelLarge.copy(),
+        labelMedium = Typography().labelMedium.copy(),
+        labelSmall = Typography().labelSmall.copy(),
+    )
Index: app/src/main/java/com/android/bookswap/ui/theme/Color.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.theme\n\nimport androidx.compose.ui.graphics.Color\n\nobject ColorVariable {\n  val Purple80 = Color(0xFFD0BCFF)\n  val PurpleGrey80 = Color(0xFFCCC2DC)\n  val Pink80 = Color(0xFFEFB8C8)\n\n  val Purple40 = Color(0xFF6650a4)\n  val PurpleGrey40 = Color(0xFF625b71)\n  val Pink40 = Color(0xFF7D5260)\n\n  val BackGround = Color(0xFFF0EAD2)\n  val Accent = Color(0xFF6C584C)\n  val Primary = Color(0xFFADC178)\n  val AccentSecondary = Color(0xFFA98467)\n  val Secondary = Color(0xFFDDE5B6)\n  val Green = Color(0xFFADC178)\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/theme/Color.kt b/app/src/main/java/com/android/bookswap/ui/theme/Color.kt
--- a/app/src/main/java/com/android/bookswap/ui/theme/Color.kt	
+++ b/app/src/main/java/com/android/bookswap/ui/theme/Color.kt	
@@ -18,3 +18,219 @@
   val Secondary = Color(0xFFDDE5B6)
   val Green = Color(0xFFADC178)
 }
+
+val primaryLight = Color(0xFF536525)
+val onPrimaryLight = Color(0xFFFFFFFF)
+val primaryContainerLight = Color(0xFFD6EB9C)
+val onPrimaryContainerLight = Color(0xFF151F00)
+val secondaryLight = Color(0xFF5A6147)
+val onSecondaryLight = Color(0xFFFFFFFF)
+val secondaryContainerLight = Color(0xFFDFE6C4)
+val onSecondaryContainerLight = Color(0xFF181E09)
+val tertiaryLight = Color(0xFF39665F)
+val onTertiaryLight = Color(0xFFFFFFFF)
+val tertiaryContainerLight = Color(0xFFBCECE3)
+val onTertiaryContainerLight = Color(0xFF00201C)
+val errorLight = Color(0xFFBA1A1A)
+val onErrorLight = Color(0xFFFFFFFF)
+val errorContainerLight = Color(0xFFFFDAD6)
+val onErrorContainerLight = Color(0xFF410002)
+val backgroundLight = Color(0xFFFAFAEE)
+val onBackgroundLight = Color(0xFF1B1C15)
+val surfaceLight = Color(0xFFFAFAEE)
+val onSurfaceLight = Color(0xFF1B1C15)
+val surfaceVariantLight = Color(0xFFE2E4D4)
+val onSurfaceVariantLight = Color(0xFF45483C)
+val outlineLight = Color(0xFFA98467)
+val outlineVariantLight = Color(0xFFC6C8B8)
+val scrimLight = Color(0xFF000000)
+val inverseSurfaceLight = Color(0xFF303129)
+val inverseOnSurfaceLight = Color(0xFFF2F1E5)
+val inversePrimaryLight = Color(0xFFBACF82)
+val surfaceDimLight = Color(0xFFDBDBCF)
+val surfaceBrightLight = Color(0xFFFAFAEE)
+val surfaceContainerLowestLight = Color(0xFFFFFFFF)
+val surfaceContainerLowLight = Color(0xFFF5F4E8)
+val surfaceContainerLight = Color(0xFFEFEFE2)
+val surfaceContainerHighLight = Color(0xFFE9E9DD)
+val surfaceContainerHighestLight = Color(0xFFE3E3D7)
+
+val primaryLightMediumContrast = Color(0xFF38480A)
+val onPrimaryLightMediumContrast = Color(0xFFFFFFFF)
+val primaryContainerLightMediumContrast = Color(0xFF697C39)
+val onPrimaryContainerLightMediumContrast = Color(0xFFFFFFFF)
+val secondaryLightMediumContrast = Color(0xFF3F452D)
+val onSecondaryLightMediumContrast = Color(0xFFFFFFFF)
+val secondaryContainerLightMediumContrast = Color(0xFF71785C)
+val onSecondaryContainerLightMediumContrast = Color(0xFFFFFFFF)
+val tertiaryLightMediumContrast = Color(0xFF1C4A43)
+val onTertiaryLightMediumContrast = Color(0xFFFFFFFF)
+val tertiaryContainerLightMediumContrast = Color(0xFF507D75)
+val onTertiaryContainerLightMediumContrast = Color(0xFFFFFFFF)
+val errorLightMediumContrast = Color(0xFF8C0009)
+val onErrorLightMediumContrast = Color(0xFFFFFFFF)
+val errorContainerLightMediumContrast = Color(0xFFDA342E)
+val onErrorContainerLightMediumContrast = Color(0xFFFFFFFF)
+val backgroundLightMediumContrast = Color(0xFFFAFAEE)
+val onBackgroundLightMediumContrast = Color(0xFF1B1C15)
+val surfaceLightMediumContrast = Color(0xFFFAFAEE)
+val onSurfaceLightMediumContrast = Color(0xFF1B1C15)
+val surfaceVariantLightMediumContrast = Color(0xFFE2E4D4)
+val onSurfaceVariantLightMediumContrast = Color(0xFF424438)
+val outlineLightMediumContrast = Color(0xFF5E6054)
+val outlineVariantLightMediumContrast = Color(0xFF7A7C6E)
+val scrimLightMediumContrast = Color(0xFF000000)
+val inverseSurfaceLightMediumContrast = Color(0xFF303129)
+val inverseOnSurfaceLightMediumContrast = Color(0xFFF2F1E5)
+val inversePrimaryLightMediumContrast = Color(0xFFBACF82)
+val surfaceDimLightMediumContrast = Color(0xFFDBDBCF)
+val surfaceBrightLightMediumContrast = Color(0xFFFAFAEE)
+val surfaceContainerLowestLightMediumContrast = Color(0xFFFFFFFF)
+val surfaceContainerLowLightMediumContrast = Color(0xFFF5F4E8)
+val surfaceContainerLightMediumContrast = Color(0xFFEFEFE2)
+val surfaceContainerHighLightMediumContrast = Color(0xFFE9E9DD)
+val surfaceContainerHighestLightMediumContrast = Color(0xFFE3E3D7)
+
+val primaryLightHighContrast = Color(0xFF1B2600)
+val onPrimaryLightHighContrast = Color(0xFFFFFFFF)
+val primaryContainerLightHighContrast = Color(0xFF38480A)
+val onPrimaryContainerLightHighContrast = Color(0xFFFFFFFF)
+val secondaryLightHighContrast = Color(0xFF1F240F)
+val onSecondaryLightHighContrast = Color(0xFFFFFFFF)
+val secondaryContainerLightHighContrast = Color(0xFF3F452D)
+val onSecondaryContainerLightHighContrast = Color(0xFFFFFFFF)
+val tertiaryLightHighContrast = Color(0xFF002823)
+val onTertiaryLightHighContrast = Color(0xFFFFFFFF)
+val tertiaryContainerLightHighContrast = Color(0xFF1C4A43)
+val onTertiaryContainerLightHighContrast = Color(0xFFFFFFFF)
+val errorLightHighContrast = Color(0xFF4E0002)
+val onErrorLightHighContrast = Color(0xFFFFFFFF)
+val errorContainerLightHighContrast = Color(0xFF8C0009)
+val onErrorContainerLightHighContrast = Color(0xFFFFFFFF)
+val backgroundLightHighContrast = Color(0xFFFAFAEE)
+val onBackgroundLightHighContrast = Color(0xFF1B1C15)
+val surfaceLightHighContrast = Color(0xFFFAFAEE)
+val onSurfaceLightHighContrast = Color(0xFF000000)
+val surfaceVariantLightHighContrast = Color(0xFFE2E4D4)
+val onSurfaceVariantLightHighContrast = Color(0xFF22251B)
+val outlineLightHighContrast = Color(0xFF424438)
+val outlineVariantLightHighContrast = Color(0xFF424438)
+val scrimLightHighContrast = Color(0xFF000000)
+val inverseSurfaceLightHighContrast = Color(0xFF303129)
+val inverseOnSurfaceLightHighContrast = Color(0xFFFFFFFF)
+val inversePrimaryLightHighContrast = Color(0xFFDFF5A5)
+val surfaceDimLightHighContrast = Color(0xFFDBDBCF)
+val surfaceBrightLightHighContrast = Color(0xFFFAFAEE)
+val surfaceContainerLowestLightHighContrast = Color(0xFFFFFFFF)
+val surfaceContainerLowLightHighContrast = Color(0xFFF5F4E8)
+val surfaceContainerLightHighContrast = Color(0xFFEFEFE2)
+val surfaceContainerHighLightHighContrast = Color(0xFFE9E9DD)
+val surfaceContainerHighestLightHighContrast = Color(0xFFE3E3D7)
+
+val primaryDark = Color(0xFFBACF82)
+val onPrimaryDark = Color(0xFF273500)
+val primaryContainerDark = Color(0xFF3C4D0E)
+val onPrimaryContainerDark = Color(0xFFD6EB9C)
+val secondaryDark = Color(0xFFC3CAAA)
+val onSecondaryDark = Color(0xFF2D331C)
+val secondaryContainerDark = Color(0xFF434931)
+val onSecondaryContainerDark = Color(0xFFDFE6C4)
+val tertiaryDark = Color(0xFFA1D0C7)
+val onTertiaryDark = Color(0xFF023731)
+val tertiaryContainerDark = Color(0xFF204E47)
+val onTertiaryContainerDark = Color(0xFFBCECE3)
+val errorDark = Color(0xFFFFB4AB)
+val onErrorDark = Color(0xFF690005)
+val errorContainerDark = Color(0xFF93000A)
+val onErrorContainerDark = Color(0xFFFFDAD6)
+val backgroundDark = Color(0xFF12140D)
+val onBackgroundDark = Color(0xFFE3E3D7)
+val surfaceDark = Color(0xFF12140D)
+val onSurfaceDark = Color(0xFFE3E3D7)
+val surfaceVariantDark = Color(0xFF45483C)
+val onSurfaceVariantDark = Color(0xFFC6C8B8)
+val outlineDark = Color(0xFF909284)
+val outlineVariantDark = Color(0xFF45483C)
+val scrimDark = Color(0xFF000000)
+val inverseSurfaceDark = Color(0xFFE3E3D7)
+val inverseOnSurfaceDark = Color(0xFF303129)
+val inversePrimaryDark = Color(0xFF536525)
+val surfaceDimDark = Color(0xFF12140D)
+val surfaceBrightDark = Color(0xFF383A32)
+val surfaceContainerLowestDark = Color(0xFF0D0F08)
+val surfaceContainerLowDark = Color(0xFF1B1C15)
+val surfaceContainerDark = Color(0xFF1F2019)
+val surfaceContainerHighDark = Color(0xFF292B23)
+val surfaceContainerHighestDark = Color(0xFF34362D)
+
+val primaryDarkMediumContrast = Color(0xFFBED386)
+val onPrimaryDarkMediumContrast = Color(0xFF111900)
+val primaryContainerDarkMediumContrast = Color(0xFF859852)
+val onPrimaryContainerDarkMediumContrast = Color(0xFF000000)
+val secondaryDarkMediumContrast = Color(0xFFC7CEAE)
+val onSecondaryDarkMediumContrast = Color(0xFF131805)
+val secondaryContainerDarkMediumContrast = Color(0xFF8D9476)
+val onSecondaryContainerDarkMediumContrast = Color(0xFF000000)
+val tertiaryDarkMediumContrast = Color(0xFFA5D4CB)
+val onTertiaryDarkMediumContrast = Color(0xFF001A17)
+val tertiaryContainerDarkMediumContrast = Color(0xFF6C9991)
+val onTertiaryContainerDarkMediumContrast = Color(0xFF000000)
+val errorDarkMediumContrast = Color(0xFFFFBAB1)
+val onErrorDarkMediumContrast = Color(0xFF370001)
+val errorContainerDarkMediumContrast = Color(0xFFFF5449)
+val onErrorContainerDarkMediumContrast = Color(0xFF000000)
+val backgroundDarkMediumContrast = Color(0xFF12140D)
+val onBackgroundDarkMediumContrast = Color(0xFFE3E3D7)
+val surfaceDarkMediumContrast = Color(0xFF12140D)
+val onSurfaceDarkMediumContrast = Color(0xFFFCFBEF)
+val surfaceVariantDarkMediumContrast = Color(0xFF45483C)
+val onSurfaceVariantDarkMediumContrast = Color(0xFFCACCBC)
+val outlineDarkMediumContrast = Color(0xFFA2A495)
+val outlineVariantDarkMediumContrast = Color(0xFF828477)
+val scrimDarkMediumContrast = Color(0xFF000000)
+val inverseSurfaceDarkMediumContrast = Color(0xFFE3E3D7)
+val inverseOnSurfaceDarkMediumContrast = Color(0xFF292B23)
+val inversePrimaryDarkMediumContrast = Color(0xFF3D4E0F)
+val surfaceDimDarkMediumContrast = Color(0xFF12140D)
+val surfaceBrightDarkMediumContrast = Color(0xFF383A32)
+val surfaceContainerLowestDarkMediumContrast = Color(0xFF0D0F08)
+val surfaceContainerLowDarkMediumContrast = Color(0xFF1B1C15)
+val surfaceContainerDarkMediumContrast = Color(0xFF1F2019)
+val surfaceContainerHighDarkMediumContrast = Color(0xFF292B23)
+val surfaceContainerHighestDarkMediumContrast = Color(0xFF34362D)
+
+val primaryDarkHighContrast = Color(0xFFF6FFD7)
+val onPrimaryDarkHighContrast = Color(0xFF000000)
+val primaryContainerDarkHighContrast = Color(0xFFBED386)
+val onPrimaryContainerDarkHighContrast = Color(0xFF000000)
+val secondaryDarkHighContrast = Color(0xFFF7FEDC)
+val onSecondaryDarkHighContrast = Color(0xFF000000)
+val secondaryContainerDarkHighContrast = Color(0xFFC7CEAE)
+val onSecondaryContainerDarkHighContrast = Color(0xFF000000)
+val tertiaryDarkHighContrast = Color(0xFFEBFFFA)
+val onTertiaryDarkHighContrast = Color(0xFF000000)
+val tertiaryContainerDarkHighContrast = Color(0xFFA5D4CB)
+val onTertiaryContainerDarkHighContrast = Color(0xFF000000)
+val errorDarkHighContrast = Color(0xFFFFF9F9)
+val onErrorDarkHighContrast = Color(0xFF000000)
+val errorContainerDarkHighContrast = Color(0xFFFFBAB1)
+val onErrorContainerDarkHighContrast = Color(0xFF000000)
+val backgroundDarkHighContrast = Color(0xFF12140D)
+val onBackgroundDarkHighContrast = Color(0xFFE3E3D7)
+val surfaceDarkHighContrast = Color(0xFF12140D)
+val onSurfaceDarkHighContrast = Color(0xFFFFFFFF)
+val surfaceVariantDarkHighContrast = Color(0xFF45483C)
+val onSurfaceVariantDarkHighContrast = Color(0xFFFBFCEB)
+val outlineDarkHighContrast = Color(0xFFCACCBC)
+val outlineVariantDarkHighContrast = Color(0xFFCACCBC)
+val scrimDarkHighContrast = Color(0xFF000000)
+val inverseSurfaceDarkHighContrast = Color(0xFFE3E3D7)
+val inverseOnSurfaceDarkHighContrast = Color(0xFF000000)
+val inversePrimaryDarkHighContrast = Color(0xFF222E00)
+val surfaceDimDarkHighContrast = Color(0xFF12140D)
+val surfaceBrightDarkHighContrast = Color(0xFF383A32)
+val surfaceContainerLowestDarkHighContrast = Color(0xFF0D0F08)
+val surfaceContainerLowDarkHighContrast = Color(0xFF1B1C15)
+val surfaceContainerDarkHighContrast = Color(0xFF1F2019)
+val surfaceContainerHighDarkHighContrast = Color(0xFF292B23)
+val surfaceContainerHighestDarkHighContrast = Color(0xFF34362D)
Index: app/src/main/java/com/android/bookswap/data/source/network/UserFirestoreSource.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.data.source.network\n\nimport android.util.Log\nimport com.android.bookswap.data.DataUser\nimport com.android.bookswap.data.repository.UsersRepository\nimport com.google.android.gms.tasks.Task\nimport com.google.firebase.firestore.DocumentSnapshot\nimport com.google.firebase.firestore.FirebaseFirestore\n\n/** Name of the Firestore collection that stores users */\nprivate const val COLLECTION_NAME = \"Users\"\n\n/** Implement [UsersRepository] interface using Firebase's Firestore as the data source */\nclass UserFirestoreSource(private val db: FirebaseFirestore) : UsersRepository {\n  /**\n   * Fetches the list of users from the Firestore collection If the task is successful, maps the\n   * Firestore documents to DataUser objects Calls OnSuccess with the list of users, or onFailure if\n   * the task fails\n   */\n  override fun getUsers(callback: (Result<List<DataUser>>) -> Unit) {\n    db.collection(COLLECTION_NAME).get().addOnCompleteListener { task ->\n      if (task.isSuccessful) {\n        // Maps Firestore documents to DataUser objects or returns an empty list\n        callback(\n            Result.success(\n                task.result?.mapNotNull { documentToUser(it).getOrNull() } ?: emptyList()))\n      } else {\n        callback(Result.failure(task.exception!!))\n      }\n    }\n  }\n  /**\n   * Fetches the list of users from the Firestore collection If the task is successful, maps the\n   * Firestore documents to DataUser objects Calls OnSuccess with the list of users, or onFailure if\n   * the task fails\n   */\n  override fun getUser(uuid: String, callback: (Result<DataUser>) -> Unit) {\n\n    db.collection(COLLECTION_NAME).whereEqualTo(\"UUID\", uuid).get().addOnCompleteListener { task ->\n      if (task.isSuccessful) {\n        // Maps Firestore documents to DataUser objects or returns an empty list\n        callback(\n            Result.success(\n                task.result?.firstNotNullOfOrNull { documentToUser(it).getOrNull() } ?: DataUser()))\n      } else {\n        callback(Result.failure(task.exception!!))\n      }\n    }\n  }\n\n  /** Adds a new user to the Firestore collection */\n  override fun addUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit) {\n    performFirestoreOperation(\n        db.collection(COLLECTION_NAME).document(dataUser.userId).set(dataUser),\n        callback,\n    )\n  }\n  /**\n   * Updates an existing user in Firestore by replacing the document with the same title Uses\n   * performFirestoreOperation to handle success and failure\n   */\n  override fun updateUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit) {\n    performFirestoreOperation(\n        db.collection(COLLECTION_NAME).document(dataUser.userId).set(dataUser), callback)\n  }\n\n  /**\n   * Deletes a user from Firestore by its title Uses performFirestoreOperation to handle success and\n   * failure\n   */\n  override fun deleteUser(uuid: String, callback: (Result<Unit>) -> Unit) {\n    performFirestoreOperation(\n        db.collection(COLLECTION_NAME).document(uuid.toString()).delete(), callback)\n  }\n  /**\n   * Maps a Firestore document to a DataUser object If any required field is missing, returns null\n   * to avoid incomplete objects\n   *\n   * @return DataUser on success, otherwise error\n   */\n  fun documentToUser(document: DocumentSnapshot): Result<DataUser> {\n\n    return try {\n      val userID = document.getString(\"UUID\")!!\n      val greeting = document.getString(\"Greeting\")!!\n      val firstname = document.getString(\"Firstname\")!!\n      val lastname = document.getString(\"Lastname\")!!\n      val email = document.getString(\"Email\")!!\n      val phoneNumber = document.getString(\"Phone\")!!\n      val latitude = document.getDouble(\"Latitude\")!!\n      val longitude = document.getDouble(\"Longitude\")!!\n      val profilePicture = document.getString(\"Picture\")!!\n      Result.success(\n          DataUser(\n              greeting,\n              firstname,\n              lastname,\n              email,\n              phoneNumber,\n              latitude,\n              longitude,\n              profilePicture,\n              userID))\n    } catch (e: Exception) {\n      Log.e(\"FirestoreSource\", \"Error converting document to User: ${e.message}\")\n      Result.failure(e)\n    }\n  }\n  /**\n   * Helper function to perform Firestore operations (add, update, delete) Executes the provided\n   * Firestore task and triggers success or failure callbacks\n   *\n   * @param callback callback function that receives Result.success() when operation succeed of\n   *   Result.failure(exception) if error\n   */\n  private fun performFirestoreOperation(task: Task<Void>, callback: (Result<Unit>) -> Unit) {\n    task.addOnCompleteListener { result ->\n      if (result.isSuccessful) {\n        callback(Result.success(Unit))\n      } else {\n        result.exception?.let { e -> callback(Result.failure(e)) }\n      }\n    }\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/source/network/UserFirestoreSource.kt b/app/src/main/java/com/android/bookswap/data/source/network/UserFirestoreSource.kt
--- a/app/src/main/java/com/android/bookswap/data/source/network/UserFirestoreSource.kt	
+++ b/app/src/main/java/com/android/bookswap/data/source/network/UserFirestoreSource.kt	
@@ -6,6 +6,7 @@
 import com.google.android.gms.tasks.Task
 import com.google.firebase.firestore.DocumentSnapshot
 import com.google.firebase.firestore.FirebaseFirestore
+import java.util.UUID
 
 /** Name of the Firestore collection that stores users */
 private const val COLLECTION_NAME = "Users"
@@ -34,7 +35,7 @@
    * Firestore documents to DataUser objects Calls OnSuccess with the list of users, or onFailure if
    * the task fails
    */
-  override fun getUser(uuid: String, callback: (Result<DataUser>) -> Unit) {
+  override fun getUser(uuid: UUID, callback: (Result<DataUser>) -> Unit) {
 
     db.collection(COLLECTION_NAME).whereEqualTo("UUID", uuid).get().addOnCompleteListener { task ->
       if (task.isSuccessful) {
@@ -51,7 +52,7 @@
   /** Adds a new user to the Firestore collection */
   override fun addUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit) {
     performFirestoreOperation(
-        db.collection(COLLECTION_NAME).document(dataUser.userId).set(dataUser),
+        db.collection(COLLECTION_NAME).document(dataUser.userUUID.toString()).set(dataUser),
         callback,
     )
   }
@@ -61,14 +62,15 @@
    */
   override fun updateUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit) {
     performFirestoreOperation(
-        db.collection(COLLECTION_NAME).document(dataUser.userId).set(dataUser), callback)
+        db.collection(COLLECTION_NAME).document(dataUser.userUUID.toString()).set(dataUser),
+        callback)
   }
 
   /**
    * Deletes a user from Firestore by its title Uses performFirestoreOperation to handle success and
    * failure
    */
-  override fun deleteUser(uuid: String, callback: (Result<Unit>) -> Unit) {
+  override fun deleteUser(uuid: UUID, callback: (Result<Unit>) -> Unit) {
     performFirestoreOperation(
         db.collection(COLLECTION_NAME).document(uuid.toString()).delete(), callback)
   }
@@ -81,17 +83,34 @@
   fun documentToUser(document: DocumentSnapshot): Result<DataUser> {
 
     return try {
-      val userID = document.getString("UUID")!!
-      val greeting = document.getString("Greeting")!!
-      val firstname = document.getString("Firstname")!!
-      val lastname = document.getString("Lastname")!!
-      val email = document.getString("Email")!!
-      val phoneNumber = document.getString("Phone")!!
-      val latitude = document.getDouble("Latitude")!!
-      val longitude = document.getDouble("Longitude")!!
-      val profilePicture = document.getString("Picture")!!
+      val mostSignificantBits = document.getLong("userUUID.mostSignificantBits")!!
+      val leastSignificantBits = document.getLong("userUUID.leastSignificantBits")!!
+      val greeting = document.getString("greeting")!!
+      val firstname = document.getString("firstName")!!
+      val lastname = document.getString("lastName")!!
+      val email = document.getString("email")!!
+      val phoneNumber = document.getString("phoneNumber")!!
+      val latitude = document.getDouble("latitude")!!
+      val longitude = document.getDouble("longitude")!!
+      val profilePicture = document.getString("profilePictureUrl")!!
+      val googleUid = document.getString("googleUid")!!
+      val bookList =
+          (document.get("bookList") as List<Map<String, Long>>).map { bookMap ->
+            val mostSigBits = bookMap["mostSignificantBits"]
+            val leastSigBits = bookMap["leastSignificantBits"]
+            if (mostSigBits != null && leastSigBits != null) {
+              UUID(mostSigBits, leastSigBits)
+            } else {
+              null
+            }
+          }
+      if (bookList.any { it == null }) {
+        throw IllegalArgumentException("Book list contains null UUIDs")
+      }
+
       Result.success(
           DataUser(
+              UUID(mostSignificantBits, leastSignificantBits),
               greeting,
               firstname,
               lastname,
@@ -100,7 +119,8 @@
               latitude,
               longitude,
               profilePicture,
-              userID))
+              bookList.filterNotNull(),
+              googleUid))
     } catch (e: Exception) {
       Log.e("FirestoreSource", "Error converting document to User: ${e.message}")
       Result.failure(e)
Index: app/src/main/java/com/android/bookswap/data/repository/UserRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.data.repository\n\nimport com.android.bookswap.data.DataUser\n\n/** Interface defining a contract for managing user-related operations in a repository. */\ninterface UsersRepository {\n  /**\n   * Function to fetch a list of users from the repository.\n   *\n   * @param callback callback function that receives list of user if success\n   */\n  fun getUsers(\n      callback: (Result<List<DataUser>>) -> Unit,\n  )\n\n  /**\n   * Function to fetch a list of users from the repository.\n   *\n   * @param callback callback function that receives list of user if success\n   */\n  fun getUser(\n      uuid: String,\n      callback: (Result<DataUser>) -> Unit,\n  )\n\n  /**\n   * Function to add a new user to the repository.\n   *\n   * @param dataUser The user data to be added.\n   * @param callback callback function that receives Result.success() when operation succeed of\n   *   Result.failure(exception) if error\n   */\n  fun addUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit)\n\n  /**\n   * Function to update an existing user in the repository.\n   *\n   * @param dataUser The user data to be updated.\n   * @param callback callback function that receives Result.success() when operation succeed of\n   *   Result.failure(exception) if error\n   */\n  fun updateUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit)\n\n  /**\n   * Function to delete a user from the repository.\n   *\n   * @param uuid The unique identifier of the user to be deleted.\n   * @param callback callback function that receives Result.success() when operation succeed of\n   *   Result.failure(exception) if error\n   */\n  fun deleteUser(uuid: String, callback: (Result<Unit>) -> Unit)\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/repository/UserRepository.kt b/app/src/main/java/com/android/bookswap/data/repository/UserRepository.kt
--- a/app/src/main/java/com/android/bookswap/data/repository/UserRepository.kt	
+++ b/app/src/main/java/com/android/bookswap/data/repository/UserRepository.kt	
@@ -1,6 +1,7 @@
 package com.android.bookswap.data.repository
 
 import com.android.bookswap.data.DataUser
+import java.util.UUID
 
 /** Interface defining a contract for managing user-related operations in a repository. */
 interface UsersRepository {
@@ -19,7 +20,7 @@
    * @param callback callback function that receives list of user if success
    */
   fun getUser(
-      uuid: String,
+      uuid: UUID,
       callback: (Result<DataUser>) -> Unit,
   )
 
@@ -48,5 +49,5 @@
    * @param callback callback function that receives Result.success() when operation succeed of
    *   Result.failure(exception) if error
    */
-  fun deleteUser(uuid: String, callback: (Result<Unit>) -> Unit)
+  fun deleteUser(uuid: UUID, callback: (Result<Unit>) -> Unit)
 }
Index: app/src/main/java/com/android/bookswap/data/repository/MessageRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.data.repository\n\nimport android.content.Context\nimport com.android.bookswap.data.DataMessage\nimport com.google.firebase.firestore.ListenerRegistration\n\ninterface MessageRepository {\n\n  /** Generates a new unique id for a message */\n  fun getNewUid(): String\n\n  /**\n   * Initialize the repository\n   *\n   * @param callback callback function that receives Result.success() when operation succeed of\n   *   Result.failure(exception) if error\n   */\n  fun init(callback: (Result<Unit>) -> Unit)\n\n  /**\n   * Get all messages as a list\n   *\n   * @param callback callback function that receives list of messages if success\n   */\n  fun getMessages(\n      callback: (Result<List<DataMessage>>) -> Unit,\n  )\n\n  /**\n   * Add a message to the repository\n   *\n   * @param message message to be added\n   * @param callback callback function that receives Result.success() when operation succeed of\n   *   Result.failure(exception) if error\n   */\n  fun sendMessage(message: DataMessage, callback: (Result<Unit>) -> Unit)\n\n  /**\n   * Delete a message from the repository\n   *\n   * @param message message to be deleted\n   * @param callback callback function that receives Result.success() when operation succeed of\n   *   Result.failure(exception) if error\n   */\n  fun deleteMessage(messageId: String, callback: (Result<Unit>) -> Unit, context: Context)\n\n  /**\n   * Delete all messages of this chat from the repository\n   *\n   * @param user1Id id of the first user\n   * @param user2Id id of the second user\n   * @param callback callback function that receives Result.success() when operation succeed of\n   *   Result.failure(exception) if error\n   */\n  fun deleteAllMessages(user1Id: String, user2Id: String, callback: (Result<Unit>) -> Unit)\n\n  /**\n   * Update a message in the repository\n   *\n   * @param message message to be updated\n   * @param callback callback function that receives Result.success() when operation succeed of\n   *   Result.failure(exception) if error\n   */\n  fun updateMessage(messageId: DataMessage, callback: (Result<Unit>) -> Unit, context: Context)\n\n  /**\n   * Add a listener to the repository to get messages in real-time\n   *\n   * @param otherUserId id of the other user\n   * @param currentUserId id of the current user\n   * @param callback callback function that receives list of messages if success\n   * @return ListenerRegistration object that can be used to remove the listener\n   */\n  fun addMessagesListener(\n      otherUserId: String,\n      currentUserId: String,\n      callback: (Result<List<DataMessage>>) -> Unit\n  ): ListenerRegistration\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/repository/MessageRepository.kt b/app/src/main/java/com/android/bookswap/data/repository/MessageRepository.kt
--- a/app/src/main/java/com/android/bookswap/data/repository/MessageRepository.kt	
+++ b/app/src/main/java/com/android/bookswap/data/repository/MessageRepository.kt	
@@ -3,11 +3,12 @@
 import android.content.Context
 import com.android.bookswap.data.DataMessage
 import com.google.firebase.firestore.ListenerRegistration
+import java.util.UUID
 
 interface MessageRepository {
 
   /** Generates a new unique id for a message */
-  fun getNewUid(): String
+  fun getNewUUID(): UUID
 
   /**
    * Initialize the repository
@@ -38,21 +39,21 @@
   /**
    * Delete a message from the repository
    *
-   * @param message message to be deleted
+   * @param messageUUID UUID of message to be deleted
    * @param callback callback function that receives Result.success() when operation succeed of
    *   Result.failure(exception) if error
    */
-  fun deleteMessage(messageId: String, callback: (Result<Unit>) -> Unit, context: Context)
+  fun deleteMessage(messageUUID: UUID, callback: (Result<Unit>) -> Unit, context: Context)
 
   /**
    * Delete all messages of this chat from the repository
    *
-   * @param user1Id id of the first user
-   * @param user2Id id of the second user
+   * @param user1UUID uuid of the first user
+   * @param user2UUID uuid of the second user
    * @param callback callback function that receives Result.success() when operation succeed of
    *   Result.failure(exception) if error
    */
-  fun deleteAllMessages(user1Id: String, user2Id: String, callback: (Result<Unit>) -> Unit)
+  fun deleteAllMessages(user1UUID: UUID, user2UUID: UUID, callback: (Result<Unit>) -> Unit)
 
   /**
    * Update a message in the repository
@@ -61,19 +62,19 @@
    * @param callback callback function that receives Result.success() when operation succeed of
    *   Result.failure(exception) if error
    */
-  fun updateMessage(messageId: DataMessage, callback: (Result<Unit>) -> Unit, context: Context)
+  fun updateMessage(message: DataMessage, callback: (Result<Unit>) -> Unit, context: Context)
 
   /**
    * Add a listener to the repository to get messages in real-time
    *
-   * @param otherUserId id of the other user
-   * @param currentUserId id of the current user
+   * @param otherUserUUID UUID of the other user
+   * @param currentUserUUID UUID of the current user
    * @param callback callback function that receives list of messages if success
    * @return ListenerRegistration object that can be used to remove the listener
    */
   fun addMessagesListener(
-      otherUserId: String,
-      currentUserId: String,
+      otherUserUUID: UUID,
+      currentUserUUID: UUID,
       callback: (Result<List<DataMessage>>) -> Unit
   ): ListenerRegistration
 }
Index: app/src/test/java/com/android/bookswap/data/source/network/UserFirestoreSourceTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.data.source.network\n\nimport android.util.Log\nimport androidx.test.core.app.ApplicationProvider\nimport com.android.bookswap.data.DataUser\nimport com.google.android.gms.tasks.Tasks\nimport com.google.firebase.FirebaseApp\nimport com.google.firebase.firestore.CollectionReference\nimport com.google.firebase.firestore.DocumentReference\nimport com.google.firebase.firestore.DocumentSnapshot\nimport com.google.firebase.firestore.FirebaseFirestore\nimport com.google.firebase.firestore.Query\nimport com.google.firebase.firestore.QuerySnapshot\nimport com.google.firebase.firestore.util.Assert.fail\nimport org.junit.After\nimport org.junit.Before\nimport org.junit.Test\nimport org.junit.runner.RunWith\nimport org.mockito.ArgumentMatchers\nimport org.mockito.Mock\nimport org.mockito.Mockito.`when`\nimport org.mockito.MockitoAnnotations\nimport org.mockito.kotlin.doAnswer\nimport org.mockito.kotlin.eq\nimport org.mockito.kotlin.verify\nimport org.robolectric.RobolectricTestRunner\n\n@RunWith(RobolectricTestRunner::class)\nclass UserFirestoreSourceTest {\n\n  @Mock private lateinit var mockFirestore: FirebaseFirestore\n  @Mock private lateinit var mockCollectionReference: CollectionReference\n  @Mock private lateinit var mockDocumentReference: DocumentReference\n  @Mock private lateinit var mockDocumentSnapshot: DocumentSnapshot\n  @Mock private lateinit var mockQuerySnapshot: QuerySnapshot\n  @Mock private lateinit var mockQuery: Query\n\n  private lateinit var userFirestoreSource: UserFirestoreSource\n\n  private val testUser =\n      DataUser(\n          \"M.\",\n          \"John\",\n          \"Doe\",\n          \"John.Doe@example.com\",\n          \"+41223456789\",\n          0.0,\n          0.0,\n          \"dummyPic.png\",\n          \"dummyUUID0000\")\n\n  @Before\n  fun setUp() {\n    MockitoAnnotations.openMocks(this)\n\n    // Initialize Firebase if necessary\n    if (FirebaseApp.getApps(ApplicationProvider.getApplicationContext()).isEmpty()) {\n      FirebaseApp.initializeApp(ApplicationProvider.getApplicationContext())\n    }\n\n    userFirestoreSource = UserFirestoreSource(mockFirestore)\n\n    `when`(mockFirestore.collection(ArgumentMatchers.any())).thenReturn(mockCollectionReference)\n    `when`(mockCollectionReference.document(ArgumentMatchers.any()))\n        .thenReturn(mockDocumentReference)\n    `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))\n  }\n\n  @After fun tearDown() {}\n\n  @Test fun init() {}\n\n  @Test\n  fun getUsers() {\n    // Arrange\n    `when`(mockQuerySnapshot.documents).thenReturn(listOf(mockDocumentSnapshot))\n    `when`(mockDocumentSnapshot.getString(\"UUID\")).thenReturn(testUser.userId)\n    `when`(mockDocumentSnapshot.getString(\"Greeting\")).thenReturn(testUser.greeting)\n    `when`(mockDocumentSnapshot.getString(\"Firstname\")).thenReturn(testUser.firstName)\n    `when`(mockDocumentSnapshot.getString(\"Lastname\")).thenReturn(testUser.lastName)\n    `when`(mockDocumentSnapshot.getString(\"Email\")).thenReturn(testUser.email)\n    `when`(mockDocumentSnapshot.getString(\"Phone\")).thenReturn(testUser.phoneNumber)\n    `when`(mockDocumentSnapshot.getDouble(\"Latitude\")).thenReturn(testUser.latitude)\n    `when`(mockDocumentSnapshot.getDouble(\"Longitude\")).thenReturn(testUser.longitude)\n    `when`(mockDocumentSnapshot.getString(\"Picture\")).thenReturn(testUser.profilePictureUrl)\n\n    // Act\n    userFirestoreSource.getUsers { result ->\n      result.fold(\n          {\n            // Assert proper data transfert\n            assert(it.isNotEmpty())\n            assert(it.first().printFullname() == testUser.printFullname())\n          },\n          { fail(\"Should not fail!\") })\n    }\n\n    // Verify Firestore collection was accessed\n    verify(mockCollectionReference).get()\n  }\n\n  @Test\n  fun getUser() {\n    // Arrange\n    `when`(mockQuerySnapshot.documents).thenReturn(listOf(mockDocumentSnapshot))\n    `when`(mockCollectionReference.whereEqualTo(eq(\"UUID\"), ArgumentMatchers.anyString()))\n        .thenReturn(mockQuery)\n    `when`(mockQuery.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))\n    `when`(mockDocumentSnapshot.getString(\"UUID\")).thenReturn(testUser.userId)\n    `when`(mockDocumentSnapshot.getString(\"Greeting\")).thenReturn(testUser.greeting)\n    `when`(mockDocumentSnapshot.getString(\"Firstname\")).thenReturn(testUser.firstName)\n    `when`(mockDocumentSnapshot.getString(\"Lastname\")).thenReturn(testUser.lastName)\n    `when`(mockDocumentSnapshot.getString(\"Email\")).thenReturn(testUser.email)\n    `when`(mockDocumentSnapshot.getString(\"Phone\")).thenReturn(testUser.phoneNumber)\n    `when`(mockDocumentSnapshot.getDouble(\"Latitude\")).thenReturn(testUser.latitude)\n    `when`(mockDocumentSnapshot.getDouble(\"Longitude\")).thenReturn(testUser.longitude)\n    `when`(mockDocumentSnapshot.getString(\"Picture\")).thenReturn(testUser.profilePictureUrl)\n\n    // Act\n    userFirestoreSource.getUser(\"dummyUUID0000\") { result ->\n      result.fold(\n          {\n            // Assert proper data transfert\n            assert(it.printFullname() == testUser.printFullname())\n          },\n          { fail(\"Should not fail!\") })\n    }\n\n    // Verify Firestore collection was accessed\n    verify(mockCollectionReference).whereEqualTo(eq(\"UUID\"), ArgumentMatchers.anyString())\n  }\n\n  @Test\n  fun addUser() {\n    // Arrange\n    doAnswer { Tasks.forResult(null) }.`when`(mockDocumentReference).set(testUser)\n\n    // Act\n    userFirestoreSource.addUser(testUser) { result ->\n      result.fold({ assert(true) }, { fail(\"Should not fail!\") })\n    }\n\n    // Verify Firestore collection was accessed\n    verify(mockDocumentReference).set(testUser)\n  }\n\n  @Test\n  fun updateUser() {\n    // Arrange\n    doAnswer { Tasks.forResult(null) }.`when`(mockDocumentReference).set(testUser)\n\n    // Act\n    userFirestoreSource.updateUser(testUser) { result ->\n      result.fold({ assert(true) }, { fail(\"Should not fail!\") })\n    }\n\n    // Verify Firestore collection was accessed\n    verify(mockDocumentReference).set(testUser)\n  }\n\n  @Test\n  fun deleteUser() {\n    // Arrange\n    doAnswer { Tasks.forResult(null) }.`when`(mockDocumentReference).delete()\n\n    // Act\n    userFirestoreSource.deleteUser(testUser.userId) { result ->\n      result.fold({ assert(true) }, { fail(\"Should not fail!\") })\n    }\n\n    // Verify Firestore collection was accessed\n    verify(mockDocumentReference).delete()\n  }\n\n  @Test\n  fun documentToUser_validDoc() {\n    // Arrange\n    `when`(mockDocumentSnapshot.getString(\"UUID\")).thenReturn(testUser.userId)\n    `when`(mockDocumentSnapshot.getString(\"Greeting\")).thenReturn(testUser.greeting)\n    `when`(mockDocumentSnapshot.getString(\"Firstname\")).thenReturn(testUser.firstName)\n    `when`(mockDocumentSnapshot.getString(\"Lastname\")).thenReturn(testUser.lastName)\n    `when`(mockDocumentSnapshot.getString(\"Email\")).thenReturn(testUser.email)\n    `when`(mockDocumentSnapshot.getString(\"Phone\")).thenReturn(testUser.phoneNumber)\n    `when`(mockDocumentSnapshot.getDouble(\"Latitude\")).thenReturn(testUser.latitude)\n    `when`(mockDocumentSnapshot.getDouble(\"Longitude\")).thenReturn(testUser.longitude)\n    `when`(mockDocumentSnapshot.getString(\"Picture\")).thenReturn(testUser.profilePictureUrl)\n\n    // Act\n    val result = userFirestoreSource.documentToUser(mockDocumentSnapshot)\n\n    // Assert\n    assert(result.getOrNull() != null)\n    result.onSuccess { assert(it.printFullname() == testUser.printFullname()) }\n  }\n\n  @Test\n  fun documentToUser_invalidDoc() {\n    // Arrange\n    `when`(mockDocumentSnapshot.getString(\"UUID\")).thenReturn(testUser.userId)\n    `when`(mockDocumentSnapshot.getString(\"Greeting\")).thenReturn(null)\n    `when`(mockDocumentSnapshot.getString(\"Firstname\")).thenReturn(testUser.firstName)\n    `when`(mockDocumentSnapshot.getString(\"Lastname\")).thenReturn(testUser.lastName)\n    `when`(mockDocumentSnapshot.getString(\"Email\")).thenReturn(testUser.email)\n    `when`(mockDocumentSnapshot.getString(\"Phone\")).thenReturn(testUser.phoneNumber)\n    `when`(mockDocumentSnapshot.getDouble(\"Latitude\")).thenReturn(testUser.latitude)\n    `when`(mockDocumentSnapshot.getDouble(\"Longitude\")).thenReturn(testUser.longitude)\n    `when`(mockDocumentSnapshot.getString(\"Picture\")).thenReturn(testUser.profilePictureUrl)\n\n    // Act\n    val result = userFirestoreSource.documentToUser(mockDocumentSnapshot)\n\n    // Assert\n    assert(result.getOrNull() == null)\n    result.onFailure { Log.d(\"UserFirestoreSourceTest\", \"failure with message: ${it.message}\") }\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/source/network/UserFirestoreSourceTest.kt b/app/src/test/java/com/android/bookswap/data/source/network/UserFirestoreSourceTest.kt
--- a/app/src/test/java/com/android/bookswap/data/source/network/UserFirestoreSourceTest.kt	
+++ b/app/src/test/java/com/android/bookswap/data/source/network/UserFirestoreSourceTest.kt	
@@ -12,6 +12,7 @@
 import com.google.firebase.firestore.Query
 import com.google.firebase.firestore.QuerySnapshot
 import com.google.firebase.firestore.util.Assert.fail
+import java.util.UUID
 import org.junit.After
 import org.junit.Before
 import org.junit.Test
@@ -20,6 +21,7 @@
 import org.mockito.Mock
 import org.mockito.Mockito.`when`
 import org.mockito.MockitoAnnotations
+import org.mockito.kotlin.any
 import org.mockito.kotlin.doAnswer
 import org.mockito.kotlin.eq
 import org.mockito.kotlin.verify
@@ -39,6 +41,7 @@
 
   private val testUser =
       DataUser(
+          UUID.randomUUID(),
           "M.",
           "John",
           "Doe",
@@ -46,8 +49,7 @@
           "+41223456789",
           0.0,
           0.0,
-          "dummyPic.png",
-          "dummyUUID0000")
+          "dummyPic.png")
 
   @Before
   fun setUp() {
@@ -64,6 +66,23 @@
     `when`(mockCollectionReference.document(ArgumentMatchers.any()))
         .thenReturn(mockDocumentReference)
     `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
+
+    `when`(mockQuerySnapshot.documents).thenReturn(listOf(mockDocumentSnapshot))
+    `when`(mockDocumentSnapshot.getLong("userUUID.mostSignificantBits"))
+        .thenReturn(testUser.userUUID.mostSignificantBits)!!
+    `when`(mockDocumentSnapshot.getLong("userUUID.leastSignificantBits"))
+        .thenReturn(testUser.userUUID.leastSignificantBits)!!
+    `when`(mockDocumentSnapshot.getString("greeting")).thenReturn(testUser.greeting)
+    `when`(mockDocumentSnapshot.getString("firstName")).thenReturn(testUser.firstName)
+    `when`(mockDocumentSnapshot.getString("lastName")).thenReturn(testUser.lastName)
+    `when`(mockDocumentSnapshot.getString("email")).thenReturn(testUser.email)
+    `when`(mockDocumentSnapshot.getString("phoneNumber")).thenReturn(testUser.phoneNumber)
+    `when`(mockDocumentSnapshot.getDouble("latitude")).thenReturn(testUser.latitude)
+    `when`(mockDocumentSnapshot.getDouble("longitude")).thenReturn(testUser.longitude)
+    `when`(mockDocumentSnapshot.getString("profilePictureUrl"))
+        .thenReturn(testUser.profilePictureUrl)
+    `when`(mockDocumentSnapshot.get("bookList")).thenReturn(testUser.bookList)
+    `when`(mockDocumentSnapshot.getString("googleUid")).thenReturn(testUser.googleUid)
   }
 
   @After fun tearDown() {}
@@ -72,18 +91,6 @@
 
   @Test
   fun getUsers() {
-    // Arrange
-    `when`(mockQuerySnapshot.documents).thenReturn(listOf(mockDocumentSnapshot))
-    `when`(mockDocumentSnapshot.getString("UUID")).thenReturn(testUser.userId)
-    `when`(mockDocumentSnapshot.getString("Greeting")).thenReturn(testUser.greeting)
-    `when`(mockDocumentSnapshot.getString("Firstname")).thenReturn(testUser.firstName)
-    `when`(mockDocumentSnapshot.getString("Lastname")).thenReturn(testUser.lastName)
-    `when`(mockDocumentSnapshot.getString("Email")).thenReturn(testUser.email)
-    `when`(mockDocumentSnapshot.getString("Phone")).thenReturn(testUser.phoneNumber)
-    `when`(mockDocumentSnapshot.getDouble("Latitude")).thenReturn(testUser.latitude)
-    `when`(mockDocumentSnapshot.getDouble("Longitude")).thenReturn(testUser.longitude)
-    `when`(mockDocumentSnapshot.getString("Picture")).thenReturn(testUser.profilePictureUrl)
-
     // Act
     userFirestoreSource.getUsers { result ->
       result.fold(
@@ -102,32 +109,22 @@
   @Test
   fun getUser() {
     // Arrange
-    `when`(mockQuerySnapshot.documents).thenReturn(listOf(mockDocumentSnapshot))
-    `when`(mockCollectionReference.whereEqualTo(eq("UUID"), ArgumentMatchers.anyString()))
+    `when`(mockCollectionReference.whereEqualTo(eq("UUID"), ArgumentMatchers.any()))
         .thenReturn(mockQuery)
     `when`(mockQuery.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
-    `when`(mockDocumentSnapshot.getString("UUID")).thenReturn(testUser.userId)
-    `when`(mockDocumentSnapshot.getString("Greeting")).thenReturn(testUser.greeting)
-    `when`(mockDocumentSnapshot.getString("Firstname")).thenReturn(testUser.firstName)
-    `when`(mockDocumentSnapshot.getString("Lastname")).thenReturn(testUser.lastName)
-    `when`(mockDocumentSnapshot.getString("Email")).thenReturn(testUser.email)
-    `when`(mockDocumentSnapshot.getString("Phone")).thenReturn(testUser.phoneNumber)
-    `when`(mockDocumentSnapshot.getDouble("Latitude")).thenReturn(testUser.latitude)
-    `when`(mockDocumentSnapshot.getDouble("Longitude")).thenReturn(testUser.longitude)
-    `when`(mockDocumentSnapshot.getString("Picture")).thenReturn(testUser.profilePictureUrl)
 
     // Act
-    userFirestoreSource.getUser("dummyUUID0000") { result ->
+    userFirestoreSource.getUser(testUser.userUUID) { result ->
       result.fold(
           {
-            // Assert proper data transfert
+            // Assert proper data transfer
             assert(it.printFullname() == testUser.printFullname())
           },
           { fail("Should not fail!") })
     }
 
     // Verify Firestore collection was accessed
-    verify(mockCollectionReference).whereEqualTo(eq("UUID"), ArgumentMatchers.anyString())
+    verify(mockCollectionReference).whereEqualTo(eq("UUID"), any())
   }
 
   @Test
@@ -164,7 +161,7 @@
     doAnswer { Tasks.forResult(null) }.`when`(mockDocumentReference).delete()
 
     // Act
-    userFirestoreSource.deleteUser(testUser.userId) { result ->
+    userFirestoreSource.deleteUser(testUser.userUUID) { result ->
       result.fold({ assert(true) }, { fail("Should not fail!") })
     }
 
@@ -174,17 +171,6 @@
 
   @Test
   fun documentToUser_validDoc() {
-    // Arrange
-    `when`(mockDocumentSnapshot.getString("UUID")).thenReturn(testUser.userId)
-    `when`(mockDocumentSnapshot.getString("Greeting")).thenReturn(testUser.greeting)
-    `when`(mockDocumentSnapshot.getString("Firstname")).thenReturn(testUser.firstName)
-    `when`(mockDocumentSnapshot.getString("Lastname")).thenReturn(testUser.lastName)
-    `when`(mockDocumentSnapshot.getString("Email")).thenReturn(testUser.email)
-    `when`(mockDocumentSnapshot.getString("Phone")).thenReturn(testUser.phoneNumber)
-    `when`(mockDocumentSnapshot.getDouble("Latitude")).thenReturn(testUser.latitude)
-    `when`(mockDocumentSnapshot.getDouble("Longitude")).thenReturn(testUser.longitude)
-    `when`(mockDocumentSnapshot.getString("Picture")).thenReturn(testUser.profilePictureUrl)
-
     // Act
     val result = userFirestoreSource.documentToUser(mockDocumentSnapshot)
 
@@ -195,16 +181,7 @@
 
   @Test
   fun documentToUser_invalidDoc() {
-    // Arrange
-    `when`(mockDocumentSnapshot.getString("UUID")).thenReturn(testUser.userId)
-    `when`(mockDocumentSnapshot.getString("Greeting")).thenReturn(null)
-    `when`(mockDocumentSnapshot.getString("Firstname")).thenReturn(testUser.firstName)
-    `when`(mockDocumentSnapshot.getString("Lastname")).thenReturn(testUser.lastName)
-    `when`(mockDocumentSnapshot.getString("Email")).thenReturn(testUser.email)
-    `when`(mockDocumentSnapshot.getString("Phone")).thenReturn(testUser.phoneNumber)
-    `when`(mockDocumentSnapshot.getDouble("Latitude")).thenReturn(testUser.latitude)
-    `when`(mockDocumentSnapshot.getDouble("Longitude")).thenReturn(testUser.longitude)
-    `when`(mockDocumentSnapshot.getString("Picture")).thenReturn(testUser.profilePictureUrl)
+    `when`(mockDocumentSnapshot.getString("greeting")).thenReturn(null)
 
     // Act
     val result = userFirestoreSource.documentToUser(mockDocumentSnapshot)
Index: app/src/test/java/com/android/bookswap/model/chat/DataMessageFirestoreSourceTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.model.chat\n\nimport android.content.Context\nimport android.os.Looper\nimport androidx.test.core.app.ApplicationProvider\nimport com.android.bookswap.data.DataMessage\nimport com.android.bookswap.data.source.network.COLLECTION_PATH\nimport com.android.bookswap.data.source.network.MessageFirestoreSource\nimport com.android.bookswap.data.source.network.documentToMessage\nimport com.google.android.gms.tasks.Tasks\nimport com.google.firebase.FirebaseApp\nimport com.google.firebase.firestore.CollectionReference\nimport com.google.firebase.firestore.DocumentReference\nimport com.google.firebase.firestore.DocumentSnapshot\nimport com.google.firebase.firestore.FirebaseFirestore\nimport com.google.firebase.firestore.QuerySnapshot\nimport com.google.firebase.firestore.WriteBatch\nimport org.junit.Assert.assertEquals\nimport org.junit.Assert.assertTrue\nimport org.junit.Before\nimport org.junit.Test\nimport org.junit.runner.RunWith\nimport org.mockito.ArgumentMatchers\nimport org.mockito.ArgumentMatchers.anyMap\nimport org.mockito.Mock\nimport org.mockito.Mockito.mock\nimport org.mockito.Mockito.never\nimport org.mockito.Mockito.`when`\nimport org.mockito.MockitoAnnotations\nimport org.mockito.kotlin.argThat\nimport org.mockito.kotlin.doAnswer\nimport org.mockito.kotlin.verify\nimport org.robolectric.RobolectricTestRunner\nimport org.robolectric.Shadows.shadowOf\n\n@RunWith(RobolectricTestRunner::class)\nclass DataMessageFirestoreSourceTest {\n\n  @Mock private lateinit var mockFirestore: FirebaseFirestore\n  @Mock private lateinit var mockCollectionReference: CollectionReference\n  @Mock private lateinit var mockDocumentReference: DocumentReference\n  @Mock private lateinit var mockDocumentSnapshot: DocumentSnapshot\n  @Mock private lateinit var mockQuerySnapshot: QuerySnapshot\n\n  private val testMessage =\n      DataMessage(\n          id = \"message-id\",\n          text = \"Hello, World!\",\n          senderId = \"user-id\",\n          receiverId = \"receiver-id\",\n          timestamp = System.currentTimeMillis())\n\n  private lateinit var messageRepository: MessageFirestoreSource\n\n  @Before\n  fun setUp() {\n    MockitoAnnotations.openMocks(this)\n\n    if (FirebaseApp.getApps(ApplicationProvider.getApplicationContext()).isEmpty()) {\n      FirebaseApp.initializeApp(ApplicationProvider.getApplicationContext())\n    }\n\n    messageRepository = MessageFirestoreSource(mockFirestore)\n\n    `when`(mockFirestore.collection(ArgumentMatchers.anyString()))\n        .thenReturn(mockCollectionReference)\n    `when`(mockCollectionReference.document(ArgumentMatchers.anyString()))\n        .thenReturn(mockDocumentReference)\n    `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))\n  }\n\n  @Test\n  fun `test getNewUid returns valid document id`() {\n    val expectedUid = \"randomGeneratedUid\"\n    `when`(mockFirestore.collection(ArgumentMatchers.anyString()))\n        .thenReturn(mockCollectionReference)\n    `when`(mockCollectionReference.document()).thenReturn(mockDocumentReference)\n    `when`(mockDocumentReference.id).thenReturn(expectedUid)\n\n    val newUid = messageRepository.getNewUid()\n\n    assert(newUid == expectedUid)\n  }\n\n  @Test\n  fun `test init calls onSuccess`() {\n    val callback = mock<(Result<Unit>) -> Unit>()\n    messageRepository.init(callback)\n    verify(callback).invoke(Result.success(Unit))\n  }\n\n  @Test\n  fun `test init calls onFailure when initialization fails`() {\n    val callback = mock<(Result<Unit>) -> Unit>()\n    val exceptionMessage = \"Initialization failed\"\n    val exception = RuntimeException(exceptionMessage)\n    messageRepository.init { callback(Result.failure(exception)) }\n    verify(callback).invoke(argThat { isFailure && exceptionOrNull()?.message == exceptionMessage })\n  }\n\n  @Test\n  fun `getMessages calls onSuccess`() {\n    // Arrange\n    val callback = mock<(Result<List<DataMessage>>) -> Unit>()\n    val messages = listOf(testMessage)\n\n    // Ensure the documents list is not null\n    `when`(mockQuerySnapshot.documents).thenReturn(messages.map { mockDocumentSnapshot })\n\n    // Mock the document snapshot fields\n    `when`(mockDocumentSnapshot.getString(\"id\")).thenReturn(testMessage.id)\n    `when`(mockDocumentSnapshot.getString(\"text\")).thenReturn(testMessage.text)\n    `when`(mockDocumentSnapshot.getString(\"senderId\")).thenReturn(testMessage.senderId)\n    `when`(mockDocumentSnapshot.getString(\"receiverId\")).thenReturn(testMessage.receiverId)\n    `when`(mockDocumentSnapshot.getLong(\"timestamp\")).thenReturn(testMessage.timestamp)\n\n    // Act\n    messageRepository.getMessages(callback)\n    shadowOf(Looper.getMainLooper()).idle()\n\n    // Assert\n    verify(callback).invoke(argThat { isSuccess && getOrNull() == messages })\n    verify(mockCollectionReference).get()\n  }\n\n  @Test\n  fun `getMessages calls onFailure when Firestore query fails`() {\n    val callback = mock<(Result<List<DataMessage>>) -> Unit>()\n    val exception = RuntimeException(\"Firestore query failed\")\n    `when`(mockCollectionReference.get()).thenReturn(Tasks.forException(exception))\n    messageRepository.getMessages(callback)\n    shadowOf(Looper.getMainLooper()).idle()\n    verify(callback).invoke(argThat { isFailure && exceptionOrNull() == exception })\n  }\n\n  @Test\n  fun `get messages returns empty list when no messages exist`() {\n    `when`(mockQuerySnapshot.documents).thenReturn(emptyList())\n\n    messageRepository.getMessages { result ->\n      assertTrue(result.isSuccess)\n      assertTrue(result.getOrNull()!!.isEmpty())\n    }\n\n    verify(mockCollectionReference).get()\n  }\n\n  @Test\n  fun `get messages handles firestore failure`() {\n    val exception = Exception(\"Firestore get error\")\n    `when`(mockCollectionReference.get()).thenReturn(Tasks.forException(exception))\n\n    messageRepository.getMessages { result ->\n      assertTrue(result.isFailure)\n      assertEquals(exception, result.exceptionOrNull())\n    }\n\n    verify(mockCollectionReference).get()\n  }\n\n  @Test\n  fun `get messages calls firestore get`() {\n    // Arrange\n    `when`(mockQuerySnapshot.documents).thenReturn(listOf(mockDocumentSnapshot))\n    `when`(mockDocumentSnapshot.getString(\"id\")).thenReturn(testMessage.id)\n    `when`(mockDocumentSnapshot.getString(\"text\")).thenReturn(testMessage.text)\n    `when`(mockDocumentSnapshot.getString(\"senderId\")).thenReturn(testMessage.senderId)\n    `when`(mockDocumentSnapshot.getString(\"receiverId\")).thenReturn(testMessage.receiverId)\n    `when`(mockDocumentSnapshot.getLong(\"timestamp\")).thenReturn(testMessage.timestamp)\n\n    // Act\n    messageRepository.getMessages() {\n      assertTrue(it.isSuccess)\n      assertTrue(it.getOrNull()!!.isNotEmpty())\n      assertEquals(testMessage.id, it.getOrNull()?.first()?.id)\n    }\n\n    // Verify Firestore collection was called\n    verify(mockCollectionReference).get()\n  }\n\n  @Test\n  fun `send message calls firestore set and calls OnSuccess`() {\n    // Arrange\n    val messageMap =\n        mapOf(\n            \"id\" to testMessage.id,\n            \"text\" to testMessage.text,\n            \"senderId\" to testMessage.senderId,\n            \"receiverId\" to testMessage.receiverId,\n            \"timestamp\" to testMessage.timestamp)\n\n    doAnswer { Tasks.forResult(null) }.`when`(mockDocumentReference).set(messageMap)\n\n    // Act\n    messageRepository.sendMessage(testMessage) { assertTrue(it.isSuccess) }\n\n    // Verify Firestore set operation\n    verify(mockDocumentReference).set(messageMap)\n  }\n\n  @Test\n  fun `send message handles firestore set failure`() {\n    val exception = Exception(\"Firestore set error\")\n    val messageMap =\n        mapOf(\n            \"id\" to testMessage.id,\n            \"text\" to testMessage.text,\n            \"senderId\" to testMessage.senderId,\n            \"receiverId\" to testMessage.receiverId,\n            \"timestamp\" to testMessage.timestamp)\n\n    `when`(mockDocumentReference.set(messageMap)).thenReturn(Tasks.forException(exception))\n\n    messageRepository.sendMessage(testMessage) { result ->\n      assertTrue(result.isFailure)\n      assertEquals(exception, result.exceptionOrNull())\n    }\n\n    verify(mockDocumentReference).set(messageMap)\n  }\n\n  @Test\n  fun `documentToMessage fails when document is missing fields`() {\n    `when`(mockDocumentSnapshot.getString(\"id\")).thenReturn(null) // Simulate missing \"id\" field\n    `when`(mockDocumentSnapshot.getString(\"text\")).thenReturn(testMessage.text)\n    `when`(mockDocumentSnapshot.getString(\"senderId\")).thenReturn(testMessage.senderId)\n    `when`(mockDocumentSnapshot.getString(\"receiverId\")).thenReturn(testMessage.receiverId)\n    `when`(mockDocumentSnapshot.getLong(\"timestamp\")).thenReturn(testMessage.timestamp)\n\n    val result = documentToMessage(mockDocumentSnapshot)\n\n    assertTrue(result.isFailure)\n    assertTrue(result.exceptionOrNull() is NullPointerException)\n  }\n\n  @Test\n  fun `documentToMessage converts DocumentSnapshot to DataMessage`() {\n    `when`(mockDocumentSnapshot.getString(\"id\")).thenReturn(testMessage.id)\n    `when`(mockDocumentSnapshot.getString(\"text\")).thenReturn(testMessage.text)\n    `when`(mockDocumentSnapshot.getString(\"senderId\")).thenReturn(testMessage.senderId)\n    `when`(mockDocumentSnapshot.getString(\"receiverId\")).thenReturn(testMessage.receiverId)\n    `when`(mockDocumentSnapshot.getLong(\"timestamp\")).thenReturn(testMessage.timestamp)\n\n    val result = documentToMessage(mockDocumentSnapshot)\n\n    assertTrue(result.isSuccess)\n    assertEquals(testMessage, result.getOrNull())\n  }\n\n  @Test\n  fun `delete message fails for messages older than 15 minutes`() {\n    val context = mock<Context>()\n    val oldMessage = testMessage.copy(timestamp = System.currentTimeMillis() - (16 * 60 * 1000))\n\n    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))\n    `when`(mockDocumentSnapshot.exists()).thenReturn(true)\n    `when`(mockDocumentSnapshot.getString(\"id\")).thenReturn(oldMessage.id)\n    `when`(mockDocumentSnapshot.getLong(\"timestamp\")).thenReturn(oldMessage.timestamp)\n\n    // Act\n    messageRepository.deleteMessage(\n        oldMessage.id,\n        { result ->\n          assertTrue(result.isFailure)\n          assertEquals(\n              \"Message can only be deleted within 15 minutes of being sent\",\n              result.exceptionOrNull()?.message)\n        },\n        context)\n\n    // Verify Firestore delete was not called\n    verify(mockDocumentReference, never()).delete()\n  }\n\n  @Test\n  fun `delete message fails when message does not exist`() {\n    val context = mock<Context>()\n    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))\n    `when`(mockDocumentSnapshot.exists()).thenReturn(false) // Simulate nonexistent document\n\n    messageRepository.deleteMessage(\n        testMessage.id,\n        { result ->\n          assertTrue(result.isFailure)\n          assertEquals(\"Message not found\", result.exceptionOrNull()?.message)\n        },\n        context)\n\n    // Verify delete was not called\n    verify(mockDocumentReference, never()).delete()\n  }\n\n  @Test\n  fun `update message fails for messages older than 15 minutes`() {\n    val context = mock<Context>()\n    val oldMessage = testMessage.copy(timestamp = System.currentTimeMillis() - (16 * 60 * 1000))\n\n    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))\n    `when`(mockDocumentSnapshot.exists()).thenReturn(true)\n    `when`(mockDocumentSnapshot.getString(\"id\")).thenReturn(oldMessage.id)\n    `when`(mockDocumentSnapshot.getLong(\"timestamp\")).thenReturn(oldMessage.timestamp)\n\n    messageRepository.updateMessage(\n        oldMessage,\n        { result ->\n          assertTrue(result.isFailure)\n          assertEquals(\n              \"Message can only be updated within 15 minutes of being sent\",\n              result.exceptionOrNull()?.message)\n        },\n        context)\n\n    // Verify Firestore update was not called\n    verify(mockDocumentReference, never()).update(anyMap())\n  }\n\n  @Test\n  fun `update message fails when message does not exist`() {\n    val context = mock<Context>()\n    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))\n    `when`(mockDocumentSnapshot.exists()).thenReturn(false) // Simulate nonexistent document\n\n    messageRepository.updateMessage(\n        testMessage,\n        { result ->\n          assertTrue(result.isFailure)\n          assertEquals(\"Message not found\", result.exceptionOrNull()?.message)\n        },\n        context)\n\n    // Verify update was not called\n    verify(mockDocumentReference, never()).update(anyMap())\n  }\n\n  @Test\n  fun `delete all messages between two users deletes documents`() {\n    // Arrange\n    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)\n    `when`(mockCollectionReference.whereIn(\"senderId\", listOf(\"user1\", \"user2\")))\n        .thenReturn(mockCollectionReference)\n    `when`(mockCollectionReference.whereIn(\"receiverId\", listOf(\"user1\", \"user2\")))\n        .thenReturn(mockCollectionReference)\n    `when`(mockCollectionReference.whereNotEqualTo(\"senderId\", \"receiverId\"))\n        .thenReturn(mockCollectionReference)\n\n    // Mock retrieval of a query snapshot with one document to delete\n    `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))\n    `when`(mockQuerySnapshot.documents).thenReturn(listOf(mockDocumentSnapshot))\n    `when`(mockDocumentSnapshot.reference).thenReturn(mockDocumentReference)\n\n    // Mock the Firestore batch process\n    val mockBatch = mock<WriteBatch>()\n    `when`(mockFirestore.batch()).thenReturn(mockBatch)\n    `when`(mockBatch.delete(mockDocumentReference)).thenReturn(mockBatch)\n    `when`(mockBatch.commit()).thenReturn(Tasks.forResult(null)) // Simulate successful commit\n\n    // Act\n    messageRepository.deleteAllMessages(\"user1\", \"user2\") { result ->\n      // Assert that the delete operation was successful\n      assertTrue(result.isSuccess)\n    }\n\n    // Ensure that any pending tasks are executed\n    shadowOf(Looper.getMainLooper()).idle()\n\n    // Verify interactions\n    verify(mockCollectionReference).get() // Verify retrieval call\n    verify(mockBatch).delete(mockDocumentReference) // Verify deletion call\n    verify(mockBatch).commit() // Verify batch commit call\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/model/chat/DataMessageFirestoreSourceTest.kt b/app/src/test/java/com/android/bookswap/model/chat/DataMessageFirestoreSourceTest.kt
--- a/app/src/test/java/com/android/bookswap/model/chat/DataMessageFirestoreSourceTest.kt	
+++ b/app/src/test/java/com/android/bookswap/model/chat/DataMessageFirestoreSourceTest.kt	
@@ -4,6 +4,7 @@
 import android.os.Looper
 import androidx.test.core.app.ApplicationProvider
 import com.android.bookswap.data.DataMessage
+import com.android.bookswap.data.MessageType
 import com.android.bookswap.data.source.network.COLLECTION_PATH
 import com.android.bookswap.data.source.network.MessageFirestoreSource
 import com.android.bookswap.data.source.network.documentToMessage
@@ -13,23 +14,19 @@
 import com.google.firebase.firestore.DocumentReference
 import com.google.firebase.firestore.DocumentSnapshot
 import com.google.firebase.firestore.FirebaseFirestore
+import com.google.firebase.firestore.FirebaseFirestoreSettings
 import com.google.firebase.firestore.QuerySnapshot
 import com.google.firebase.firestore.WriteBatch
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertTrue
+import java.util.UUID
 import org.junit.Before
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.mockito.ArgumentMatchers
-import org.mockito.ArgumentMatchers.anyMap
 import org.mockito.Mock
 import org.mockito.Mockito.mock
-import org.mockito.Mockito.never
+import org.mockito.Mockito.verify
 import org.mockito.Mockito.`when`
 import org.mockito.MockitoAnnotations
-import org.mockito.kotlin.argThat
-import org.mockito.kotlin.doAnswer
-import org.mockito.kotlin.verify
 import org.robolectric.RobolectricTestRunner
 import org.robolectric.Shadows.shadowOf
 
@@ -41,26 +38,37 @@
   @Mock private lateinit var mockDocumentReference: DocumentReference
   @Mock private lateinit var mockDocumentSnapshot: DocumentSnapshot
   @Mock private lateinit var mockQuerySnapshot: QuerySnapshot
+  @Mock private lateinit var mockContext: Context
+
+  private lateinit var firestore: FirebaseFirestore
+  private lateinit var messageRepository: MessageFirestoreSource
+  private lateinit var messageFirestoreSource: MessageFirestoreSource
 
   private val testMessage =
       DataMessage(
-          id = "message-id",
-          text = "Hello, World!",
-          senderId = "user-id",
-          receiverId = "receiver-id",
+          messageType = MessageType.TEXT,
+          uuid = UUID.randomUUID(),
+          text = "Test message",
+          senderUUID = UUID.randomUUID(),
+          receiverUUID = UUID.randomUUID(),
           timestamp = System.currentTimeMillis())
 
-  private lateinit var messageRepository: MessageFirestoreSource
-
   @Before
   fun setUp() {
     MockitoAnnotations.openMocks(this)
 
+    // Initialize Firebase if necessary
     if (FirebaseApp.getApps(ApplicationProvider.getApplicationContext()).isEmpty()) {
       FirebaseApp.initializeApp(ApplicationProvider.getApplicationContext())
     }
 
-    messageRepository = MessageFirestoreSource(mockFirestore)
+    firestore = FirebaseFirestore.getInstance()
+    firestore.useEmulator("localhost", 8080)
+    firestore.firestoreSettings =
+        FirebaseFirestoreSettings.Builder().setPersistenceEnabled(false).build()
+
+    messageFirestoreSource = MessageFirestoreSource(mockFirestore)
+    messageRepository = MessageFirestoreSource(firestore)
 
     `when`(mockFirestore.collection(ArgumentMatchers.anyString()))
         .thenReturn(mockCollectionReference)
@@ -69,304 +77,514 @@
     `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
   }
 
+  // Init Tests
   @Test
-  fun `test getNewUid returns valid document id`() {
-    val expectedUid = "randomGeneratedUid"
-    `when`(mockFirestore.collection(ArgumentMatchers.anyString()))
-        .thenReturn(mockCollectionReference)
-    `when`(mockCollectionReference.document()).thenReturn(mockDocumentReference)
-    `when`(mockDocumentReference.id).thenReturn(expectedUid)
-
-    val newUid = messageRepository.getNewUid()
-
-    assert(newUid == expectedUid)
+  fun init_invokesCallbackOnSuccess() {
+    messageFirestoreSource.init { result -> assert(result.isSuccess) }
   }
 
+  // GetMessages Tests
   @Test
-  fun `test init calls onSuccess`() {
-    val callback = mock<(Result<Unit>) -> Unit>()
-    messageRepository.init(callback)
-    verify(callback).invoke(Result.success(Unit))
-  }
-
-  @Test
-  fun `test init calls onFailure when initialization fails`() {
-    val callback = mock<(Result<Unit>) -> Unit>()
-    val exceptionMessage = "Initialization failed"
-    val exception = RuntimeException(exceptionMessage)
-    messageRepository.init { callback(Result.failure(exception)) }
-    verify(callback).invoke(argThat { isFailure && exceptionOrNull()?.message == exceptionMessage })
-  }
-
-  @Test
-  fun `getMessages calls onSuccess`() {
+  fun getMessages_returnsMessagesOnSuccess() {
     // Arrange
-    val callback = mock<(Result<List<DataMessage>>) -> Unit>()
-    val messages = listOf(testMessage)
-
-    // Ensure the documents list is not null
-    `when`(mockQuerySnapshot.documents).thenReturn(messages.map { mockDocumentSnapshot })
-
-    // Mock the document snapshot fields
-    `when`(mockDocumentSnapshot.getString("id")).thenReturn(testMessage.id)
-    `when`(mockDocumentSnapshot.getString("text")).thenReturn(testMessage.text)
-    `when`(mockDocumentSnapshot.getString("senderId")).thenReturn(testMessage.senderId)
-    `when`(mockDocumentSnapshot.getString("receiverId")).thenReturn(testMessage.receiverId)
-    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(testMessage.timestamp)
+    val documents = listOf(mockDocumentSnapshot)
+    val expectedMessage = testMessage
+    `when`(mockQuerySnapshot.documents).thenReturn(documents)
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(expectedMessage.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("text")).thenReturn(expectedMessage.text)
+    `when`(mockDocumentSnapshot.getString("senderUUID"))
+        .thenReturn(expectedMessage.senderUUID.toString())
+    `when`(mockDocumentSnapshot.getString("receiverUUID"))
+        .thenReturn(expectedMessage.receiverUUID.toString())
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(expectedMessage.timestamp)
 
     // Act
-    messageRepository.getMessages(callback)
-    shadowOf(Looper.getMainLooper()).idle()
-
-    // Assert
-    verify(callback).invoke(argThat { isSuccess && getOrNull() == messages })
-    verify(mockCollectionReference).get()
+    messageFirestoreSource.getMessages { result ->
+      // Assert
+      assert(result.isSuccess)
+      val messages = result.getOrNull()
+      assert(messages?.size == 1)
+      assert(messages?.first() == expectedMessage)
+    }
   }
 
   @Test
-  fun `getMessages calls onFailure when Firestore query fails`() {
-    val callback = mock<(Result<List<DataMessage>>) -> Unit>()
-    val exception = RuntimeException("Firestore query failed")
+  fun getMessages_returnsFailureOnException() {
+    val exception = RuntimeException("Firestore error")
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
     `when`(mockCollectionReference.get()).thenReturn(Tasks.forException(exception))
-    messageRepository.getMessages(callback)
-    shadowOf(Looper.getMainLooper()).idle()
-    verify(callback).invoke(argThat { isFailure && exceptionOrNull() == exception })
+
+    messageFirestoreSource.getMessages { result ->
+      assert(result.isFailure)
+      assert(result.exceptionOrNull() == exception)
+    }
   }
 
   @Test
-  fun `get messages returns empty list when no messages exist`() {
+  fun getMessages_returnsEmptyListOnEmptyResult() {
     `when`(mockQuerySnapshot.documents).thenReturn(emptyList())
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
 
-    messageRepository.getMessages { result ->
-      assertTrue(result.isSuccess)
-      assertTrue(result.getOrNull()!!.isEmpty())
+    messageFirestoreSource.getMessages { result ->
+      assert(result.isSuccess)
+      val messages = result.getOrNull()
+      assert(messages?.isEmpty() == true)
     }
-
-    verify(mockCollectionReference).get()
   }
 
+  // SendMessage Tests
   @Test
-  fun `get messages handles firestore failure`() {
-    val exception = Exception("Firestore get error")
-    `when`(mockCollectionReference.get()).thenReturn(Tasks.forException(exception))
-
-    messageRepository.getMessages { result ->
-      assertTrue(result.isFailure)
-      assertEquals(exception, result.exceptionOrNull())
-    }
-
-    verify(mockCollectionReference).get()
-  }
-
-  @Test
-  fun `get messages calls firestore get`() {
-    // Arrange
-    `when`(mockQuerySnapshot.documents).thenReturn(listOf(mockDocumentSnapshot))
-    `when`(mockDocumentSnapshot.getString("id")).thenReturn(testMessage.id)
-    `when`(mockDocumentSnapshot.getString("text")).thenReturn(testMessage.text)
-    `when`(mockDocumentSnapshot.getString("senderId")).thenReturn(testMessage.senderId)
-    `when`(mockDocumentSnapshot.getString("receiverId")).thenReturn(testMessage.receiverId)
-    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(testMessage.timestamp)
-
-    // Act
-    messageRepository.getMessages() {
-      assertTrue(it.isSuccess)
-      assertTrue(it.getOrNull()!!.isNotEmpty())
-      assertEquals(testMessage.id, it.getOrNull()?.first()?.id)
-    }
-
-    // Verify Firestore collection was called
-    verify(mockCollectionReference).get()
-  }
-
-  @Test
-  fun `send message calls firestore set and calls OnSuccess`() {
-    // Arrange
+  fun sendMessage_callsFirestoreSet_onSuccess() {
     val messageMap =
         mapOf(
-            "id" to testMessage.id,
+            "uuid" to testMessage.uuid.toString(),
             "text" to testMessage.text,
-            "senderId" to testMessage.senderId,
-            "receiverId" to testMessage.receiverId,
-            "timestamp" to testMessage.timestamp)
+            "senderUUID" to testMessage.senderUUID.toString(),
+            "receiverUUID" to testMessage.receiverUUID.toString(),
+            "timestamp" to testMessage.timestamp,
+            "messageType" to testMessage.messageType.name)
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(testMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.set(messageMap)).thenReturn(Tasks.forResult(null))
 
-    doAnswer { Tasks.forResult(null) }.`when`(mockDocumentReference).set(messageMap)
+    messageFirestoreSource.sendMessage(testMessage) { result -> assert(result.isSuccess) }
 
-    // Act
-    messageRepository.sendMessage(testMessage) { assertTrue(it.isSuccess) }
-
-    // Verify Firestore set operation
     verify(mockDocumentReference).set(messageMap)
   }
 
   @Test
-  fun `send message handles firestore set failure`() {
-    val exception = Exception("Firestore set error")
+  fun sendMessage_callsFirestoreSet_onFailure() {
+    val exception = RuntimeException("Firestore error")
     val messageMap =
         mapOf(
-            "id" to testMessage.id,
+            "uuid" to testMessage.uuid.toString(),
             "text" to testMessage.text,
-            "senderId" to testMessage.senderId,
-            "receiverId" to testMessage.receiverId,
-            "timestamp" to testMessage.timestamp)
-
+            "senderUUID" to testMessage.senderUUID.toString(),
+            "receiverUUID" to testMessage.receiverUUID.toString(),
+            "timestamp" to testMessage.timestamp,
+            "messageType" to testMessage.messageType.name)
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(testMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
     `when`(mockDocumentReference.set(messageMap)).thenReturn(Tasks.forException(exception))
 
-    messageRepository.sendMessage(testMessage) { result ->
-      assertTrue(result.isFailure)
-      assertEquals(exception, result.exceptionOrNull())
+    messageFirestoreSource.sendMessage(testMessage) { result ->
+      assert(result.isFailure)
+      assert(result.exceptionOrNull() == exception)
     }
-
-    verify(mockDocumentReference).set(messageMap)
   }
 
+  // DeleteMessage Tests
   @Test
-  fun `documentToMessage fails when document is missing fields`() {
-    `when`(mockDocumentSnapshot.getString("id")).thenReturn(null) // Simulate missing "id" field
-    `when`(mockDocumentSnapshot.getString("text")).thenReturn(testMessage.text)
-    `when`(mockDocumentSnapshot.getString("senderId")).thenReturn(testMessage.senderId)
-    `when`(mockDocumentSnapshot.getString("receiverId")).thenReturn(testMessage.receiverId)
-    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(testMessage.timestamp)
+  fun deleteMessage_deletesMessageOnSuccess() {
+    val fifteenMinutesInMillis = 15 * 60 * 1000
+    val recentMessage =
+        testMessage.copy(timestamp = System.currentTimeMillis() - (fifteenMinutesInMillis - 1000))
+
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(recentMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
+    `when`(mockDocumentSnapshot.exists()).thenReturn(true) // Ensure document exists
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(recentMessage.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("text")).thenReturn(recentMessage.text)
+    `when`(mockDocumentSnapshot.getString("senderUUID"))
+        .thenReturn(recentMessage.senderUUID.toString())
+    `when`(mockDocumentSnapshot.getString("receiverUUID"))
+        .thenReturn(recentMessage.receiverUUID.toString())
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(recentMessage.timestamp)
+    `when`(mockDocumentSnapshot.getString("messageType")).thenReturn(recentMessage.messageType.name)
+    `when`(mockDocumentReference.delete()).thenReturn(Tasks.forResult(null))
 
-    val result = documentToMessage(mockDocumentSnapshot)
+    messageFirestoreSource.deleteMessage(
+        recentMessage.uuid, { result -> assert(result.isSuccess) }, mockContext)
 
-    assertTrue(result.isFailure)
-    assertTrue(result.exceptionOrNull() is NullPointerException)
+    shadowOf(Looper.getMainLooper()).idle()
+
+    verify(mockDocumentReference).delete()
   }
 
   @Test
-  fun `documentToMessage converts DocumentSnapshot to DataMessage`() {
-    `when`(mockDocumentSnapshot.getString("id")).thenReturn(testMessage.id)
-    `when`(mockDocumentSnapshot.getString("text")).thenReturn(testMessage.text)
-    `when`(mockDocumentSnapshot.getString("senderId")).thenReturn(testMessage.senderId)
-    `when`(mockDocumentSnapshot.getString("receiverId")).thenReturn(testMessage.receiverId)
-    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(testMessage.timestamp)
+  fun deleteMessage_failsWhenMessageNotFound() {
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(testMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
+    `when`(mockDocumentSnapshot.exists()).thenReturn(false) // Message does not exist
 
-    val result = documentToMessage(mockDocumentSnapshot)
-
-    assertTrue(result.isSuccess)
-    assertEquals(testMessage, result.getOrNull())
+    messageFirestoreSource.deleteMessage(
+        testMessage.uuid,
+        { result ->
+          assert(result.isFailure)
+          assert(result.exceptionOrNull()?.message == "Message not found")
+        },
+        mockContext)
   }
 
   @Test
-  fun `delete message fails for messages older than 15 minutes`() {
-    val context = mock<Context>()
-    val oldMessage = testMessage.copy(timestamp = System.currentTimeMillis() - (16 * 60 * 1000))
-
+  fun deleteMessage_failsWhenMessageTooOld() {
+    val oldMessage =
+        testMessage.copy(
+            timestamp =
+                System.currentTimeMillis() -
+                    (15 * 60 * 1000 + 1000)) // Sent more than 15 minutes ago
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(oldMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
     `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
     `when`(mockDocumentSnapshot.exists()).thenReturn(true)
-    `when`(mockDocumentSnapshot.getString("id")).thenReturn(oldMessage.id)
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(oldMessage.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("text")).thenReturn(oldMessage.text)
+    `when`(mockDocumentSnapshot.getString("senderUUID"))
+        .thenReturn(oldMessage.senderUUID.toString())
+    `when`(mockDocumentSnapshot.getString("receiverUUID"))
+        .thenReturn(oldMessage.receiverUUID.toString())
     `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(oldMessage.timestamp)
 
-    // Act
-    messageRepository.deleteMessage(
-        oldMessage.id,
+    messageFirestoreSource.deleteMessage(
+        oldMessage.uuid,
         { result ->
-          assertTrue(result.isFailure)
-          assertEquals(
-              "Message can only be deleted within 15 minutes of being sent",
-              result.exceptionOrNull()?.message)
+          assert(result.isFailure)
+          assert(
+              result.exceptionOrNull()?.message ==
+                  "Message can only be deleted within 15 minutes of being sent")
         },
-        context)
-
-    // Verify Firestore delete was not called
-    verify(mockDocumentReference, never()).delete()
+        mockContext)
   }
 
   @Test
-  fun `delete message fails when message does not exist`() {
-    val context = mock<Context>()
-    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
-    `when`(mockDocumentSnapshot.exists()).thenReturn(false) // Simulate nonexistent document
+  fun deleteMessage_failsOnFirestoreRetrievalError() {
+    val exception = RuntimeException("Firestore retrieval error")
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(testMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forException(exception))
 
-    messageRepository.deleteMessage(
-        testMessage.id,
+    messageFirestoreSource.deleteMessage(
+        testMessage.uuid,
         { result ->
-          assertTrue(result.isFailure)
-          assertEquals("Message not found", result.exceptionOrNull()?.message)
+          assert(result.isFailure)
+          assert(result.exceptionOrNull() == exception)
         },
-        context)
-
-    // Verify delete was not called
-    verify(mockDocumentReference, never()).delete()
+        mockContext)
   }
 
   @Test
-  fun `update message fails for messages older than 15 minutes`() {
-    val context = mock<Context>()
-    val oldMessage = testMessage.copy(timestamp = System.currentTimeMillis() - (16 * 60 * 1000))
-
+  fun deleteMessage_failsOnFirestoreDeleteError() {
+    val exception = RuntimeException("Firestore delete error")
+    val recentMessage =
+        testMessage.copy(
+            timestamp =
+                System.currentTimeMillis() - (15 * 60 * 1000 - 1000)) // Sent within 15 minutes
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(recentMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
     `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
     `when`(mockDocumentSnapshot.exists()).thenReturn(true)
-    `when`(mockDocumentSnapshot.getString("id")).thenReturn(oldMessage.id)
-    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(oldMessage.timestamp)
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(recentMessage.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("text")).thenReturn(recentMessage.text)
+    `when`(mockDocumentSnapshot.getString("senderUUID"))
+        .thenReturn(recentMessage.senderUUID.toString())
+    `when`(mockDocumentSnapshot.getString("receiverUUID"))
+        .thenReturn(recentMessage.receiverUUID.toString())
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(recentMessage.timestamp)
+    `when`(mockDocumentReference.delete()).thenReturn(Tasks.forException(exception))
 
-    messageRepository.updateMessage(
-        oldMessage,
+    messageFirestoreSource.deleteMessage(
+        recentMessage.uuid,
         { result ->
-          assertTrue(result.isFailure)
-          assertEquals(
-              "Message can only be updated within 15 minutes of being sent",
-              result.exceptionOrNull()?.message)
+          assert(result.isFailure)
+          assert(result.exceptionOrNull() == exception)
         },
-        context)
-
-    // Verify Firestore update was not called
-    verify(mockDocumentReference, never()).update(anyMap())
+        mockContext)
   }
 
   @Test
-  fun `update message fails when message does not exist`() {
-    val context = mock<Context>()
+  fun deleteMessage_failsWhenConversionFails() {
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(testMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
     `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
-    `when`(mockDocumentSnapshot.exists()).thenReturn(false) // Simulate nonexistent document
+    `when`(mockDocumentSnapshot.exists()).thenReturn(true)
+    `when`(mockDocumentSnapshot.getString("uuid"))
+        .thenReturn(null) // Missing field causes conversion failure
 
-    messageRepository.updateMessage(
-        testMessage,
+    messageFirestoreSource.deleteMessage(
+        testMessage.uuid,
         { result ->
-          assertTrue(result.isFailure)
-          assertEquals("Message not found", result.exceptionOrNull()?.message)
+          assert(result.isFailure)
+          assert(result.exceptionOrNull()?.message == "Message not found")
         },
-        context)
-
-    // Verify update was not called
-    verify(mockDocumentReference, never()).update(anyMap())
+        mockContext)
   }
 
+  // DeleteAllMessages Tests
   @Test
-  fun `delete all messages between two users deletes documents`() {
-    // Arrange
+  fun deleteAllMessages_deletesMessagesSuccessfully() {
+    val documents = listOf(mockDocumentSnapshot)
+    val mockBatch = mock(WriteBatch::class.java)
+
     `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
-    `when`(mockCollectionReference.whereIn("senderId", listOf("user1", "user2")))
+    `when`(
+            mockCollectionReference.whereIn(
+                "senderUUID", listOf(testMessage.senderUUID, testMessage.receiverUUID)))
         .thenReturn(mockCollectionReference)
-    `when`(mockCollectionReference.whereIn("receiverId", listOf("user1", "user2")))
+
+    `when`(
+            mockCollectionReference.whereIn(
+                "receiverUUID", listOf(testMessage.senderUUID, testMessage.receiverUUID)))
         .thenReturn(mockCollectionReference)
-    `when`(mockCollectionReference.whereNotEqualTo("senderId", "receiverId"))
+    `when`(mockCollectionReference.whereNotEqualTo("senderUUID", "receiverUUID"))
         .thenReturn(mockCollectionReference)
-
-    // Mock retrieval of a query snapshot with one document to delete
     `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
-    `when`(mockQuerySnapshot.documents).thenReturn(listOf(mockDocumentSnapshot))
-    `when`(mockDocumentSnapshot.reference).thenReturn(mockDocumentReference)
+    `when`(mockQuerySnapshot.documents).thenReturn(documents)
 
-    // Mock the Firestore batch process
-    val mockBatch = mock<WriteBatch>()
     `when`(mockFirestore.batch()).thenReturn(mockBatch)
-    `when`(mockBatch.delete(mockDocumentReference)).thenReturn(mockBatch)
-    `when`(mockBatch.commit()).thenReturn(Tasks.forResult(null)) // Simulate successful commit
+    documents.forEach { `when`(mockBatch.delete(it.reference)).thenReturn(mockBatch) }
+    `when`(mockBatch.commit()).thenReturn(Tasks.forResult(null))
 
-    // Act
-    messageRepository.deleteAllMessages("user1", "user2") { result ->
-      // Assert that the delete operation was successful
-      assertTrue(result.isSuccess)
+    messageFirestoreSource.deleteAllMessages(testMessage.senderUUID, testMessage.receiverUUID) {
+        result ->
+      assert(result.isSuccess)
     }
 
-    // Ensure that any pending tasks are executed
     shadowOf(Looper.getMainLooper()).idle()
 
-    // Verify interactions
-    verify(mockCollectionReference).get() // Verify retrieval call
-    verify(mockBatch).delete(mockDocumentReference) // Verify deletion call
-    verify(mockBatch).commit() // Verify batch commit call
+    verify(mockBatch).commit()
+  }
+
+  @Test
+  fun deleteAllMessages_returnsSuccessWhenNoMessagesToDelete() {
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(
+            mockCollectionReference.whereIn(
+                "senderUUID", listOf(testMessage.senderUUID, testMessage.receiverUUID)))
+        .thenReturn(mockCollectionReference)
+    `when`(
+            mockCollectionReference.whereIn(
+                "receiverUUID", listOf(testMessage.senderUUID, testMessage.receiverUUID)))
+        .thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.whereNotEqualTo("senderUUID", "receiverUUID"))
+        .thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
+    `when`(mockQuerySnapshot.documents).thenReturn(emptyList()) // No messages found
+
+    messageFirestoreSource.deleteAllMessages(testMessage.senderUUID, testMessage.receiverUUID) {
+        result ->
+      assert(result.isSuccess)
+    }
+  }
+
+  @Test
+  fun deleteAllMessages_failsWhenFirestoreRetrievalError() {
+    val exception = RuntimeException("Firestore retrieval error")
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(
+            mockCollectionReference.whereIn(
+                "senderUUID", listOf(testMessage.senderUUID, testMessage.receiverUUID)))
+        .thenReturn(mockCollectionReference)
+    `when`(
+            mockCollectionReference.whereIn(
+                "receiverUUID", listOf(testMessage.senderUUID, testMessage.receiverUUID)))
+        .thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.whereNotEqualTo("senderUUID", "receiverUUID"))
+        .thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.get()).thenReturn(Tasks.forException(exception))
+
+    messageFirestoreSource.deleteAllMessages(testMessage.senderUUID, testMessage.receiverUUID) {
+        result ->
+      assert(result.isFailure)
+      assert(result.exceptionOrNull() == exception)
+    }
+  }
+
+  @Test
+  fun deleteAllMessages_failsWhenBatchCommitError() {
+    val documents = listOf(mockDocumentSnapshot)
+    val exception = RuntimeException("Batch commit error")
+    val mockBatch = mock(WriteBatch::class.java)
+
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(
+            mockCollectionReference.whereIn(
+                "senderUUID", listOf(testMessage.senderUUID, testMessage.receiverUUID)))
+        .thenReturn(mockCollectionReference)
+    `when`(
+            mockCollectionReference.whereIn(
+                "receiverUUID", listOf(testMessage.senderUUID, testMessage.receiverUUID)))
+        .thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.whereNotEqualTo("senderUUID", "receiverUUID"))
+        .thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.get()).thenReturn(Tasks.forResult(mockQuerySnapshot))
+    `when`(mockQuerySnapshot.documents).thenReturn(documents)
+
+    `when`(mockFirestore.batch()).thenReturn(mockBatch)
+    documents.forEach { `when`(mockBatch.delete(it.reference)).thenReturn(mockBatch) }
+    `when`(mockBatch.commit()).thenReturn(Tasks.forException(exception))
+
+    messageFirestoreSource.deleteAllMessages(testMessage.senderUUID, testMessage.receiverUUID) {
+        result ->
+      assert(result.isFailure)
+      assert(result.exceptionOrNull() == exception)
+    }
+  }
+
+  // UpdateMessage Tests
+  @Test
+  fun updateMessage_failsWhenMessageNotFound() {
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(testMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
+    `when`(mockDocumentSnapshot.exists()).thenReturn(false)
+
+    messageFirestoreSource.updateMessage(
+        testMessage,
+        { result ->
+          assert(result.isFailure)
+          assert(result.exceptionOrNull()?.message == "Message not found")
+        },
+        mockContext)
+  }
+
+  @Test
+  fun updateMessage_failsWhenMessageTooOld() {
+    val oldMessage =
+        testMessage.copy(
+            timestamp =
+                System.currentTimeMillis() -
+                    (15 * 60 * 1000 + 1000)) // Sent more than 15 minutes ago
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(oldMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
+    `when`(mockDocumentSnapshot.exists()).thenReturn(true)
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(oldMessage.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("text")).thenReturn(oldMessage.text)
+    `when`(mockDocumentSnapshot.getString("senderUUID"))
+        .thenReturn(oldMessage.senderUUID.toString())
+    `when`(mockDocumentSnapshot.getString("receiverUUID"))
+        .thenReturn(oldMessage.receiverUUID.toString())
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(oldMessage.timestamp)
+
+    messageFirestoreSource.updateMessage(
+        oldMessage,
+        { result ->
+          assert(result.isFailure)
+          assert(
+              result.exceptionOrNull()?.message ==
+                  "Message can only be updated within 15 minutes of being sent")
+        },
+        mockContext)
+  }
+
+  @Test
+  fun updateMessage_failsOnFirestoreRetrievalError() {
+    val exception = RuntimeException("Firestore retrieval error")
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(testMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forException(exception))
+
+    messageFirestoreSource.updateMessage(
+        testMessage,
+        { result ->
+          assert(result.isFailure)
+          assert(result.exceptionOrNull() == exception)
+        },
+        mockContext)
+  }
+
+  @Test
+  fun updateMessage_failsOnFirestoreUpdateError() {
+    val exception = RuntimeException("Firestore update error")
+    val recentMessage =
+        testMessage.copy(timestamp = System.currentTimeMillis() - (15 * 60 * 1000 - 1000))
+    val updatedText = "Updated text"
+    val messageMap = mapOf("text" to updatedText, "timestamp" to System.currentTimeMillis())
+
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(recentMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
+    `when`(mockDocumentSnapshot.exists()).thenReturn(true)
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(recentMessage.uuid.toString())
+    `when`(mockDocumentSnapshot.getString("text")).thenReturn(recentMessage.text)
+    `when`(mockDocumentSnapshot.getString("senderUUID"))
+        .thenReturn(recentMessage.senderUUID.toString())
+    `when`(mockDocumentSnapshot.getString("receiverUUID"))
+        .thenReturn(recentMessage.receiverUUID.toString())
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(recentMessage.timestamp)
+    `when`(mockDocumentReference.update(messageMap)).thenReturn(Tasks.forException(exception))
+
+    messageFirestoreSource.updateMessage(
+        recentMessage.copy(text = updatedText),
+        { result ->
+          assert(result.isFailure)
+          assert(result.exceptionOrNull() == exception)
+        },
+        mockContext)
+  }
+
+  @Test
+  fun updateMessage_failsWhenConversionFails() {
+    `when`(mockFirestore.collection(COLLECTION_PATH)).thenReturn(mockCollectionReference)
+    `when`(mockCollectionReference.document(testMessage.uuid.toString()))
+        .thenReturn(mockDocumentReference)
+    `when`(mockDocumentReference.get()).thenReturn(Tasks.forResult(mockDocumentSnapshot))
+    `when`(mockDocumentSnapshot.exists()).thenReturn(true)
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(null)
+
+    messageFirestoreSource.updateMessage(
+        testMessage,
+        { result ->
+          assert(result.isFailure)
+          assert(result.exceptionOrNull()?.message == "Message not found")
+        },
+        mockContext)
+  }
+
+  @Test
+  fun documentToMessage_returnsDataMessageOnSuccess() {
+    val definedUUID = UUID.randomUUID()
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(definedUUID.toString())
+    `when`(mockDocumentSnapshot.getString("text")).thenReturn("Test message")
+    `when`(mockDocumentSnapshot.getString("senderUUID"))
+        .thenReturn(testMessage.senderUUID.toString())
+    `when`(mockDocumentSnapshot.getString("receiverUUID"))
+        .thenReturn(testMessage.receiverUUID.toString())
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(1634567890L)
+    `when`(mockDocumentSnapshot.getString("messageType")).thenReturn("TEXT")
+
+    val result = documentToMessage(mockDocumentSnapshot)
+
+    assert(result.isSuccess)
+    val message = result.getOrNull()
+    assert(message != null)
+    assert(message?.uuid == definedUUID)
+    assert(message?.text == "Test message")
+    assert(message?.senderUUID == testMessage.senderUUID)
+    assert(message?.receiverUUID == testMessage.receiverUUID)
+    assert(message?.timestamp == 1634567890L)
+    assert(message?.messageType == MessageType.TEXT)
+  }
+
+  @Test
+  fun documentToMessage_returnsFailureWhenFieldIsMissing() {
+    `when`(mockDocumentSnapshot.getString("uuid")).thenReturn(UUID.randomUUID().toString())
+    `when`(mockDocumentSnapshot.getString("text")).thenReturn(null) // Missing field
+    `when`(mockDocumentSnapshot.getString("senderUUID")).thenReturn("sender1")
+    `when`(mockDocumentSnapshot.getString("receiverUUID")).thenReturn("receiver1")
+    `when`(mockDocumentSnapshot.getLong("timestamp")).thenReturn(1634567890L)
+    `when`(mockDocumentSnapshot.getString("messageType")).thenReturn("TEXT")
+
+    val result = documentToMessage(mockDocumentSnapshot)
+
+    assert(result.isFailure)
+    assert(result.exceptionOrNull() is Exception)
   }
 }
Index: app/src/test/java/com/android/bookswap/data/source/api/GoogleBookDataSourceTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.data.source.api\n\nimport com.android.bookswap.data.BookLanguages\nimport com.android.bookswap.data.DataBook\nimport java.util.UUID\nimport org.junit.After\nimport org.junit.Assert.assertEquals\nimport org.junit.Assert.assertTrue\nimport org.junit.Before\nimport org.junit.Test\nimport org.junit.runner.RunWith\nimport org.mockito.ArgumentCaptor\nimport org.mockito.ArgumentMatchers\nimport org.mockito.Captor\nimport org.mockito.Mockito.anyString\nimport org.mockito.Mockito.`when`\nimport org.mockito.MockitoAnnotations\nimport org.mockito.kotlin.capture\nimport org.mockito.kotlin.mock\nimport org.mockito.kotlin.times\nimport org.mockito.kotlin.verify\nimport org.robolectric.RobolectricTestRunner\n\n@RunWith(RobolectricTestRunner::class)\nclass GoogleBookDataSourceTest {\n\n  private lateinit var mockitoClosable: AutoCloseable\n  @Captor private lateinit var resultDataBookCaptor: ArgumentCaptor<Result<DataBook>>\n\n  @Before\n  fun init() {\n    mockitoClosable = MockitoAnnotations.openMocks(this)\n  }\n\n  @After\n  fun close() {\n    mockitoClosable.close()\n  }\n\n  @Test\n  fun `ISBN input validation`() {\n    val mockGoogleBookDataSource: GoogleBookDataSource = mock()\n\n    val callback: (Result<DataBook>) -> Unit = mock()\n    `when`(\n            mockGoogleBookDataSource.getBookFromISBN(\n                anyString(), ArgumentMatchers.any(callback::class.java) ?: callback))\n        .thenCallRealMethod()\n\n    mockGoogleBookDataSource.getBookFromISBN(\"01a3456789\", callback)\n    mockGoogleBookDataSource.getBookFromISBN(\"01234567890\", callback)\n    verify(callback, times(2)).invoke(capture(resultDataBookCaptor))\n\n    assert(resultDataBookCaptor.value.isFailure)\n  }\n\n  @Test\n  fun `parseISBNResponse correctly parse`() {\n    val jsonBook =\n        \"\"\"\n      {\n        \"kind\": \"books#volumes\",\n        \"totalItems\": 1,\n        \"items\": [\n          {\n            \"id\": \"JLunPwAACAAJ\",\n            \"volumeInfo\": {\n              \"title\": \"Flowers for Algernon\",\n              \"authors\": [\n                \"Daniel Keyes\"\n              ],\n              \"description\": \"Example desc\",\n              \"industryIdentifiers\": [\n                {\n                  \"type\": \"ISBN_10\",\n                  \"identifier\": \"0435123432\"\n                },\n                {\n                  \"type\": \"ISBN_13\",\n                  \"identifier\": \"9780435123437\"\n                }\n              ],\n              \"imageLinks\": {\n                \"smallThumbnail\": \"image1\",\n                \"thumbnail\": \"image2\"\n              },\n              \"language\": \"en\"\n            }\n          }\n        ]\n      }\n    \"\"\"\n            .trimIndent()\n    val dataBook =\n        DataBook(\n            uuid = UUID.randomUUID(),\n            title = \"Flowers for Algernon\",\n            author = \"Daniel Keyes\",\n            description = \"Example desc\",\n            rating = null,\n            photo = \"image2\",\n            language = BookLanguages.ENGLISH,\n            isbn = \"9780435123437\")\n\n    val mockGoogleBookDataSource: GoogleBookDataSource = mock()\n    `when`(mockGoogleBookDataSource.parseISBNResponse(jsonBook)).thenCallRealMethod()\n\n    assertBookEquals(dataBook, mockGoogleBookDataSource.parseISBNResponse(jsonBook).getOrNull())\n  }\n\n  @Test\n  fun `parseISBNResponse fail when json is wrong`() {\n    val brokenJSON = \"BROKEN JSON\"\n\n    val mockGoogleBookDataSource: GoogleBookDataSource = mock()\n    `when`(mockGoogleBookDataSource.parseISBNResponse(brokenJSON)).thenCallRealMethod()\n\n    assertTrue(mockGoogleBookDataSource.parseISBNResponse(brokenJSON).isFailure)\n  }\n\n  @Test\n  fun `parseISBNResponse fail when title is not available`() {\n    val missingTitleJson =\n        \"\"\"\n      {\n        \"kind\": \"books#volumes\",\n        \"totalItems\": 1,\n        \"items\": [\n          {\n            \"id\": \"JLunPwAACAAJ\",\n            \"volumeInfo\": {\n              \"authors\": [\n                \"Daniel Keyes\"\n              ],\n              \"description\": \"Example desc\",\n              \"industryIdentifiers\": [\n                {\n                  \"type\": \"ISBN_10\",\n                  \"identifier\": \"0435123432\"\n                },\n                {\n                  \"type\": \"ISBN_13\",\n                  \"identifier\": \"9780435123437\"\n                }\n              ],\n              \"imageLinks\": {\n                \"smallThumbnail\": \"image1\",\n                \"thumbnail\": \"image2\"\n              },\n              \"language\": \"en\"\n            }\n          }\n        ]\n      }\n    \"\"\"\n            .trimIndent()\n\n    val mockGoogleBookDataSource: GoogleBookDataSource = mock()\n    `when`(mockGoogleBookDataSource.parseISBNResponse(missingTitleJson)).thenCallRealMethod()\n\n    assertTrue(mockGoogleBookDataSource.parseISBNResponse(missingTitleJson).isFailure)\n  }\n\n  @Test\n  fun `parseISBNResponse valid when partially empty`() {\n    val fieldsEmpty =\n        \"\"\"\n      {\n        \"kind\": \"books#volumes\",\n        \"totalItems\": 1,\n        \"items\": [\n          {\n            \"id\": \"JLunPwAACAAJ\",\n            \"volumeInfo\": {\n              \"title\": \"Flowers for Algernon\",\n              \"industryIdentifiers\": [\n                {\n                  \"type\": \"ISBN_10\",\n                  \"identifier\": \"0435123432\"\n                },\n                {\n                  \"type\": \"ISBN_13\",\n                  \"identifier\": \"9780435123437\"\n                }\n              ]\n            }\n          }\n        ]\n      }\n    \"\"\"\n            .trimIndent()\n    val listEmpty =\n        \"\"\"\n      {\n        \"kind\": \"books#volumes\",\n        \"totalItems\": 1,\n        \"items\": [\n          {\n            \"id\": \"JLunPwAACAAJ\",\n            \"volumeInfo\": {\n              \"title\": \"Flowers for Algernon\",\n              \"authors\": [],\n              \"industryIdentifiers\": [\n                {\n                  \"type\": \"ISBN_10\",\n                  \"identifier\": \"0435123432\"\n                },\n                {\n                  \"type\": \"ISBN_13\",\n                  \"identifier\": \"9780435123437\"\n                }\n              ],\n              \"imageLinks\": {}\n            }\n          }\n        ]\n      }\n    \"\"\"\n            .trimIndent()\n    val dataBook =\n        DataBook(\n            uuid = UUID.randomUUID(),\n            title = \"Flowers for Algernon\",\n            author = null,\n            description = null,\n            rating = null,\n            photo = null,\n            language = BookLanguages.OTHER,\n            isbn = \"9780435123437\")\n\n    val mockGoogleBookDataSource: GoogleBookDataSource = mock()\n    `when`(mockGoogleBookDataSource.parseISBNResponse(anyString())).thenCallRealMethod()\n\n    assertBookEquals(dataBook, mockGoogleBookDataSource.parseISBNResponse(fieldsEmpty).getOrNull())\n    assertBookEquals(dataBook, mockGoogleBookDataSource.parseISBNResponse(listEmpty).getOrNull())\n  }\n\n  /**\n   * Assert that two books are identical except for their UUID\n   *\n   * @param expected the expected result\n   * @param result the result with it's UUID modified to match the UUID of expected\n   */\n  private fun assertBookEquals(expected: DataBook, result: DataBook?) {\n    assertEquals(expected, result?.copy(uuid = expected.uuid))\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/source/api/GoogleBookDataSourceTest.kt b/app/src/test/java/com/android/bookswap/data/source/api/GoogleBookDataSourceTest.kt
--- a/app/src/test/java/com/android/bookswap/data/source/api/GoogleBookDataSourceTest.kt	
+++ b/app/src/test/java/com/android/bookswap/data/source/api/GoogleBookDataSourceTest.kt	
@@ -2,9 +2,9 @@
 
 import com.android.bookswap.data.BookLanguages
 import com.android.bookswap.data.DataBook
+import com.android.bookswap.utils.assertBookEquals
 import java.util.UUID
 import org.junit.After
-import org.junit.Assert.assertEquals
 import org.junit.Assert.assertTrue
 import org.junit.Before
 import org.junit.Test
@@ -234,14 +234,4 @@
     assertBookEquals(dataBook, mockGoogleBookDataSource.parseISBNResponse(fieldsEmpty).getOrNull())
     assertBookEquals(dataBook, mockGoogleBookDataSource.parseISBNResponse(listEmpty).getOrNull())
   }
-
-  /**
-   * Assert that two books are identical except for their UUID
-   *
-   * @param expected the expected result
-   * @param result the result with it's UUID modified to match the UUID of expected
-   */
-  private fun assertBookEquals(expected: DataBook, result: DataBook?) {
-    assertEquals(expected, result?.copy(uuid = expected.uuid))
-  }
 }
Index: app/src/test/java/com/android/bookswap/ui/navigation/NavigationActionsTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.navigation\n\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.MailOutline\nimport androidx.compose.material.icons.outlined.AccountCircle\nimport androidx.compose.material.icons.outlined.AddCircle\nimport androidx.compose.material.icons.outlined.Place\nimport androidx.navigation.NavDestination\nimport androidx.navigation.NavHostController\nimport androidx.navigation.NavOptionsBuilder\nimport org.hamcrest.CoreMatchers.`is`\nimport org.hamcrest.MatcherAssert.assertThat\nimport org.junit.Before\nimport org.junit.Test\nimport org.mockito.Mockito.mock\nimport org.mockito.Mockito.verify\nimport org.mockito.Mockito.`when`\nimport org.mockito.kotlin.any\nimport org.mockito.kotlin.eq\n\nclass NavigationActionsTest {\n  private lateinit var navigationDestination: NavDestination\n  private lateinit var navHostController: NavHostController\n  private lateinit var navigationActions: NavigationActions\n\n  @Before\n  fun setUp() {\n    navigationDestination = mock(NavDestination::class.java)\n    navHostController = mock(NavHostController::class.java)\n    navigationActions = NavigationActions(navHostController)\n  }\n\n  @Test\n  fun navigateToTopLevelDestination() {\n    navigationActions.navigateTo(TopLevelDestinations.CHAT)\n    verify(navHostController).navigate(eq(Route.CHAT), any<(NavOptionsBuilder) -> Unit>())\n\n    navigationActions.navigateTo(TopLevelDestinations.MAP)\n    verify(navHostController).navigate(eq(Route.MAP), any<(NavOptionsBuilder) -> Unit>())\n\n    navigationActions.navigateTo(TopLevelDestinations.PROFILE)\n    verify(navHostController).navigate(eq(Route.PROFIL), any<(NavOptionsBuilder) -> Unit>())\n\n    navigationActions.navigateTo(TopLevelDestinations.NEW_BOOK)\n    verify(navHostController).navigate(eq(Route.NEWBOOK), any<(NavOptionsBuilder) -> Unit>())\n  }\n\n  @Test\n  fun navigateToScreen() {\n    navigationActions.navigateTo(Screen.MAP)\n    verify(navHostController).navigate(Screen.MAP)\n\n    navigationActions.navigateTo(Screen.CHAT)\n    verify(navHostController).navigate(Screen.CHAT)\n\n    navigationActions.navigateTo(Screen.NEWBOOK)\n    verify(navHostController).navigate(Screen.NEWBOOK)\n\n    navigationActions.navigateTo(Screen.ADD_BOOK_ISBN)\n    verify(navHostController).navigate(Screen.ADD_BOOK_ISBN)\n\n    navigationActions.navigateTo(Screen.ADD_BOOK_SCAN)\n    verify(navHostController).navigate(Screen.ADD_BOOK_SCAN)\n  }\n\n  @Test\n  fun currentRouteAreCorrect() {\n    `when`(navHostController.currentDestination).thenReturn(navigationDestination)\n    `when`(navigationDestination.route).thenReturn(Route.NEWBOOK)\n\n    navigationActions.navigateTo(TopLevelDestinations.NEW_BOOK)\n    assertThat(navigationActions.currentRoute(), `is`(Route.NEWBOOK))\n  }\n\n  @Test\n  fun goBackCallPopBackStack() {\n    navigationActions.goBack()\n    verify(navHostController).popBackStack()\n  }\n\n  @Test\n  fun topLevelDestinationsHaveCorrectIcon() {\n    assertThat(TopLevelDestinations.CHAT.icon, `is`(Icons.Filled.MailOutline))\n    assertThat(TopLevelDestinations.MAP.icon, `is`(Icons.Outlined.Place))\n    assertThat(TopLevelDestinations.NEW_BOOK.icon, `is`(Icons.Outlined.AddCircle))\n    assertThat(TopLevelDestinations.PROFILE.icon, `is`(Icons.Outlined.AccountCircle))\n  }\n\n  @Test\n  fun list_Navigation_Bar_DestinationsCorrectOrder() {\n    assertThat(\n        List_Navigation_Bar_Destinations,\n        `is`(\n            listOf(\n                TopLevelDestinations.CHAT,\n                TopLevelDestinations.NEW_BOOK,\n                TopLevelDestinations.MAP)))\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/ui/navigation/NavigationActionsTest.kt b/app/src/test/java/com/android/bookswap/ui/navigation/NavigationActionsTest.kt
--- a/app/src/test/java/com/android/bookswap/ui/navigation/NavigationActionsTest.kt	
+++ b/app/src/test/java/com/android/bookswap/ui/navigation/NavigationActionsTest.kt	
@@ -39,7 +39,7 @@
     verify(navHostController).navigate(eq(Route.MAP), any<(NavOptionsBuilder) -> Unit>())
 
     navigationActions.navigateTo(TopLevelDestinations.PROFILE)
-    verify(navHostController).navigate(eq(Route.PROFIL), any<(NavOptionsBuilder) -> Unit>())
+    verify(navHostController).navigate(eq(Route.PROFILE), any<(NavOptionsBuilder) -> Unit>())
 
     navigationActions.navigateTo(TopLevelDestinations.NEW_BOOK)
     verify(navHostController).navigate(eq(Route.NEWBOOK), any<(NavOptionsBuilder) -> Unit>())
Index: app/src/androidTest/java/com/android/bookswap/ui/chat/ListChatScreenTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.chat\n\nimport androidx.compose.ui.test.assertAll\nimport androidx.compose.ui.test.assertHasClickAction\nimport androidx.compose.ui.test.assertIsDisplayed\nimport androidx.compose.ui.test.assertTextEquals\nimport androidx.compose.ui.test.hasClickAction\nimport androidx.compose.ui.test.junit4.createComposeRule\nimport androidx.compose.ui.test.onAllNodesWithTag\nimport androidx.compose.ui.test.onChild\nimport androidx.compose.ui.test.onNodeWithContentDescription\nimport androidx.compose.ui.test.onNodeWithTag\nimport androidx.navigation.compose.rememberNavController\nimport com.android.bookswap.model.chat.MessageBox\nimport com.android.bookswap.ui.navigation.NavigationActions\nimport org.junit.Before\nimport org.junit.Rule\nimport org.junit.Test\n\nclass ListChatScreenTest {\n\n  @get:Rule val composeTestRule = createComposeRule()\n  private lateinit var placeHolderData: List<MessageBox>\n  private lateinit var placeHolderDataEmpty: List<MessageBox>\n\n  @Before\n  fun setUp() {\n    placeHolderData =\n        List(12) {\n          MessageBox(\n              \"Contact ${it + 1}\",\n              \"Test message $it test for the feature of ellipsis in the message\",\n              \"01.01.24\")\n        }\n    placeHolderDataEmpty = emptyList()\n  }\n\n  @Test\n  fun hasRequiredComponentsWithMessage() {\n    composeTestRule.setContent {\n      val navController = rememberNavController()\n      val navigationActions = NavigationActions(navController)\n      ListChatScreen(placeHolderData, navigationActions)\n    }\n    composeTestRule.onNodeWithTag(\"chat_messageScreenTitle\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"profileIconButton\").assertIsDisplayed()\n    composeTestRule.onNodeWithContentDescription(\"Profile Icon\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"chat_messageList\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"bottomNavigationMenu\").assertIsDisplayed()\n\n    composeTestRule.onNodeWithTag(\"chat_messageScreenTitle\").onChild().assertTextEquals(\"Messages\")\n  }\n\n  @Test\n  fun hasRequiredComponentsWithMessageEmpty() {\n    composeTestRule.setContent {\n      val navController = rememberNavController()\n      val navigationActions = NavigationActions(navController)\n      ListChatScreen(placeHolderDataEmpty, navigationActions)\n    }\n    composeTestRule.onNodeWithTag(\"chat_messageScreenTitle\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"profileIconButton\").assertIsDisplayed()\n    composeTestRule.onNodeWithContentDescription(\"Profile Icon\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"chat_messageList\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"bottomNavigationMenu\").assertIsDisplayed()\n\n    composeTestRule.onNodeWithTag(\"chat_messageScreenTitle\").onChild().assertTextEquals(\"Messages\")\n    composeTestRule.onNodeWithTag(\"chat_messageList\").onChild().assertTextEquals(\"No messages yet\")\n  }\n\n  @Test\n  fun hasClickableComponents() {\n    composeTestRule.setContent {\n      val navController = rememberNavController()\n      val navigationActions = NavigationActions(navController)\n      ListChatScreen(placeHolderData, navigationActions)\n    }\n    composeTestRule.onNodeWithTag(\"profileIconButton\").assertHasClickAction()\n  }\n\n  @Test\n  fun allMessageBoxesAreClickable() {\n    composeTestRule.setContent {\n      val navController = rememberNavController()\n      val navigationActions = NavigationActions(navController)\n      ListChatScreen(placeHolderData, navigationActions)\n    }\n    val messageNodes = composeTestRule.onAllNodesWithTag(\"chat_messageBox\")\n    assert(messageNodes.fetchSemanticsNodes().isNotEmpty())\n    messageNodes.assertAll(hasClickAction())\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/chat/ListChatScreenTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/chat/ListChatScreenTest.kt
--- a/app/src/androidTest/java/com/android/bookswap/ui/chat/ListChatScreenTest.kt	
+++ b/app/src/androidTest/java/com/android/bookswap/ui/chat/ListChatScreenTest.kt	
@@ -1,5 +1,6 @@
 package com.android.bookswap.ui.chat
 
+import androidx.compose.ui.Modifier
 import androidx.compose.ui.test.assertAll
 import androidx.compose.ui.test.assertHasClickAction
 import androidx.compose.ui.test.assertIsDisplayed
@@ -11,8 +12,13 @@
 import androidx.compose.ui.test.onNodeWithContentDescription
 import androidx.compose.ui.test.onNodeWithTag
 import androidx.navigation.compose.rememberNavController
-import com.android.bookswap.model.chat.MessageBox
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.MessageBox
+import com.android.bookswap.ui.components.TopAppBarComponent
+import com.android.bookswap.ui.navigation.BottomNavigationMenu
+import com.android.bookswap.ui.navigation.List_Navigation_Bar_Destinations
 import com.android.bookswap.ui.navigation.NavigationActions
+import java.util.UUID
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
@@ -28,7 +34,18 @@
     placeHolderData =
         List(12) {
           MessageBox(
-              "Contact ${it + 1}",
+              DataUser(
+                  UUID.randomUUID(),
+                  "Hello",
+                  "First ${it + 1}",
+                  "Last ${it + 1}",
+                  "",
+                  "",
+                  0.0,
+                  0.0,
+                  "",
+                  emptyList(),
+                  "googleUid"),
               "Test message $it test for the feature of ellipsis in the message",
               "01.01.24")
         }
@@ -40,15 +57,24 @@
     composeTestRule.setContent {
       val navController = rememberNavController()
       val navigationActions = NavigationActions(navController)
-      ListChatScreen(placeHolderData, navigationActions)
+      ListChatScreen(
+          placeHolderData,
+          navigationActions,
+          { TopAppBarComponent(Modifier, navigationActions, "Messages") },
+          {
+            BottomNavigationMenu(
+                onTabSelect = { destination -> navigationActions.navigateTo(destination) },
+                tabList = List_Navigation_Bar_Destinations,
+                selectedItem = navigationActions.currentRoute())
+          })
     }
-    composeTestRule.onNodeWithTag("chat_messageScreenTitle").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("TopAppBar").assertIsDisplayed()
     composeTestRule.onNodeWithTag("profileIconButton").assertIsDisplayed()
     composeTestRule.onNodeWithContentDescription("Profile Icon").assertIsDisplayed()
     composeTestRule.onNodeWithTag("chat_messageList").assertIsDisplayed()
     composeTestRule.onNodeWithTag("bottomNavigationMenu").assertIsDisplayed()
 
-    composeTestRule.onNodeWithTag("chat_messageScreenTitle").onChild().assertTextEquals("Messages")
+    composeTestRule.onNodeWithTag("TopAppBar_Title").assertTextEquals("Messages")
   }
 
   @Test
@@ -56,15 +82,24 @@
     composeTestRule.setContent {
       val navController = rememberNavController()
       val navigationActions = NavigationActions(navController)
-      ListChatScreen(placeHolderDataEmpty, navigationActions)
+      ListChatScreen(
+          placeHolderDataEmpty,
+          navigationActions,
+          { TopAppBarComponent(Modifier, navigationActions, "Messages") },
+          {
+            BottomNavigationMenu(
+                onTabSelect = { destination -> navigationActions.navigateTo(destination) },
+                tabList = List_Navigation_Bar_Destinations,
+                selectedItem = navigationActions.currentRoute())
+          })
     }
-    composeTestRule.onNodeWithTag("chat_messageScreenTitle").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("TopAppBar").assertIsDisplayed()
     composeTestRule.onNodeWithTag("profileIconButton").assertIsDisplayed()
     composeTestRule.onNodeWithContentDescription("Profile Icon").assertIsDisplayed()
     composeTestRule.onNodeWithTag("chat_messageList").assertIsDisplayed()
     composeTestRule.onNodeWithTag("bottomNavigationMenu").assertIsDisplayed()
 
-    composeTestRule.onNodeWithTag("chat_messageScreenTitle").onChild().assertTextEquals("Messages")
+    composeTestRule.onNodeWithTag("TopAppBar_Title").assertTextEquals("Messages")
     composeTestRule.onNodeWithTag("chat_messageList").onChild().assertTextEquals("No messages yet")
   }
 
@@ -73,7 +108,16 @@
     composeTestRule.setContent {
       val navController = rememberNavController()
       val navigationActions = NavigationActions(navController)
-      ListChatScreen(placeHolderData, navigationActions)
+      ListChatScreen(
+          placeHolderData,
+          navigationActions,
+          { TopAppBarComponent(Modifier, navigationActions, "Messages") },
+          {
+            BottomNavigationMenu(
+                onTabSelect = { destination -> navigationActions.navigateTo(destination) },
+                tabList = List_Navigation_Bar_Destinations,
+                selectedItem = navigationActions.currentRoute())
+          })
     }
     composeTestRule.onNodeWithTag("profileIconButton").assertHasClickAction()
   }
@@ -83,7 +127,16 @@
     composeTestRule.setContent {
       val navController = rememberNavController()
       val navigationActions = NavigationActions(navController)
-      ListChatScreen(placeHolderData, navigationActions)
+      ListChatScreen(
+          placeHolderData,
+          navigationActions,
+          { TopAppBarComponent(Modifier, navigationActions, "Messages") },
+          {
+            BottomNavigationMenu(
+                onTabSelect = { destination -> navigationActions.navigateTo(destination) },
+                tabList = List_Navigation_Bar_Destinations,
+                selectedItem = navigationActions.currentRoute())
+          })
     }
     val messageNodes = composeTestRule.onAllNodesWithTag("chat_messageBox")
     assert(messageNodes.fetchSemanticsNodes().isNotEmpty())
Index: app/src/androidTest/java/com/android/bookswap/ui/books/add/ISBNAddTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.books.add\n\nimport android.widget.Toast\nimport androidx.compose.ui.semantics.SemanticsProperties\nimport androidx.compose.ui.test.assertHasClickAction\nimport androidx.compose.ui.test.assertIsDisplayed\nimport androidx.compose.ui.test.junit4.createComposeRule\nimport androidx.compose.ui.test.onNodeWithTag\nimport androidx.compose.ui.test.performClick\nimport androidx.compose.ui.test.performTextClearance\nimport androidx.compose.ui.test.performTextInput\nimport androidx.test.ext.junit.runners.AndroidJUnit4\nimport com.android.bookswap.data.BookLanguages\nimport com.android.bookswap.data.DataBook\nimport com.android.bookswap.data.repository.BooksRepository\nimport com.android.bookswap.data.source.api.GoogleBookDataSource\nimport com.android.bookswap.ui.navigation.NavigationActions\nimport com.android.bookswap.ui.navigation.TopLevelDestination\nimport com.android.bookswap.utils.matchDataBook\nimport com.kaspersky.kaspresso.testcases.api.testcase.TestCase\nimport io.mockk.Runs\nimport io.mockk.andThenJust\nimport io.mockk.every\nimport io.mockk.just\nimport io.mockk.mockk\nimport io.mockk.mockkConstructor\nimport io.mockk.mockkStatic\nimport io.mockk.verify\nimport java.util.UUID\nimport org.junit.Assert\nimport org.junit.Before\nimport org.junit.Rule\nimport org.junit.Test\nimport org.junit.runner.RunWith\n\n@RunWith(AndroidJUnit4::class)\nclass ISBNAddTest : TestCase() {\n  @get:Rule val composeTestRule = createComposeRule()\n  private lateinit var toastMock: Toast\n\n  @Before\n  fun init() {\n    mockkStatic(Toast::class)\n    toastMock = mockk<Toast>()\n    every { toastMock.show() } returns Unit\n    every { Toast.makeText(any(), any<String>(), any()) } returns toastMock\n  }\n\n  @Test\n  fun elementsAreDisplayed() {\n    composeTestRule.setContent {\n      val mockNavigationActions: NavigationActions = mockk()\n      val mockBooksRepository: BooksRepository = mockk()\n\n      AddISBNScreen(mockNavigationActions, mockBooksRepository)\n    }\n\n    val isbnField = composeTestRule.onNodeWithTag(\"isbn_field\")\n    isbnField.assertIsDisplayed()\n    Assert.assertEquals(\n        \"ISBN*\", isbnField.fetchSemanticsNode().config[SemanticsProperties.Text][0].text)\n\n    composeTestRule.onNodeWithTag(\"isbn_searchButton\").assertIsDisplayed()\n    composeTestRule.onNodeWithTag(\"isbn_searchButton\").assertHasClickAction()\n  }\n\n  @Suppress(\"TestFunctionName\")\n  @Test\n  fun ISBNFieldWork() {\n    composeTestRule.setContent {\n      val mockNavigationActions: NavigationActions = mockk()\n      val mockBooksRepository: BooksRepository = mockk()\n      AddISBNScreen(mockNavigationActions, mockBooksRepository)\n    }\n    val isbnField = composeTestRule.onNodeWithTag(\"isbn_field\")\n\n    isbnField.performTextInput(\"testEmpty\")\n    Assert.assertEquals(\n        \"\", isbnField.fetchSemanticsNode().config[SemanticsProperties.EditableText].text)\n\n    isbnField.performTextClearance()\n    isbnField.performTextInput(\"12845\")\n    Assert.assertEquals(\n        \"12845\", isbnField.fetchSemanticsNode().config[SemanticsProperties.EditableText].text)\n  }\n\n  @Suppress(\"TestFunctionName\")\n  @Test\n  fun ISBNRequestSucceeded() {\n    val dataBook =\n        DataBook(\n            uuid = UUID.randomUUID(),\n            title = \"Flowers for Algernon\",\n            author = null,\n            description = null,\n            rating = null,\n            photo = null,\n            language = BookLanguages.OTHER,\n            isbn = \"9780435123437\")\n\n    // Mock call to api\n    mockkConstructor(GoogleBookDataSource::class)\n    every { anyConstructed<GoogleBookDataSource>().getBookFromISBN(dataBook.isbn!!, any()) } answers\n        {\n          secondArg<(Result<DataBook>) -> Unit>()(Result.success(dataBook))\n        } andThenJust\n        Runs\n\n    // Mock call to repository\n    val mockBooksRepository: BooksRepository = mockk()\n    every { mockBooksRepository.addBook(matchDataBook(dataBook), any(), any()) } answers\n        {\n          secondArg<() -> Unit>()()\n        } andThenJust\n        Runs\n\n    // Mock the navigation\n    val mockNavigationActions: NavigationActions = mockk()\n    every { mockNavigationActions.navigateTo(any(TopLevelDestination::class)) } just Runs\n\n    composeTestRule.setContent { AddISBNScreen(mockNavigationActions, mockBooksRepository) }\n\n    composeTestRule.onNodeWithTag(\"isbn_field\").performTextInput(dataBook.isbn!!)\n    composeTestRule.onNodeWithTag(\"isbn_searchButton\").performClick()\n\n    verify {\n      anyConstructed<GoogleBookDataSource>().getBookFromISBN(dataBook.isbn!!, any())\n    } // Api is called\n    verify { mockBooksRepository.addBook(matchDataBook(dataBook), any(), any()) } // Book is added\n    verify {\n      mockNavigationActions.navigateTo(any(TopLevelDestination::class))\n    } // Navigation is called when book is added\n  }\n\n  @Suppress(\"TestFunctionName\")\n  @Test\n  fun ISBNAPIRequestFailed() {\n    // Mock bad call to api\n    mockkConstructor(GoogleBookDataSource::class)\n    every { anyConstructed<GoogleBookDataSource>().getBookFromISBN(any(), any()) } answers\n        {\n          secondArg<(Result<DataBook>) -> Unit>()(Result.failure(IllegalArgumentException()))\n        } andThenJust\n        Runs\n\n    // Mock the navigation\n    val mockNavigationActions: NavigationActions = mockk()\n    // Mock call to repository\n    val mockBooksRepository: BooksRepository = mockk()\n\n    composeTestRule.setContent { AddISBNScreen(mockNavigationActions, mockBooksRepository) }\n\n    composeTestRule.onNodeWithTag(\"isbn_field\").performTextInput(\"BAD_ISBN\")\n    composeTestRule.onNodeWithTag(\"isbn_searchButton\").performClick()\n\n    verify { anyConstructed<GoogleBookDataSource>().getBookFromISBN(any(), any()) } // Api is called\n    verify { toastMock.show() }\n  }\n\n  @Suppress(\"TestFunctionName\")\n  @Test\n  fun ISBNRepositoryCallFailed() {\n    val dataBook =\n        DataBook(\n            uuid = UUID.randomUUID(),\n            title = \"Flowers for Algernon\",\n            author = null,\n            description = null,\n            rating = null,\n            photo = null,\n            language = BookLanguages.OTHER,\n            isbn = \"9780435123437\")\n\n    // Mock call to api\n    mockkConstructor(GoogleBookDataSource::class)\n    every { anyConstructed<GoogleBookDataSource>().getBookFromISBN(dataBook.isbn!!, any()) } answers\n        {\n          secondArg<(Result<DataBook>) -> Unit>()(Result.success(dataBook))\n        } andThenJust\n        Runs\n\n    // Mock failed call to repository\n    val mockBooksRepository: BooksRepository = mockk()\n    every { mockBooksRepository.addBook(matchDataBook(dataBook), any(), any()) } answers\n        {\n          thirdArg<(Exception) -> Unit>()(Exception(\"Error message\"))\n        } andThenJust\n        Runs\n\n    // Mock the navigation\n    val mockNavigationActions: NavigationActions = mockk()\n\n    composeTestRule.setContent { AddISBNScreen(mockNavigationActions, mockBooksRepository) }\n\n    composeTestRule.onNodeWithTag(\"isbn_field\").performTextInput(dataBook.isbn!!)\n    composeTestRule.onNodeWithTag(\"isbn_searchButton\").performClick()\n\n    verify {\n      anyConstructed<GoogleBookDataSource>().getBookFromISBN(dataBook.isbn!!, any())\n    } // Api is called\n    verify {\n      mockBooksRepository.addBook(matchDataBook(dataBook), any(), any())\n    } // Book repository is called\n    verify { toastMock.show() } // Error is displayed\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/books/add/ISBNAddTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/books/add/ISBNAddTest.kt
--- a/app/src/androidTest/java/com/android/bookswap/ui/books/add/ISBNAddTest.kt	
+++ b/app/src/androidTest/java/com/android/bookswap/ui/books/add/ISBNAddTest.kt	
@@ -108,9 +108,9 @@
 
     // Mock call to repository
     val mockBooksRepository: BooksRepository = mockk()
-    every { mockBooksRepository.addBook(matchDataBook(dataBook), any(), any()) } answers
+    every { mockBooksRepository.addBook(matchDataBook(dataBook), any()) } answers
         {
-          secondArg<() -> Unit>()()
+          secondArg<(Result<Unit>) -> Unit>()(Result.success(Unit))
         } andThenJust
         Runs
 
@@ -126,7 +126,7 @@
     verify {
       anyConstructed<GoogleBookDataSource>().getBookFromISBN(dataBook.isbn!!, any())
     } // Api is called
-    verify { mockBooksRepository.addBook(matchDataBook(dataBook), any(), any()) } // Book is added
+    verify { mockBooksRepository.addBook(matchDataBook(dataBook), any()) } // Book is added
     verify {
       mockNavigationActions.navigateTo(any(TopLevelDestination::class))
     } // Navigation is called when book is added
@@ -181,9 +181,9 @@
 
     // Mock failed call to repository
     val mockBooksRepository: BooksRepository = mockk()
-    every { mockBooksRepository.addBook(matchDataBook(dataBook), any(), any()) } answers
+    every { mockBooksRepository.addBook(matchDataBook(dataBook), any()) } answers
         {
-          thirdArg<(Exception) -> Unit>()(Exception("Error message"))
+          secondArg<(Result<Unit>) -> Unit>()(Result.failure(Exception("Error message")))
         } andThenJust
         Runs
 
@@ -199,7 +199,7 @@
       anyConstructed<GoogleBookDataSource>().getBookFromISBN(dataBook.isbn!!, any())
     } // Api is called
     verify {
-      mockBooksRepository.addBook(matchDataBook(dataBook), any(), any())
+      mockBooksRepository.addBook(matchDataBook(dataBook), any())
     } // Book repository is called
     verify { toastMock.show() } // Error is displayed
   }
Index: app/src/androidTest/java/com/android/bookswap/screen/UserProfileScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.screen\n\nimport androidx.compose.ui.test.SemanticsNodeInteractionsProvider\nimport androidx.compose.ui.test.hasTestTag\nimport io.github.kakaocup.compose.node.element.ComposeScreen\nimport io.github.kakaocup.compose.node.element.KNode\n\nclass UserProfileScreen(semanticsProvider: SemanticsNodeInteractionsProvider) :\n    ComposeScreen<UserProfileScreen>(\n        semanticsProvider = semanticsProvider,\n        viewBuilderAction = { hasTestTag(\"profileScreenContainer\") }) {\n\n  val titleTxt: KNode = child { hasTestTag(\"profileTitleTxt\") }\n  val fullNameTxt: KNode = child { hasTestTag(\"fullNameTxt\") }\n  val emailTxt: KNode = child { hasTestTag(\"emailTxt\") }\n  val phoneNumberTxt: KNode = child { hasTestTag(\"phoneNumberTxt\") }\n  val addressTxt: KNode = child { hasTestTag(\"addressTxt\") }\n  val editProfileBtn: KNode = child { hasTestTag(\"editProfileBtn\") }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/screen/UserProfileScreen.kt b/app/src/androidTest/java/com/android/bookswap/screen/UserProfileScreen.kt
--- a/app/src/androidTest/java/com/android/bookswap/screen/UserProfileScreen.kt	
+++ b/app/src/androidTest/java/com/android/bookswap/screen/UserProfileScreen.kt	
@@ -10,7 +10,7 @@
         semanticsProvider = semanticsProvider,
         viewBuilderAction = { hasTestTag("profileScreenContainer") }) {
 
-  val titleTxt: KNode = child { hasTestTag("profileTitleTxt") }
+  val titleTxt: KNode = child { hasTestTag("TopAppBar_Title") }
   val fullNameTxt: KNode = child { hasTestTag("fullNameTxt") }
   val emailTxt: KNode = child { hasTestTag("emailTxt") }
   val phoneNumberTxt: KNode = child { hasTestTag("phoneNumberTxt") }
Index: app/src/test/java/com/android/bookswap/data/DataUserTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.data\n\nimport com.android.bookswap.data.repository.UsersRepository\nimport com.android.bookswap.model.UserViewModel\nimport org.junit.Assert.assertEquals\nimport org.junit.Assert.assertNotEquals\nimport org.junit.Before\nimport org.junit.Test\n\nclass DataUserTest {\n\n  private lateinit var userVM: UserViewModel\n\n  @Before\n  fun setUp() {\n    userVM = UserViewModel(\"usr_01_jd\", MockUserRepo())\n  }\n\n  @Test\n  fun checkCreate() {\n    val u1 = DataUser()\n    assertEquals(\"\", u1.greeting)\n    assertEquals(\"\", u1.firstName)\n    assertEquals(\"\", u1.lastName)\n    assertEquals(\"\", u1.email)\n    assertEquals(\"\", u1.phoneNumber)\n    assertEquals(0.0, u1.latitude, 0.000001)\n    assertEquals(0.0, u1.longitude, 0.000001)\n    assertEquals(\"\", u1.profilePictureUrl)\n    assertEquals(\"\", u1.userId)\n  }\n\n  @Test\n  fun checkAssign() {\n    val u1 =\n        DataUser(\n            \"M.\",\n            \"John\",\n            \"Doe\",\n            \"john.doe@example.com\",\n            \"+41223456789\",\n            1.0,\n            7.0,\n            \"dummyPic.png\",\n            \"usr_01_jd\")\n\n    assertEquals(\"M.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n  }\n\n  @Test\n  fun checkUpdate_ExistingUser() {\n    userVM.updateUser(\n        DataUser(\n            \"M.\",\n            \"John\",\n            \"Doe\",\n            \"john.doe@example.com\",\n            \"+41223456789\",\n            1.0,\n            7.0,\n            \"dummyPic.png\",\n            \"usr_01_jd\"))\n\n    val u1 = userVM.getUser()\n\n    assertEquals(\"M.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n\n    assert(userVM.isStored)\n  }\n\n  @Test\n  fun checkUpdate_NotExistentUser() {\n    userVM.updateUser(\n        DataUser(\n            \"M.\",\n            \"John\",\n            \"Doe\",\n            \"john.doe@example.com\",\n            \"+41223456789\",\n            1.0,\n            7.0,\n            \"dummyPic.png\",\n            \"usr_04_jd\"))\n\n    val u1 = userVM.getUser()\n\n    assertEquals(\"M.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_04_jd\", u1.userId)\n\n    assert(!userVM.isStored)\n  }\n\n  @Test\n  fun checkUpdate_greeting() {\n    userVM.updateUser(\n        DataUser(\n            \"M.\",\n            \"John\",\n            \"Doe\",\n            \"john.doe@example.com\",\n            \"+41223456789\",\n            1.0,\n            7.0,\n            \"dummyPic.png\",\n            \"usr_01_jd\"))\n\n    var u1 = userVM.getUser()\n\n    assertEquals(\"M.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n\n    userVM.updateUser(greeting = \"Mr.\")\n    u1 = userVM.getUser(true)\n\n    assertNotEquals(\"M.\", u1.greeting)\n    assertEquals(\"Mr.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n  }\n\n  @Test\n  fun checkUpdate_firstName() {\n    userVM.updateUser(\n        DataUser(\n            \"M.\",\n            \"John\",\n            \"Doe\",\n            \"john.doe@example.com\",\n            \"+41223456789\",\n            1.0,\n            7.0,\n            \"dummyPic.png\",\n            \"usr_01_jd\"))\n\n    var u1 = userVM.getUser()\n\n    assertEquals(\"M.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n\n    userVM.updateUser(firstName = \"Joe\")\n    u1 = userVM.getUser(true)\n\n    assertEquals(\"M.\", u1.greeting)\n    assertNotEquals(\"John\", u1.firstName)\n    assertEquals(\"Joe\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n  }\n\n  @Test\n  fun checkUpdate_lastName() {\n    userVM.updateUser(\n        DataUser(\n            \"M.\",\n            \"John\",\n            \"Doe\",\n            \"john.doe@example.com\",\n            \"+41223456789\",\n            1.0,\n            7.0,\n            \"dummyPic.png\",\n            \"usr_01_jd\"))\n\n    var u1 = userVM.getUser()\n\n    assertEquals(\"M.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n\n    userVM.updateUser(lastName = \"Douse\")\n    u1 = userVM.getUser(true)\n\n    assertEquals(\"M.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertNotEquals(\"Doe\", u1.lastName)\n    assertEquals(\"Douse\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n  }\n\n  @Test\n  fun checkUpdate_email() {\n    userVM.updateUser(\n        DataUser(\n            \"M.\",\n            \"John\",\n            \"Doe\",\n            \"john.doe@example.com\",\n            \"+41223456789\",\n            1.0,\n            7.0,\n            \"dummyPic.png\",\n            \"usr_01_jd\"))\n\n    var u1 = userVM.getUser()\n\n    assertEquals(\"M.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n\n    userVM.updateUser(email = \"john.doe@example.swiss\")\n    u1 = userVM.getUser(true)\n\n    assertEquals(\"M.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertNotEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"john.doe@example.swiss\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n  }\n\n  @Test\n  fun checkUpdate_phoneNumber() {\n    userVM.updateUser(\n        DataUser(\n            \"M.\",\n            \"John\",\n            \"Doe\",\n            \"john.doe@example.com\",\n            \"+41223456789\",\n            1.0,\n            7.0,\n            \"dummyPic.png\",\n            \"usr_01_jd\"))\n\n    var u1 = userVM.getUser()\n\n    assertEquals(\"M.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n\n    userVM.updateUser(phone = \"+41234567890\")\n    u1 = userVM.getUser(true)\n\n    assertEquals(\"M.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertNotEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(\"+41234567890\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n  }\n\n  @Test\n  fun checkUpdate_latitude() {\n    userVM.updateUser(\n        DataUser(\n            \"M.\",\n            \"John\",\n            \"Doe\",\n            \"john.doe@example.com\",\n            \"+41223456789\",\n            1.0,\n            7.0,\n            \"dummyPic.png\",\n            \"usr_01_jd\"))\n\n    var u1 = userVM.getUser()\n\n    assertEquals(\"M.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n\n    userVM.updateUser(latitude = 2.7)\n    u1 = userVM.getUser(true)\n\n    assertEquals(\"M.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertNotEquals(1.0, u1.latitude)\n    assertEquals(2.7, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n  }\n\n  @Test\n  fun checkUpdate_longitude() {\n    userVM.updateUser(\n        DataUser(\n            \"M.\",\n            \"John\",\n            \"Doe\",\n            \"john.doe@example.com\",\n            \"+41223456789\",\n            1.0,\n            7.0,\n            \"dummyPic.png\",\n            \"usr_01_jd\"))\n\n    var u1 = userVM.getUser()\n\n    assertEquals(\"M.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n\n    userVM.updateUser(longitude = 6.3)\n    u1 = userVM.getUser(true)\n\n    assertEquals(\"M.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertNotEquals(7.0, u1.longitude)\n    assertEquals(6.3, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n  }\n\n  @Test\n  fun checkUpdate_profilePictureURI() {\n    userVM.updateUser(\n        DataUser(\n            \"M.\",\n            \"John\",\n            \"Doe\",\n            \"john.doe@example.com\",\n            \"+41223456789\",\n            1.0,\n            7.0,\n            \"dummyPic.png\",\n            \"usr_01_jd\"))\n\n    var u1 = userVM.getUser()\n\n    assertEquals(\"M.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n\n    userVM.updateUser(picURL = \"pl4c3h0ld3rP1c.jpg\")\n    u1 = userVM.getUser(true)\n\n    assertEquals(\"M.\", u1.greeting)\n    assertEquals(\"John\", u1.firstName)\n    assertEquals(\"Doe\", u1.lastName)\n    assertEquals(\"john.doe@example.com\", u1.email)\n    assertEquals(\"+41223456789\", u1.phoneNumber)\n    assertEquals(1.0, u1.latitude, 0.000001)\n    assertEquals(7.0, u1.longitude, 0.000001)\n    assertNotEquals(\"dummyPic.png\", u1.profilePictureUrl)\n    assertEquals(\"pl4c3h0ld3rP1c.jpg\", u1.profilePictureUrl)\n    assertEquals(\"usr_01_jd\", u1.userId)\n  }\n\n  @Test\n  fun checkString() {\n    val u1 =\n        DataUser(\n            \"M.\", \"John\", \"Doe\", \"john.doe@example.com\", \"+41223456789\", 0.0, 0.0, \"\", \"usr_01_jd\")\n    assertEquals(\"M. John Doe\", u1.printFullname())\n  }\n}\n\nclass MockUserRepo : UsersRepository {\n  val mockUserList =\n      mutableMapOf(\n          \"usr_01_jd\" to\n              DataUser(\n                  \"M.\",\n                  \"John\",\n                  \"Doe\",\n                  \"john.doe@example.com\",\n                  \"+41223456789\",\n                  0.0,\n                  0.0,\n                  \"\",\n                  \"usr_01_jd\"),\n          \"usr_02_jd\" to\n              DataUser(\n                  \"Mr.\",\n                  \"Jones\",\n                  \"Douse\",\n                  \"jon.doe@example.com\",\n                  \"+41234567890\",\n                  0.0,\n                  0.0,\n                  \"\",\n                  \"usr_02_jd\"),\n          \"usr_03_jd\" to\n              DataUser(\n                  \"Ms.\",\n                  \"Jo\",\n                  \"Doe\",\n                  \"jo.doe@example.com\",\n                  \"+41765432198\",\n                  0.0,\n                  0.0,\n                  \"\",\n                  \"usr_03_jd\"),\n      )\n\n  override fun getUsers(callback: (Result<List<DataUser>>) -> Unit) {\n    callback(Result.success(mockUserList.values.toList()))\n  }\n\n  override fun getUser(uuid: String, callback: (Result<DataUser>) -> Unit) {\n    val usr = mockUserList.get(uuid)\n    if (usr != null) {\n      callback(Result.success(usr))\n    } else {\n      callback(Result.failure(Throwable(\"User not found\")))\n    }\n  }\n\n  override fun addUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit) {\n    mockUserList.put(dataUser.userId, dataUser)\n  }\n\n  override fun updateUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit) {\n    getUser(dataUser.userId) { result ->\n      result.fold(\n          {\n            mockUserList.put(dataUser.userId, dataUser)\n            callback(Result.success(Unit))\n          },\n          { callback(Result.failure(it)) })\n    }\n  }\n\n  override fun deleteUser(uuid: String, callback: (Result<Unit>) -> Unit) {\n    mockUserList.remove(uuid)\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/DataUserTest.kt b/app/src/test/java/com/android/bookswap/data/DataUserTest.kt
--- a/app/src/test/java/com/android/bookswap/data/DataUserTest.kt	
+++ b/app/src/test/java/com/android/bookswap/data/DataUserTest.kt	
@@ -2,521 +2,123 @@
 
 import com.android.bookswap.data.repository.UsersRepository
 import com.android.bookswap.model.UserViewModel
+import io.mockk.Runs
+import io.mockk.andThenJust
+import io.mockk.every
+import io.mockk.mockk
+import io.mockk.verify
+import java.util.UUID
 import org.junit.Assert.assertEquals
-import org.junit.Assert.assertNotEquals
-import org.junit.Before
+import org.junit.Assert.assertNotNull
+import org.junit.Assert.assertTrue
 import org.junit.Test
 
 class DataUserTest {
 
-  private lateinit var userVM: UserViewModel
-
-  @Before
-  fun setUp() {
-    userVM = UserViewModel("usr_01_jd", MockUserRepo())
-  }
-
-  @Test
-  fun checkCreate() {
-    val u1 = DataUser()
-    assertEquals("", u1.greeting)
-    assertEquals("", u1.firstName)
-    assertEquals("", u1.lastName)
-    assertEquals("", u1.email)
-    assertEquals("", u1.phoneNumber)
-    assertEquals(0.0, u1.latitude, 0.000001)
-    assertEquals(0.0, u1.longitude, 0.000001)
-    assertEquals("", u1.profilePictureUrl)
-    assertEquals("", u1.userId)
-  }
-
-  @Test
-  fun checkAssign() {
-    val u1 =
-        DataUser(
-            "M.",
-            "John",
-            "Doe",
-            "john.doe@example.com",
-            "+41223456789",
-            1.0,
-            7.0,
-            "dummyPic.png",
-            "usr_01_jd")
-
-    assertEquals("M.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
-  }
-
-  @Test
-  fun checkUpdate_ExistingUser() {
-    userVM.updateUser(
-        DataUser(
-            "M.",
-            "John",
-            "Doe",
-            "john.doe@example.com",
-            "+41223456789",
-            1.0,
-            7.0,
-            "dummyPic.png",
-            "usr_01_jd"))
-
-    val u1 = userVM.getUser()
-
-    assertEquals("M.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
-
-    assert(userVM.isStored)
-  }
-
-  @Test
-  fun checkUpdate_NotExistentUser() {
-    userVM.updateUser(
-        DataUser(
-            "M.",
-            "John",
-            "Doe",
-            "john.doe@example.com",
-            "+41223456789",
-            1.0,
-            7.0,
-            "dummyPic.png",
-            "usr_04_jd"))
-
-    val u1 = userVM.getUser()
-
-    assertEquals("M.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_04_jd", u1.userId)
-
-    assert(!userVM.isStored)
-  }
-
-  @Test
-  fun checkUpdate_greeting() {
-    userVM.updateUser(
-        DataUser(
-            "M.",
-            "John",
-            "Doe",
-            "john.doe@example.com",
-            "+41223456789",
-            1.0,
-            7.0,
-            "dummyPic.png",
-            "usr_01_jd"))
-
-    var u1 = userVM.getUser()
-
-    assertEquals("M.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
+  private val mockUsersRepo: UsersRepository = mockk()
 
-    userVM.updateUser(greeting = "Mr.")
-    u1 = userVM.getUser(true)
-
-    assertNotEquals("M.", u1.greeting)
-    assertEquals("Mr.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
-  }
-
-  @Test
-  fun checkUpdate_firstName() {
-    userVM.updateUser(
-        DataUser(
-            "M.",
-            "John",
-            "Doe",
-            "john.doe@example.com",
-            "+41223456789",
-            1.0,
-            7.0,
-            "dummyPic.png",
-            "usr_01_jd"))
-
-    var u1 = userVM.getUser()
-
-    assertEquals("M.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
-
-    userVM.updateUser(firstName = "Joe")
-    u1 = userVM.getUser(true)
-
-    assertEquals("M.", u1.greeting)
-    assertNotEquals("John", u1.firstName)
-    assertEquals("Joe", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
-  }
-
-  @Test
-  fun checkUpdate_lastName() {
-    userVM.updateUser(
-        DataUser(
-            "M.",
-            "John",
-            "Doe",
-            "john.doe@example.com",
-            "+41223456789",
-            1.0,
-            7.0,
-            "dummyPic.png",
-            "usr_01_jd"))
-
-    var u1 = userVM.getUser()
-
-    assertEquals("M.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
-
-    userVM.updateUser(lastName = "Douse")
-    u1 = userVM.getUser(true)
-
-    assertEquals("M.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertNotEquals("Doe", u1.lastName)
-    assertEquals("Douse", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
-  }
+  private val standardUser =
+      DataUser(
+          userUUID = UUID.randomUUID(),
+          greeting = "M.",
+          firstName = "John",
+          lastName = "Doe",
+          email = "john.doe@example.com",
+          phoneNumber = "+41223456789",
+          latitude = 1.0,
+          longitude = 7.0,
+          profilePictureUrl = "dummyPic.png",
+          bookList = listOf(UUID(1000, 2000)),
+          googleUid = "googleUid")
 
   @Test
-  fun checkUpdate_email() {
-    userVM.updateUser(
-        DataUser(
-            "M.",
-            "John",
-            "Doe",
-            "john.doe@example.com",
-            "+41223456789",
-            1.0,
-            7.0,
-            "dummyPic.png",
-            "usr_01_jd"))
-
-    var u1 = userVM.getUser()
-
-    assertEquals("M.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
-
-    userVM.updateUser(email = "john.doe@example.swiss")
-    u1 = userVM.getUser(true)
-
-    assertEquals("M.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertNotEquals("john.doe@example.com", u1.email)
-    assertEquals("john.doe@example.swiss", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
+  fun checkAssign() {
+    assertNotNull(standardUser.userUUID)
+    assertEquals("M.", standardUser.greeting)
+    assertEquals("John", standardUser.firstName)
+    assertEquals("Doe", standardUser.lastName)
+    assertEquals("john.doe@example.com", standardUser.email)
+    assertEquals("+41223456789", standardUser.phoneNumber)
+    assertEquals(1.0, standardUser.latitude, 0.000001)
+    assertEquals(7.0, standardUser.longitude, 0.000001)
+    assertEquals("dummyPic.png", standardUser.profilePictureUrl)
+    assertEquals(listOf(UUID(1000, 2000)), standardUser.bookList)
+    assertEquals("googleUid", standardUser.googleUid)
   }
 
   @Test
-  fun checkUpdate_phoneNumber() {
-    userVM.updateUser(
-        DataUser(
-            "M.",
-            "John",
-            "Doe",
-            "john.doe@example.com",
-            "+41223456789",
-            1.0,
-            7.0,
-            "dummyPic.png",
-            "usr_01_jd"))
+  fun viewModelFetch() {
+    val userVM = UserViewModel(standardUser.userUUID, mockUsersRepo)
+    assertTrue(!userVM.isStored)
 
-    var u1 = userVM.getUser()
+    every { mockUsersRepo.getUser(standardUser.userUUID, any()) } answers
+        {
+          secondArg<(Result<DataUser>) -> Unit>()(Result.success(standardUser))
+        } andThenJust
+        Runs
 
-    assertEquals("M.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
+    val result = userVM.getUser()
 
-    userVM.updateUser(phone = "+41234567890")
-    u1 = userVM.getUser(true)
+    assertEquals(standardUser, result)
+    assertTrue(userVM.isStored)
 
-    assertEquals("M.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertNotEquals("+41223456789", u1.phoneNumber)
-    assertEquals("+41234567890", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
+    // Verify that second calls does not fetch again
+    userVM.getUser()
+    verify(exactly = 1) { mockUsersRepo.getUser(any(), any()) }
   }
 
   @Test
-  fun checkUpdate_latitude() {
+  fun viewModelUpdateCorrectly() {
+    val updatedUser =
+        standardUser.copy(
+            greeting = "Mme.",
+            firstName = "Alice",
+            email = "alice.doe@example.com",
+            longitude = 5.0,
+            latitude = 3.2,
+            phoneNumber = "+4122346666",
+            profilePictureUrl = "zzz",
+            bookList = listOf(UUID(10, 5)),
+            googleUid = "googleUid")
+
+    every { mockUsersRepo.updateUser(any(), any()) } answers
+        {
+          secondArg<(Result<Unit>) -> Unit>()(Result.success(Unit))
+        }
+
+    val userVM = UserViewModel(standardUser.userUUID, mockUsersRepo)
     userVM.updateUser(
-        DataUser(
-            "M.",
-            "John",
-            "Doe",
-            "john.doe@example.com",
-            "+41223456789",
-            1.0,
-            7.0,
-            "dummyPic.png",
-            "usr_01_jd"))
-
-    var u1 = userVM.getUser()
+        updatedUser.greeting,
+        updatedUser.firstName,
+        updatedUser.lastName,
+        updatedUser.email,
+        updatedUser.phoneNumber,
+        updatedUser.latitude,
+        updatedUser.longitude,
+        updatedUser.profilePictureUrl,
+        updatedUser.bookList,
+        updatedUser.googleUid)
 
-    assertEquals("M.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
+    assertTrue(userVM.isStored)
 
-    userVM.updateUser(latitude = 2.7)
-    u1 = userVM.getUser(true)
-
-    assertEquals("M.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertNotEquals(1.0, u1.latitude)
-    assertEquals(2.7, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
-  }
+    // Verify it fails correctly
+    every { mockUsersRepo.updateUser(any(), any()) } answers
+        {
+          secondArg<(Result<Unit>) -> Unit>()(Result.failure(Exception()))
+        }
 
-  @Test
-  fun checkUpdate_longitude() {
     userVM.updateUser(
-        DataUser(
-            "M.",
-            "John",
-            "Doe",
-            "john.doe@example.com",
-            "+41223456789",
-            1.0,
-            7.0,
-            "dummyPic.png",
-            "usr_01_jd"))
-
-    var u1 = userVM.getUser()
-
-    assertEquals("M.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
-
-    userVM.updateUser(longitude = 6.3)
-    u1 = userVM.getUser(true)
-
-    assertEquals("M.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertNotEquals(7.0, u1.longitude)
-    assertEquals(6.3, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
-  }
-
-  @Test
-  fun checkUpdate_profilePictureURI() {
-    userVM.updateUser(
-        DataUser(
-            "M.",
-            "John",
-            "Doe",
-            "john.doe@example.com",
-            "+41223456789",
-            1.0,
-            7.0,
-            "dummyPic.png",
-            "usr_01_jd"))
-
-    var u1 = userVM.getUser()
-
-    assertEquals("M.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
+        updatedUser.greeting,
+        updatedUser.firstName,
+        updatedUser.lastName,
+        updatedUser.email,
+        updatedUser.phoneNumber,
+        updatedUser.latitude,
+        updatedUser.longitude,
+        updatedUser.profilePictureUrl,
+        updatedUser.bookList,
+        updatedUser.googleUid)
 
-    userVM.updateUser(picURL = "pl4c3h0ld3rP1c.jpg")
-    u1 = userVM.getUser(true)
-
-    assertEquals("M.", u1.greeting)
-    assertEquals("John", u1.firstName)
-    assertEquals("Doe", u1.lastName)
-    assertEquals("john.doe@example.com", u1.email)
-    assertEquals("+41223456789", u1.phoneNumber)
-    assertEquals(1.0, u1.latitude, 0.000001)
-    assertEquals(7.0, u1.longitude, 0.000001)
-    assertNotEquals("dummyPic.png", u1.profilePictureUrl)
-    assertEquals("pl4c3h0ld3rP1c.jpg", u1.profilePictureUrl)
-    assertEquals("usr_01_jd", u1.userId)
-  }
-
-  @Test
-  fun checkString() {
-    val u1 =
-        DataUser(
-            "M.", "John", "Doe", "john.doe@example.com", "+41223456789", 0.0, 0.0, "", "usr_01_jd")
-    assertEquals("M. John Doe", u1.printFullname())
-  }
-}
-
-class MockUserRepo : UsersRepository {
-  val mockUserList =
-      mutableMapOf(
-          "usr_01_jd" to
-              DataUser(
-                  "M.",
-                  "John",
-                  "Doe",
-                  "john.doe@example.com",
-                  "+41223456789",
-                  0.0,
-                  0.0,
-                  "",
-                  "usr_01_jd"),
-          "usr_02_jd" to
-              DataUser(
-                  "Mr.",
-                  "Jones",
-                  "Douse",
-                  "jon.doe@example.com",
-                  "+41234567890",
-                  0.0,
-                  0.0,
-                  "",
-                  "usr_02_jd"),
-          "usr_03_jd" to
-              DataUser(
-                  "Ms.",
-                  "Jo",
-                  "Doe",
-                  "jo.doe@example.com",
-                  "+41765432198",
-                  0.0,
-                  0.0,
-                  "",
-                  "usr_03_jd"),
-      )
-
-  override fun getUsers(callback: (Result<List<DataUser>>) -> Unit) {
-    callback(Result.success(mockUserList.values.toList()))
-  }
-
-  override fun getUser(uuid: String, callback: (Result<DataUser>) -> Unit) {
-    val usr = mockUserList.get(uuid)
-    if (usr != null) {
-      callback(Result.success(usr))
-    } else {
-      callback(Result.failure(Throwable("User not found")))
-    }
-  }
-
-  override fun addUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit) {
-    mockUserList.put(dataUser.userId, dataUser)
-  }
-
-  override fun updateUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit) {
-    getUser(dataUser.userId) { result ->
-      result.fold(
-          {
-            mockUserList.put(dataUser.userId, dataUser)
-            callback(Result.success(Unit))
-          },
-          { callback(Result.failure(it)) })
-    }
-  }
-
-  override fun deleteUser(uuid: String, callback: (Result<Unit>) -> Unit) {
-    mockUserList.remove(uuid)
+    assertTrue(!userVM.isStored)
   }
 }
Index: app/src/main/java/com/android/bookswap/ui/books/add/AddISBNScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.books.add\n\nimport android.util.Log\nimport android.widget.Toast\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Search\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.MediumTopAppBar\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBarDefaults\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.platform.testTag\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport com.android.bookswap.data.repository.BooksRepository\nimport com.android.bookswap.data.source.api.GoogleBookDataSource\nimport com.android.bookswap.ui.components.BackButtonComponent\nimport com.android.bookswap.ui.components.ButtonComponent\nimport com.android.bookswap.ui.components.FieldComponent\nimport com.android.bookswap.ui.navigation.NavigationActions\nimport com.android.bookswap.ui.navigation.TopLevelDestinations\nimport com.android.bookswap.ui.profile.ProfileIcon\nimport com.android.bookswap.ui.theme.ColorVariable\n\n/** This is the main screen for the chat feature. It displays the list of messages */\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun AddISBNScreen(navigationActions: NavigationActions, booksRepository: BooksRepository) {\n  val context = LocalContext.current\n  Scaffold(\n      topBar = {\n        MediumTopAppBar(\n            colors =\n                TopAppBarDefaults.topAppBarColors(\n                    containerColor = ColorVariable.BackGround,\n                ),\n            title = {\n              Box(modifier = Modifier) {\n                Row(\n                    horizontalArrangement = Arrangement.Center,\n                    modifier = Modifier.fillMaxWidth(0.85f)) {\n                      BackButtonComponent(navigationActions)\n                      Text(\n                          text = \"Search ISBN\",\n                          style =\n                              TextStyle(\n                                  fontSize = 30.sp,\n                                  lineHeight = 20.sp,\n                                  fontWeight = FontWeight(700),\n                                  color = ColorVariable.Accent,\n                                  letterSpacing = 0.3.sp,\n                              ),\n                          modifier = Modifier.padding(top = 4.dp))\n                    }\n              }\n            },\n            actions = { Box(modifier = Modifier.padding(top = 30.dp)) { ProfileIcon() } })\n      },\n      content = { pv ->\n        Box(\n            modifier =\n                Modifier.fillMaxSize()\n                    .padding(pv)\n                    .padding()\n                    .background(color = ColorVariable.BackGround)) {\n              var isbn by remember { mutableStateOf(\"\") }\n\n              Column(\n                  modifier = Modifier.fillMaxWidth().padding(top = 40.dp),\n                  horizontalAlignment = Alignment.CenterHorizontally,\n                  verticalArrangement = Arrangement.spacedBy(45.dp)) {\n                    FieldComponent(\n                        modifier = Modifier.testTag(\"isbn_field\"),\n                        labelText = \"ISBN*\",\n                        value = isbn) {\n                          if (it.all { c -> c.isDigit() } && it.length <= 13) {\n                            isbn = it\n                          }\n                        }\n                    ButtonComponent(\n                        modifier = Modifier.testTag(\"isbn_searchButton\"),\n                        onClick = {\n                          GoogleBookDataSource(context).getBookFromISBN(isbn) { result ->\n                            if (result.isFailure) {\n                              Toast.makeText(context, \"Search unsuccessful\", Toast.LENGTH_LONG)\n                                  .show()\n                              Log.e(\"AddBook\", result.exceptionOrNull().toString())\n                            } else {\n                              booksRepository.addBook(\n                                  result.getOrThrow(),\n                                  { navigationActions.navigateTo(TopLevelDestinations.NEW_BOOK) },\n                                  { error ->\n                                    Log.e(\"AddBook\", error.toString())\n                                    Toast.makeText(context, error.message, Toast.LENGTH_LONG).show()\n                                  })\n                            }\n                          }\n                        }) {\n                          Row(Modifier.fillMaxWidth()) {\n                            Text(\"Search\", style = TextStyle(color = Color.White))\n                            Spacer(Modifier.weight(1f))\n                            Icon(\n                                Icons.Filled.Search,\n                                contentDescription = \"Search icon\",\n                                tint = Color.White,\n                            )\n                          }\n                        }\n                  }\n            }\n      })\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/books/add/AddISBNScreen.kt b/app/src/main/java/com/android/bookswap/ui/books/add/AddISBNScreen.kt
--- a/app/src/main/java/com/android/bookswap/ui/books/add/AddISBNScreen.kt	
+++ b/app/src/main/java/com/android/bookswap/ui/books/add/AddISBNScreen.kt	
@@ -15,10 +15,8 @@
 import androidx.compose.material.icons.filled.Search
 import androidx.compose.material3.ExperimentalMaterial3Api
 import androidx.compose.material3.Icon
-import androidx.compose.material3.MediumTopAppBar
 import androidx.compose.material3.Scaffold
 import androidx.compose.material3.Text
-import androidx.compose.material3.TopAppBarDefaults
 import androidx.compose.runtime.Composable
 import androidx.compose.runtime.getValue
 import androidx.compose.runtime.mutableStateOf
@@ -30,53 +28,28 @@
 import androidx.compose.ui.platform.LocalContext
 import androidx.compose.ui.platform.testTag
 import androidx.compose.ui.text.TextStyle
-import androidx.compose.ui.text.font.FontWeight
 import androidx.compose.ui.unit.dp
-import androidx.compose.ui.unit.sp
 import com.android.bookswap.data.repository.BooksRepository
 import com.android.bookswap.data.source.api.GoogleBookDataSource
-import com.android.bookswap.ui.components.BackButtonComponent
 import com.android.bookswap.ui.components.ButtonComponent
 import com.android.bookswap.ui.components.FieldComponent
 import com.android.bookswap.ui.navigation.NavigationActions
 import com.android.bookswap.ui.navigation.TopLevelDestinations
-import com.android.bookswap.ui.profile.ProfileIcon
 import com.android.bookswap.ui.theme.ColorVariable
 
 /** This is the main screen for the chat feature. It displays the list of messages */
 @OptIn(ExperimentalMaterial3Api::class)
 @Composable
-fun AddISBNScreen(navigationActions: NavigationActions, booksRepository: BooksRepository) {
+fun AddISBNScreen(
+    navigationActions: NavigationActions,
+    booksRepository: BooksRepository,
+    topAppBar: @Composable () -> Unit = {},
+    bottomAppBar: @Composable () -> Unit = {}
+) {
   val context = LocalContext.current
   Scaffold(
-      topBar = {
-        MediumTopAppBar(
-            colors =
-                TopAppBarDefaults.topAppBarColors(
-                    containerColor = ColorVariable.BackGround,
-                ),
-            title = {
-              Box(modifier = Modifier) {
-                Row(
-                    horizontalArrangement = Arrangement.Center,
-                    modifier = Modifier.fillMaxWidth(0.85f)) {
-                      BackButtonComponent(navigationActions)
-                      Text(
-                          text = "Search ISBN",
-                          style =
-                              TextStyle(
-                                  fontSize = 30.sp,
-                                  lineHeight = 20.sp,
-                                  fontWeight = FontWeight(700),
-                                  color = ColorVariable.Accent,
-                                  letterSpacing = 0.3.sp,
-                              ),
-                          modifier = Modifier.padding(top = 4.dp))
-                    }
-              }
-            },
-            actions = { Box(modifier = Modifier.padding(top = 30.dp)) { ProfileIcon() } })
-      },
+      topBar = topAppBar,
+      bottomBar = bottomAppBar,
       content = { pv ->
         Box(
             modifier =
@@ -109,10 +82,15 @@
                             } else {
                               booksRepository.addBook(
                                   result.getOrThrow(),
-                                  { navigationActions.navigateTo(TopLevelDestinations.NEW_BOOK) },
-                                  { error ->
-                                    Log.e("AddBook", error.toString())
-                                    Toast.makeText(context, error.message, Toast.LENGTH_LONG).show()
+                                  callback = { res ->
+                                    if (res.isSuccess) {
+                                      navigationActions.navigateTo(TopLevelDestinations.NEW_BOOK)
+                                    } else {
+                                      val error = res.exceptionOrNull()!!
+                                      Log.e("AddBook", res.toString())
+                                      Toast.makeText(context, error.message, Toast.LENGTH_LONG)
+                                          .show()
+                                    }
                                   })
                             }
                           }
Index: gradle/libs.versions.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[versions]\nagp = \"8.3.0\"\nfirebaseBom = \"33.4.0\"\nkotlin = \"1.8.10\"\ncoreKtx = \"1.12.0\"\nktfmt = \"0.17.0\"\njunit = \"4.13.2\"\njunitVersion = \"1.1.5\"\nespressoCore = \"3.5.1\"\nappcompat = \"1.6.1\"\nmaterial = \"1.11.0\"\ncomposeBom = \"2024.02.02\"\ncomposeActivity = \"1.8.2\"\ncomposeViewModel = \"2.7.0\"\nlifecycleRuntimeKtx = \"2.7.0\"\nkaspresso = \"1.5.5\"\nmockitoAndroid = \"5.14.2\"\nmockitoCore = \"5.14.2\"\nmockitoInline = \"5.2.0\"\nmockitoKotlin = \"5.4.0\"\nmockk = \"1.13.13\"\nmockk-android = \"1.13.13\"\nrobolectric = \"4.11.1\"\nsonar = \"4.4.1.3373\"\nfirebaseFirestoreKtx = \"25.1.0\"\n\n# gradle/libs.versions.toml\ngms = \"4.4.2\"\n\n# Firebase Libraries\nfirebaseAnalytics = \"21.0.0\"\nfirebaseAuth = \"23.0.0\"\nfirebaseAuthKtx = \"23.0.0\"\nfirebaseDatabaseKtx = \"21.0.0\"\nfirebaseFirestore = \"25.1.0\"\nfirebaseUiAuth = \"8.0.0\"\n\n# Google Service and Maps\nplayServicesAuth = \"21.2.0\"\nplayServicesMaps = \"19.0.0\"\nespressoIntents = \"3.6.1\"\nnavigationCompose = \"2.8.2\"\nvolley = \"1.2.1\" # HTTP request\njson = \"20240303\"\nfirebaseMessagingKtx = \"24.0.2\" #Json parsing\nmapsCompose = \"4.3.3\"\nmapsComposeUtils = \"4.3.0\"\n\nbyteBuddy= \"1.15.4\"\nfirebaseStorageKtx = \"21.0.1\"\n\n[libraries]\ngoogle-play-services-location = { group = \"com.google.android.gms\", name = \"play-services-location\", version = \"19.0.1\" }\n# Firebase Libraries\n\nfirebase-analytics = { module = \"com.google.firebase:firebase-analytics\", version.ref = \"firebaseAnalytics\" }\nfirebase-bom = { module = \"com.google.firebase:firebase-bom\", version.ref = \"firebaseBom\" }\n\nfirebase-firestore-ktx = { group = \"com.google.firebase\", name = \"firebase-firestore-ktx\", version.ref = \"firebaseFirestoreKtx\" }\n\nfirebase-auth-ktx = { group = \"com.google.firebase\", name = \"firebase-auth-ktx\", version.ref = \"firebaseAuthKtx\" }\nfirebase-auth = { module = \"com.google.firebase:firebase-auth\", version.ref = \"firebaseAuth\" }\nfirebase-database-ktx = { module = \"com.google.firebase:firebase-database-ktx\", version.ref = \"firebaseDatabaseKtx\" }\nfirebase-firestore = { module = \"com.google.firebase:firebase-firestore\", version.ref = \"firebaseFirestore\" }\nfirebase-ui-auth = { module = \"com.firebaseui:firebase-ui-auth\", version.ref = \"firebaseUiAuth\" }\n\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\ngoogle-firebase-auth = { module = \"com.google.firebase:firebase-auth\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\nandroidx-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\nandroidx-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\nandroidx-appcompat = { group = \"androidx.appcompat\", name = \"appcompat\", version.ref = \"appcompat\" }\nmaterial = { group = \"com.google.android.material\", name = \"material\", version.ref = \"material\" }\nmockk = { group = \"io.mockk\", name = \"mockk\", version.ref = \"mockk\" }\nmockk-android = { group = \"io.mockk\", name = \"mockk-android\", version.ref = \"mockk-android\" }\nmockito-android = { module = \"org.mockito:mockito-android\", version.ref = \"mockitoAndroid\" }\nmockito-core = { module = \"org.mockito:mockito-core\", version.ref = \"mockitoCore\" }\nmockito-inline = { module = \"org.mockito:mockito-inline\", version.ref = \"mockitoInline\" }\nmockito-kotlin = { module = \"org.mockito.kotlin:mockito-kotlin\" , version.ref=\"mockitoKotlin\"}\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycleRuntimeKtx\" }\n\ncompose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\ncompose-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\ncompose-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\ncompose-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\" }\ncompose-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\ncompose-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\ncompose-activity = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"composeActivity\" }\ncompose-viewmodel = { group = \"androidx.lifecycle\", name = \"lifecycle-viewmodel-compose\", version.ref = \"composeViewModel\" }\ncompose-test-junit = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\ncompose-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\n\nkaspresso = { group = \"com.kaspersky.android-components\", name = \"kaspresso\", version.ref = \"kaspresso\" }\nkaspresso-compose = { group = \"com.kaspersky.android-components\", name = \"kaspresso-compose-support\", version.ref = \"kaspresso\" }\n\nplay-services-auth = { module = \"com.google.android.gms:play-services-auth\", version.ref = \"playServicesAuth\" }\nplay-services-maps = { module = \"com.google.android.gms:play-services-maps\", version.ref = \"playServicesMaps\" }\n\nrobolectric = { module = \"org.robolectric:robolectric\", version.ref = \"robolectric\" }\nandroidx-navigation-compose = { group = \"androidx.navigation\", name = \"navigation-compose\", version.ref = \"navigationCompose\" }\n\nandroidx-espresso-intents = { group = \"androidx.test.espresso\", name = \"espresso-intents\", version.ref = \"espressoIntents\" }\nvolley = { module = \"com.android.volley:volley\", version.ref = \"volley\" }\njson = { module = \"org.json:json\", version.ref = \"json\" }\nfirebase-messaging-ktx = { group = \"com.google.firebase\", name = \"firebase-messaging-ktx\", version.ref = \"firebaseMessagingKtx\" }\n\nmaps-compose = { module = \"com.google.maps.android:maps-compose\", version.ref = \"mapsCompose\" }\nmaps-compose-utils = { module = \"com.google.maps.android:maps-compose-utils\", version.ref = \"mapsComposeUtils\" }\nfirebase-storage-ktx = { group = \"com.google.firebase\", name = \"firebase-storage-ktx\", version.ref = \"firebaseStorageKtx\" }\n\n\n\n[plugins]\nandroidApplication = { id = \"com.android.application\", version.ref = \"agp\" }\njetbrainsKotlinAndroid = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nktfmt = { id = \"com.ncorti.ktfmt.gradle\", version.ref = \"ktfmt\" }\nsonar = { id = \"org.sonarqube\", version.ref = \"sonar\" }\ngms = { id = \"com.google.gms.google-services\", version.ref = \"gms\" }
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
--- a/gradle/libs.versions.toml	
+++ b/gradle/libs.versions.toml	
@@ -20,6 +20,7 @@
 mockitoKotlin = "5.4.0"
 mockk = "1.13.13"
 mockk-android = "1.13.13"
+okhttp = "4.9.1"
 robolectric = "4.11.1"
 sonar = "4.4.1.3373"
 firebaseFirestoreKtx = "25.1.0"
@@ -93,6 +94,7 @@
 kaspresso = { group = "com.kaspersky.android-components", name = "kaspresso", version.ref = "kaspresso" }
 kaspresso-compose = { group = "com.kaspersky.android-components", name = "kaspresso-compose-support", version.ref = "kaspresso" }
 
+okhttp = { module = "com.squareup.okhttp3:okhttp", version.ref = "okhttp" }
 play-services-auth = { module = "com.google.android.gms:play-services-auth", version.ref = "playServicesAuth" }
 play-services-maps = { module = "com.google.android.gms:play-services-maps", version.ref = "playServicesMaps" }
 
Index: app/build.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\nimport java.io.FileInputStream\nimport java.util.Properties\n\nplugins {\n    jacoco\n    alias(libs.plugins.androidApplication)\n    alias(libs.plugins.jetbrainsKotlinAndroid)\n    alias(libs.plugins.ktfmt)\n    alias(libs.plugins.sonar)\n    id(\"com.google.gms.google-services\")\n}\n\nandroid {\n    namespace = \"com.android.bookswap\"\n    compileSdk = 34\n\n    // Load the API key from local.properties\n    val localProperties = Properties()\n    val localPropertiesFile = rootProject.file(\"local.properties\")\n    if (localPropertiesFile.exists()) {\n        localProperties.load(FileInputStream(localPropertiesFile))\n    }\n\n    val mapsApiKey: String = localProperties.getProperty(\"MAPS_API_KEY\") ?: \"\"\n\n    defaultConfig {\n        applicationId = \"com.android.bookswap\"\n        minSdk = 28\n        targetSdk = 34\n        versionCode = 1\n        versionName = \"1.0\"\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n        vectorDrawables {\n            useSupportLibrary = true\n        }\n        manifestPlaceholders[\"MAPS_API_KEY\"] = mapsApiKey\n    }\n\n    buildTypes {\n        release {\n            signingConfig = null\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n\n        debug {\n            enableUnitTestCoverage = true\n            enableAndroidTestCoverage = true\n        }\n    }\n\n    testCoverage {\n        jacocoVersion = \"0.8.8\"\n    }\n\n    buildFeatures {\n        compose = true\n    }\n\n    composeOptions {\n        kotlinCompilerExtensionVersion = \"1.4.2\"\n    }\n\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_11\n        targetCompatibility = JavaVersion.VERSION_11\n    }\n\n    kotlinOptions {\n        jvmTarget = \"11\"\n    }\n\n    packaging {\n        resources {\n            excludes += \"/META-INF/{AL2.0,LGPL2.1}\"\n            merges += \"META-INF/LICENSE.md\"\n            merges += \"META-INF/LICENSE-notice.md\"\n        }\n    }\n\n    testOptions {\n        unitTests {\n            isIncludeAndroidResources = true\n            isReturnDefaultValues = true\n        }\n    }\n\n    // Robolectric needs to be run only in debug. But its tests are placed in the shared source set (test)\n    // The next lines transfers the src/test/* from shared to the testDebug one\n    //\n    // This prevent errors from occurring during unit tests\n    sourceSets.getByName(\"testDebug\") {\n        val test = sourceSets.getByName(\"test\")\n\n        java.setSrcDirs(test.java.srcDirs)\n        res.setSrcDirs(test.res.srcDirs)\n        resources.setSrcDirs(test.resources.srcDirs)\n    }\n\n    sourceSets.getByName(\"test\") {\n        java.setSrcDirs(emptyList<File>())\n        res.setSrcDirs(emptyList<File>())\n        resources.setSrcDirs(emptyList<File>())\n    }\n}\n\nsonar {\n    properties {\n        property(\"sonar.projectKey\", \"BookswapEPFL_Bookswap\")\n        property(\"sonar.projectName\", \"BookSwapApp\")\n        property(\"sonar.organization\", \"bookswapepfl\")\n        property(\"sonar.host.url\", \"https://sonarcloud.io\")\n        // Comma-separated paths to the various directories containing the *.xml JUnit report files. Each path may be absolute or relative to the project base directory.\n        property(\"sonar.junit.reportPaths\", \"${project.layout.buildDirectory.get()}/test-results/testDebugunitTest/\")\n        // Paths to xml files with Android Lint issues. If the main flavor is changed, this file will have to be changed too.\n        property(\"sonar.androidLint.reportPaths\", \"${project.layout.buildDirectory.get()}/reports/lint-results-debug.xml\")\n        // Paths to JaCoCo XML coverage report files.\n        property(\"sonar.coverage.jacoco.xmlReportPaths\", \"${project.layout.buildDirectory.get()}/reports/jacoco/jacocoTestReport/jacocoTestReport.xml\")\n    }\n}\n\n// When a library is used both by robolectric and connected tests, use this function\nfun DependencyHandlerScope.globalTestImplementation(dep: Any) {\n    androidTestImplementation(dep)\n    testImplementation(dep)\n}\n\ndependencies {\n    implementation(\"com.google.firebase:firebase-messaging:23.0.0\")\n    implementation(platform(\"com.google.firebase:firebase-bom:33.4.0\"))\n    implementation(\"com.google.firebase:firebase-auth\")\n    implementation(\"com.google.firebase:firebase-analytics\")\n    implementation(libs.google.play.services.location)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.firebase.database.ktx)\n    implementation(libs.firebase.firestore)\n    implementation(libs.firebase.ui.auth)\n    implementation(libs.firebase.auth.ktx)\n    implementation(libs.firebase.auth)\n    implementation(libs.material)\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n    implementation(platform(libs.compose.bom))\n    implementation(libs.androidx.espresso.intents)\n    implementation(libs.firebase.firestore.ktx)\n    implementation(libs.firebase.auth.ktx)\n    implementation(libs.androidx.navigation.compose)\n    implementation(libs.firebase.messaging.ktx)\n    implementation(libs.firebase.storage.ktx)\n    testImplementation(libs.junit)\n    testImplementation(libs.mockito.core)\n    testImplementation(libs.mockito.kotlin)\n    testImplementation(libs.mockk)\n    testImplementation(libs.mockito.inline)\n    globalTestImplementation(libs.androidx.junit)\n    globalTestImplementation(libs.androidx.espresso.core)\n    androidTestImplementation(libs.mockk.android)\n\n    // Google Service and Maps\n    implementation(libs.play.services.maps)\n    implementation(libs.play.services.auth)\n\n    // Google Service and Maps\n    implementation(libs.play.services.maps)\n    implementation(libs.maps.compose)\n    implementation(libs.maps.compose.utils)\n\n    // ------------- Jetpack Compose ------------------\n    implementation(\"androidx.compose.material:material:1.7.1\")\n    val composeBom = platform(libs.compose.bom)\n    implementation(composeBom)\n    globalTestImplementation(composeBom)\n\n    implementation(libs.compose.ui)\n    implementation(libs.compose.ui.graphics)\n    // Material Design 3\n    implementation(libs.compose.material3)\n    // Integration with activities\n    implementation(libs.compose.activity)\n    // Integration with ViewModels\n    implementation(libs.compose.viewmodel)\n    // Android Studio Preview support\n    implementation(libs.compose.preview)\n    debugImplementation(libs.compose.tooling)\n    // UI Tests\n    globalTestImplementation(libs.compose.test.junit)\n    debugImplementation(libs.compose.test.manifest)\n\n    // --------- Kaspresso test framework ----------\n    globalTestImplementation(libs.kaspresso)\n    globalTestImplementation(libs.kaspresso.compose)\n\n\n\n    testImplementation(libs.mockito.core)\n    testImplementation(libs.mockito.inline)\n    testImplementation(libs.mockito.kotlin)\n    androidTestImplementation(libs.mockito.android)\n    androidTestImplementation(libs.mockito.kotlin)\n\n\n    // ----------       Robolectric     ------------\n    testImplementation(libs.robolectric)\n\n    implementation(libs.volley) //HTTP request\n    implementation(libs.json) //JSON parser\n    implementation(\"androidx.appcompat:appcompat:1.6.1\")\n    implementation(\"androidx.vectordrawable:vectordrawable:1.1.0\")\n\n\n}\n\ntasks.withType<Test> {\n    // Configure Jacoco for each tests\n    configure<JacocoTaskExtension> {\n        isIncludeNoLocationClasses = true\n        excludes = listOf(\"jdk.internal.*\")\n    }\n}\n\ntasks.register(\"jacocoTestReport\", JacocoReport::class) {\n    mustRunAfter(\"testDebugUnitTest\", \"connectedDebugAndroidTest\")\n\n    reports {\n        xml.required = true\n        html.required = true\n    }\n\n    val fileFilter = listOf(\n        \"**/R.class\",\n        \"**/R$*.class\",\n        \"**/BuildConfig.*\",\n        \"**/Manifest*.*\",\n        \"**/*Test*.*\",\n        \"android/**/*.*\",\n    )\n\n    val debugTree = fileTree(\"${project.layout.buildDirectory.get()}/tmp/kotlin-classes/debug\") {\n        exclude(fileFilter)\n    }\n\n    val mainSrc = \"${project.layout.projectDirectory}/src/main/java\"\n    sourceDirectories.setFrom(files(mainSrc))\n    classDirectories.setFrom(files(debugTree))\n    executionData.setFrom(fileTree(project.layout.buildDirectory.get()) {\n        include(\"outputs/unit_test_code_coverage/debugUnitTest/testDebugUnitTest.exec\")\n        include(\"outputs/code_coverage/debugAndroidTest/connected/*/coverage.ec\")\n    })\n\n    doLast {\n        val reportFile = reports.xml.outputLocation.asFile.get()\n        val newContent = reportFile.readText().replace(\"<line[^>]+nr=\\\"65535\\\"[^>]*>\".toRegex(), \"\")\n        reportFile.writeText(newContent)\n\n        logger.quiet(\"Wrote summarized jacoco test coverage report xml to ${reportFile.absolutePath}\")\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/build.gradle.kts b/app/build.gradle.kts
--- a/app/build.gradle.kts	
+++ b/app/build.gradle.kts	
@@ -1,4 +1,3 @@
-
 import java.io.FileInputStream
 import java.util.Properties
 
@@ -15,6 +14,9 @@
     namespace = "com.android.bookswap"
     compileSdk = 34
 
+    buildFeatures {
+        buildConfig = true
+    }
     // Load the API key from local.properties
     val localProperties = Properties()
     val localPropertiesFile = rootProject.file("local.properties")
@@ -24,6 +26,7 @@
 
     val mapsApiKey: String = localProperties.getProperty("MAPS_API_KEY") ?: ""
 
+
     defaultConfig {
         applicationId = "com.android.bookswap"
         minSdk = 28
@@ -35,7 +38,10 @@
         vectorDrawables {
             useSupportLibrary = true
         }
+        val openAiApiKey: String = localProperties.getProperty("OPENAI_API_KEY") ?: "\" placeHolder \" "
         manifestPlaceholders["MAPS_API_KEY"] = mapsApiKey
+        manifestPlaceholders["OPENAI_API_KEY"] = openAiApiKey
+        buildConfigField("String", "OPENAI_API_KEY",  openAiApiKey)
     }
 
     buildTypes {
@@ -60,6 +66,7 @@
 
     buildFeatures {
         compose = true
+        buildConfig = true //Generate a com.android.bookswap.BuildConfig file
     }
 
     composeOptions {
@@ -80,6 +87,7 @@
             excludes += "/META-INF/{AL2.0,LGPL2.1}"
             merges += "META-INF/LICENSE.md"
             merges += "META-INF/LICENSE-notice.md"
+            excludes += "META-INF/DEPENDENCIES"
         }
     }
 
@@ -116,11 +124,20 @@
         property("sonar.organization", "bookswapepfl")
         property("sonar.host.url", "https://sonarcloud.io")
         // Comma-separated paths to the various directories containing the *.xml JUnit report files. Each path may be absolute or relative to the project base directory.
-        property("sonar.junit.reportPaths", "${project.layout.buildDirectory.get()}/test-results/testDebugunitTest/")
+        property(
+            "sonar.junit.reportPaths",
+            "${project.layout.buildDirectory.get()}/test-results/testDebugunitTest/"
+        )
         // Paths to xml files with Android Lint issues. If the main flavor is changed, this file will have to be changed too.
-        property("sonar.androidLint.reportPaths", "${project.layout.buildDirectory.get()}/reports/lint-results-debug.xml")
+        property(
+            "sonar.androidLint.reportPaths",
+            "${project.layout.buildDirectory.get()}/reports/lint-results-debug.xml"
+        )
         // Paths to JaCoCo XML coverage report files.
-        property("sonar.coverage.jacoco.xmlReportPaths", "${project.layout.buildDirectory.get()}/reports/jacoco/jacocoTestReport/jacocoTestReport.xml")
+        property(
+            "sonar.coverage.jacoco.xmlReportPaths",
+            "${project.layout.buildDirectory.get()}/reports/jacoco/jacocoTestReport/jacocoTestReport.xml"
+        )
     }
 }
 
@@ -136,6 +153,7 @@
     implementation("com.google.firebase:firebase-auth")
     implementation("com.google.firebase:firebase-analytics")
     implementation(libs.google.play.services.location)
+    implementation("io.coil-kt:coil-compose:2.1.0")
     implementation(libs.androidx.core.ktx)
     implementation(libs.androidx.appcompat)
     implementation(libs.firebase.database.ktx)
@@ -195,8 +213,6 @@
     globalTestImplementation(libs.kaspresso)
     globalTestImplementation(libs.kaspresso.compose)
 
-
-
     testImplementation(libs.mockito.core)
     testImplementation(libs.mockito.inline)
     testImplementation(libs.mockito.kotlin)
@@ -208,6 +224,10 @@
     testImplementation(libs.robolectric)
 
     implementation(libs.volley) //HTTP request
+    implementation(libs.okhttp)
+
+    implementation("org.apache.httpcomponents:httpclient:4.5.14")
+    implementation("org.apache.httpcomponents:httpcore:4.4.13")
     implementation(libs.json) //JSON parser
     implementation("androidx.appcompat:appcompat:1.6.1")
     implementation("androidx.vectordrawable:vectordrawable:1.1.0")
Index: app/src/androidTest/java/com/android/bookswap/ui/profile/UserProfileScreenTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.profile\n\nimport androidx.compose.ui.test.ExperimentalTestApi\nimport androidx.compose.ui.test.assertIsDisplayed\nimport androidx.compose.ui.test.junit4.createComposeRule\nimport androidx.test.ext.junit.runners.AndroidJUnit4\nimport com.android.bookswap.data.DataUser\nimport com.android.bookswap.data.repository.UsersRepository\nimport com.android.bookswap.model.UserViewModel\nimport com.android.bookswap.screen.UserProfileScreen\nimport com.kaspersky.kaspresso.testcases.api.testcase.TestCase\nimport io.github.kakaocup.compose.node.element.ComposeScreen\nimport org.junit.Before\nimport org.junit.Rule\nimport org.junit.Test\nimport org.junit.runner.RunWith\n\n/**\n * Instrumented test, which will execute on an Android device.\n *\n * See [testing documentation](http://d.android.com/tools/testing).\n */\n@RunWith(AndroidJUnit4::class)\nclass UserProfileScreenTest : TestCase() {\n\n  @get:Rule val composeTestRule = createComposeRule()\n\n  @Before\n  fun setup() {\n    val userVM = UserViewModel(\"email@example.com\", MockUserRepo())\n\n    userVM.updateUser(\n        DataUser(\n            \"M.\",\n            \"John\",\n            \"Doe\",\n            \"John.Doe@example.com\",\n            \"+41223456789\",\n            0.0,\n            0.0,\n            \"dummyPic.png\",\n            \"dummyUUID0000\"))\n\n    composeTestRule.setContent { UserProfile(userVM = userVM) }\n  }\n\n  @Test\n  fun testDisplay() {\n    run(testName = \"assertContent\") {\n      step(\"Start User Profile Screen\") {\n        ComposeScreen.onComposeScreen<UserProfileScreen>(composeTestRule) {\n          titleTxt {\n            assertIsDisplayed()\n            assertTextEquals(\"Your Profile\")\n          }\n          fullNameTxt {\n            assertIsDisplayed()\n            assertTextEquals(\"M. John Doe\")\n          }\n          emailTxt {\n            assertIsDisplayed()\n            assertTextEquals(\"John.Doe@example.com\")\n          }\n          phoneNumberTxt {\n            assertIsDisplayed()\n            assertTextEquals(\"+41223456789\")\n          }\n          addressTxt {\n            assertIsDisplayed()\n            assertTextEquals(\"0.0, 0.0\")\n          }\n          editProfileBtn {\n            assertIsDisplayed()\n            assertIsEnabled()\n          }\n        }\n      }\n    }\n  }\n\n  @OptIn(ExperimentalTestApi::class)\n  @Test\n  fun testEdit() {\n    run(testName = \"assertEditAction\") {\n      ComposeScreen.onComposeScreen<UserProfileScreen>(composeTestRule) {\n        step(\"Start User Profile Screen\") {\n          titleTxt {\n            assertIsDisplayed()\n            assertTextEquals(\"Your Profile\")\n          }\n          fullNameTxt {\n            assertIsDisplayed()\n            assertTextEquals(\"M. John Doe\")\n          }\n          emailTxt {\n            assertIsDisplayed()\n            assertTextEquals(\"John.Doe@example.com\")\n          }\n          phoneNumberTxt {\n            assertIsDisplayed()\n            assertTextEquals(\"+41223456789\")\n          }\n          addressTxt {\n            assertIsDisplayed()\n            assertTextEquals(\"0.0, 0.0\")\n          }\n          editProfileBtn {\n            assertIsDisplayed()\n            assertIsEnabled()\n            assertHasClickAction()\n          }\n        }\n        step(\"Click edit button\") {\n          editProfileBtn {\n            assertIsDisplayed()\n            assertIsEnabled()\n            assertHasClickAction()\n            performClick()\n          }\n        }\n      }\n    }\n  }\n}\n\nclass MockUserRepo : UsersRepository {\n  val mockUserList =\n      mutableMapOf(\n          \"usr_01_jd\" to\n              DataUser(\n                  \"M.\",\n                  \"John\",\n                  \"Doe\",\n                  \"john.doe@example.com\",\n                  \"+41223456789\",\n                  0.0,\n                  0.0,\n                  \"\",\n                  \"usr_01_jd\"),\n          \"usr_02_jd\" to\n              DataUser(\n                  \"Mr.\",\n                  \"Jones\",\n                  \"Douse\",\n                  \"jon.doe@example.com\",\n                  \"+41234567890\",\n                  0.0,\n                  0.0,\n                  \"\",\n                  \"usr_02_jd\"),\n          \"usr_03_jd\" to\n              DataUser(\n                  \"Ms.\",\n                  \"Jo\",\n                  \"Doe\",\n                  \"jo.doe@example.com\",\n                  \"+41765432198\",\n                  0.0,\n                  0.0,\n                  \"\",\n                  \"usr_03_jd\"),\n      )\n\n  override fun getUsers(callback: (Result<List<DataUser>>) -> Unit) {\n    callback(Result.success(mockUserList.values.toList()))\n  }\n\n  override fun getUser(uuid: String, callback: (Result<DataUser>) -> Unit) {\n    val usr = mockUserList.get(uuid)\n    if (usr != null) {\n      callback(Result.success(usr))\n    } else {\n      callback(Result.failure(Throwable(\"User not found\")))\n    }\n  }\n\n  override fun addUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit) {\n    mockUserList.put(dataUser.userId, dataUser)\n  }\n\n  override fun updateUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit) {\n    mockUserList.put(dataUser.userId, dataUser)\n  }\n\n  override fun deleteUser(uuid: String, callback: (Result<Unit>) -> Unit) {\n    mockUserList.remove(uuid)\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/profile/UserProfileScreenTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/profile/UserProfileScreenTest.kt
--- a/app/src/androidTest/java/com/android/bookswap/ui/profile/UserProfileScreenTest.kt	
+++ b/app/src/androidTest/java/com/android/bookswap/ui/profile/UserProfileScreenTest.kt	
@@ -1,15 +1,19 @@
 package com.android.bookswap.ui.profile
 
-import androidx.compose.ui.test.ExperimentalTestApi
-import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.Modifier
 import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.navigation.compose.rememberNavController
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import com.android.bookswap.data.DataUser
-import com.android.bookswap.data.repository.UsersRepository
 import com.android.bookswap.model.UserViewModel
 import com.android.bookswap.screen.UserProfileScreen
+import com.android.bookswap.ui.components.TopAppBarComponent
+import com.android.bookswap.ui.navigation.NavigationActions
 import com.kaspersky.kaspresso.testcases.api.testcase.TestCase
 import io.github.kakaocup.compose.node.element.ComposeScreen
+import io.mockk.every
+import io.mockk.mockk
+import java.util.UUID
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
@@ -24,24 +28,29 @@
 class UserProfileScreenTest : TestCase() {
 
   @get:Rule val composeTestRule = createComposeRule()
-
-  @Before
-  fun setup() {
-    val userVM = UserViewModel("email@example.com", MockUserRepo())
-
-    userVM.updateUser(
-        DataUser(
-            "M.",
-            "John",
-            "Doe",
-            "John.Doe@example.com",
-            "+41223456789",
-            0.0,
-            0.0,
-            "dummyPic.png",
-            "dummyUUID0000"))
+  private val standardUser =
+      DataUser(
+          UUID.randomUUID(),
+          "M.",
+          "John",
+          "Doe",
+          "John.Doe@example.com",
+          "+41223456789",
+          0.0,
+          0.0,
+          "dummyPic.png")
 
-    composeTestRule.setContent { UserProfile(userVM = userVM) }
+  @Before
+  fun setup() {
+    val userVM: UserViewModel = mockk()
+    every { userVM.getUser(any()) } returns standardUser
+    every { userVM.uuid } returns standardUser.userUUID
+
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      UserProfile(userVM = userVM, { TopAppBarComponent(Modifier, navigationActions, "Messages") })
+    }
   }
 
   @Test
@@ -49,10 +58,7 @@
     run(testName = "assertContent") {
       step("Start User Profile Screen") {
         ComposeScreen.onComposeScreen<UserProfileScreen>(composeTestRule) {
-          titleTxt {
-            assertIsDisplayed()
-            assertTextEquals("Your Profile")
-          }
+          titleTxt { assertIsDisplayed() }
           fullNameTxt {
             assertIsDisplayed()
             assertTextEquals("M. John Doe")
@@ -78,16 +84,11 @@
     }
   }
 
-  @OptIn(ExperimentalTestApi::class)
   @Test
   fun testEdit() {
     run(testName = "assertEditAction") {
       ComposeScreen.onComposeScreen<UserProfileScreen>(composeTestRule) {
         step("Start User Profile Screen") {
-          titleTxt {
-            assertIsDisplayed()
-            assertTextEquals("Your Profile")
-          }
           fullNameTxt {
             assertIsDisplayed()
             assertTextEquals("M. John Doe")
@@ -122,67 +123,3 @@
     }
   }
 }
-
-class MockUserRepo : UsersRepository {
-  val mockUserList =
-      mutableMapOf(
-          "usr_01_jd" to
-              DataUser(
-                  "M.",
-                  "John",
-                  "Doe",
-                  "john.doe@example.com",
-                  "+41223456789",
-                  0.0,
-                  0.0,
-                  "",
-                  "usr_01_jd"),
-          "usr_02_jd" to
-              DataUser(
-                  "Mr.",
-                  "Jones",
-                  "Douse",
-                  "jon.doe@example.com",
-                  "+41234567890",
-                  0.0,
-                  0.0,
-                  "",
-                  "usr_02_jd"),
-          "usr_03_jd" to
-              DataUser(
-                  "Ms.",
-                  "Jo",
-                  "Doe",
-                  "jo.doe@example.com",
-                  "+41765432198",
-                  0.0,
-                  0.0,
-                  "",
-                  "usr_03_jd"),
-      )
-
-  override fun getUsers(callback: (Result<List<DataUser>>) -> Unit) {
-    callback(Result.success(mockUserList.values.toList()))
-  }
-
-  override fun getUser(uuid: String, callback: (Result<DataUser>) -> Unit) {
-    val usr = mockUserList.get(uuid)
-    if (usr != null) {
-      callback(Result.success(usr))
-    } else {
-      callback(Result.failure(Throwable("User not found")))
-    }
-  }
-
-  override fun addUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit) {
-    mockUserList.put(dataUser.userId, dataUser)
-  }
-
-  override fun updateUser(dataUser: DataUser, callback: (Result<Unit>) -> Unit) {
-    mockUserList.put(dataUser.userId, dataUser)
-  }
-
-  override fun deleteUser(uuid: String, callback: (Result<Unit>) -> Unit) {
-    mockUserList.remove(uuid)
-  }
-}
Index: app/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    package=\"com.android.bookswap\">\n\n    <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n    <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n    <uses-permission android:name=\"android.permission.ACCESS_BACKGROUND_LOCATION\" />\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n    <uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n    <uses-permission android:name=\"com.google.android.c2dm.permission.RECEIVE\" />\n    <uses-permission android:name=\"android.permission.POST_NOTIFICATIONS\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.BookSwapApp\"\n        tools:targetApi=\"31\">\n\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\"\n            android:label=\"@string/title_activity_main\"\n            android:theme=\"@style/Theme.BookSwapApp\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n\n        <service\n            android:name=\".model.chat.MyFirebaseMessagingService\"\n            android:exported=\"true\"\n            android:permission=\"com.android.bookswap.permission.SEND_MESSAGES\">\n            <intent-filter>\n                <action android:name=\"com.google.firebase.MESSAGING_EVENT\"/>\n            </intent-filter>\n        </service>\n\n        <meta-data\n            android:name=\"com.google.android.geo.API_KEY\"\n            android:value=\"${MAPS_API_KEY}\" />\n\n        <meta-data\n            android:name=\"com.google.firebase.messaging.default_notification_channel_id\"\n            android:value=\"bookswap_notifications_channel\" />\n\n        <receiver\n            android:name=\"com.google.firebase.iid.FirebaseInstanceIdReceiver\"\n            android:exported=\"true\"\n            android:permission=\"com.google.android.c2dm.permission.SEND\">\n            <intent-filter>\n                <action android:name=\"com.google.android.c2dm.intent.RECEIVE\" />\n                <category android:name=\"${applicationId}\" />\n            </intent-filter>\n        </receiver>\n\n    </application>\n\n    <permission\n        android:name=\"com.android.bookswap.permission.SEND_MESSAGES\"\n        android:protectionLevel=\"signature\" />\n\n</manifest>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
--- a/app/src/main/AndroidManifest.xml	
+++ b/app/src/main/AndroidManifest.xml	
@@ -3,6 +3,10 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.android.bookswap">
 
+    <permission
+        android:name="com.android.bookswap.permission.SEND_MESSAGES"
+        android:protectionLevel="signature" />
+
     <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
     <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
     <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
@@ -12,6 +16,10 @@
     <uses-permission android:name="com.google.android.c2dm.permission.RECEIVE" />
     <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
 
+    <!-- Photo permissions -->
+    <uses-permission android:name="android.permission.CAMERA" />
+    <uses-feature android:name="android.hardware.camera" android:required="false" />
+
     <application
         android:allowBackup="true"
         android:dataExtractionRules="@xml/data_extraction_rules"
@@ -61,10 +69,17 @@
             </intent-filter>
         </receiver>
 
+        <!-- Photo file provider -->
+        <provider
+            android:name="androidx.core.content.FileProvider"
+            android:authorities="${applicationId}.provider"
+            android:exported="false"
+            android:grantUriPermissions="true">
+            <meta-data
+                android:name="android.support.FILE_PROVIDER_PATHS"
+                android:resource="@xml/filepaths" />
+        </provider>
+
     </application>
 
-    <permission
-        android:name="com.android.bookswap.permission.SEND_MESSAGES"
-        android:protectionLevel="signature" />
-
 </manifest>
\ No newline at end of file
Index: app/src/androidTest/java/com/android/bookswap/ui/profile/EditProfileScreenTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.profile\n\nimport android.util.Log\nimport androidx.compose.ui.test.junit4.createComposeRule\nimport androidx.test.ext.junit.runners.AndroidJUnit4\nimport com.android.bookswap.data.DataUser\nimport com.android.bookswap.screen.EditProfileScreen\nimport com.kaspersky.kaspresso.testcases.api.testcase.TestCase\nimport io.github.kakaocup.compose.node.element.ComposeScreen\nimport org.junit.Before\nimport org.junit.Rule\nimport org.junit.Test\nimport org.junit.runner.RunWith\n\n/**\n * Instrumented test, which will execute on an Android device.\n *\n * See [testing documentation](http://d.android.com/tools/testing).\n */\n@RunWith(AndroidJUnit4::class)\nclass EditProfileScreenTest : TestCase() {\n  @get:Rule val composeTestRule = createComposeRule()\n\n  @Before fun setup() {}\n\n  @Test\n  fun testDisplay() =\n      run(testName = \"test alert display\") {\n        composeTestRule.setContent {\n          EditProfileDialog(\n              { Log.d(\"EditProfileTest_Dismiss\", \"User info discarded\") },\n              { Log.d(\"EditProfileTest_Save\", \"User info saved ${it.printFullname()}\") },\n              DataUser(\"\", \"\", \"\", \"\", \"\", 0.0, 0.0, \"\", \"\"))\n        }\n        step(\"try displaying the alert box\") {\n          ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {\n            titleTxt {\n              assertIsDisplayed()\n              assertTextEquals(\"Edit Profile\")\n            }\n            greetingTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextContains(\"Greeting\", true)\n              performTextClearance()\n              assertTextContains(\"Mr.\", true)\n            }\n            firstnameTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextContains(\"Firstname\", true)\n              performTextClearance()\n              assertTextContains(\"John\", true)\n            }\n            lastnameTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextContains(\"Lastname\", true)\n              performTextClearance()\n              assertTextContains(\"Doe\", true)\n            }\n            emailTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextContains(\"Email\", true)\n              performTextClearance()\n              assertTextContains(\"John.Doe@example.com\", true)\n            }\n            phoneNumberTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextContains(\"Phone\", true)\n              performTextClearance()\n              assertTextContains(\"+4122345678\", true)\n            }\n            confirmBtn {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextEquals(\"Save\")\n            }\n            dismissBtn {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextEquals(\"Cancel\")\n            }\n          }\n        }\n      }\n\n  @Test\n  fun testEdit() =\n      run(testName = \"test alert edit\") {\n        composeTestRule.setContent {\n          EditProfileDialog(\n              { Log.d(\"EditProfileTest_Dismiss\", \"User info discarded\") },\n              { Log.d(\"EditProfileTest_Save\", \"User info saved ${it.printFullname()}\") },\n              DataUser(\n                  \"M.\",\n                  \"John\",\n                  \"Doe\",\n                  \"John.Doe@example.com\",\n                  \"+41223456789\",\n                  0.0,\n                  0.0,\n                  \"dummyPic.png\",\n                  \"dummyUUID0000\"))\n        }\n        step(\"try editing the textbox values\") {\n          ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {\n            titleTxt {\n              assertIsDisplayed()\n              assertTextEquals(\"Edit Profile\")\n            }\n            greetingTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              performClick()\n              performTextClearance()\n              assertTextContains(\"Greeting\", true)\n              performTextInput(\"Mr.\")\n              assertTextContains(\"Mr.\", true)\n            }\n            firstnameTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              performClick()\n              performTextClearance()\n              assertTextContains(\"Firstname\", true)\n              performTextInput(\"Jones\")\n              assertTextContains(\"Jones\", true)\n            }\n            lastnameTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              performClick()\n              performTextClearance()\n              assertTextContains(\"Lastname\", true)\n              performTextInput(\"Douses\")\n              assertTextContains(\"Douses\", true)\n            }\n            emailTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              performClick()\n              performTextClearance()\n              assertTextContains(\"Email\", true)\n              performTextInput(\"Jones.Douses@example.com\")\n              assertTextContains(\"Jones.Douses@example.com\", true)\n            }\n            phoneNumberTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              performClick()\n              performTextClearance()\n              assertTextContains(\"Phone\", true)\n              performTextInput(\"+41234567890\")\n              assertTextContains(\"+41234567890\", true)\n            }\n            confirmBtn {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextEquals(\"Save\")\n            }\n            dismissBtn {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextEquals(\"Cancel\")\n            }\n          }\n        }\n      }\n\n  @Test\n  fun testEditConfirm() =\n      run(testName = \"test edit and confirm\") {\n        composeTestRule.setContent {\n          EditProfileDialog(\n              { Log.d(\"EditProfileTest_Dismiss\", \"User info discarded\") },\n              { Log.d(\"EditProfileTest_Save\", \"User info saved ${it.printFullname()}\") },\n              DataUser(\n                  \"M.\",\n                  \"John\",\n                  \"Doe\",\n                  \"John.Doe@example.com\",\n                  \"+41223456789\",\n                  0.0,\n                  0.0,\n                  \"dummyPic.png\",\n                  \"dummyUUID0000\"))\n        }\n        step(\"try editing the textbox values then confirming the changes\") {\n          ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {\n            titleTxt {\n              assertIsDisplayed()\n              assertTextEquals(\"Edit Profile\")\n            }\n            greetingTbx {\n              performTextClearance()\n              performTextInput(\"Mr.\")\n              assertTextEquals(\"Greeting\", \"Mr.\")\n            }\n            firstnameTbx {\n              performTextClearance()\n              performTextInput(\"Jones\")\n              assertTextEquals(\"Firstname\", \"Jones\")\n            }\n            lastnameTbx {\n              performTextClearance()\n              performTextInput(\"Douses\")\n              assertTextEquals(\"Lastname\", \"Douses\")\n            }\n            emailTbx {\n              performTextClearance()\n              performTextInput(\"Jones.Douses@example.com\")\n              assertTextEquals(\"Email\", \"Jones.Douses@example.com\")\n            }\n            phoneNumberTbx {\n              performTextClearance()\n              performTextInput(\"+41234567890\")\n              assertTextEquals(\"Phone\", \"+41234567890\")\n            }\n            confirmBtn {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextEquals(\"Save\")\n            }\n            dismissBtn {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextEquals(\"Cancel\")\n            }\n          }\n        }\n        step(\"try pressing on confirm\") {\n          ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {\n            step(\"\") {\n              titleTxt {\n                assertIsDisplayed()\n                assertTextEquals(\"Edit Profile\")\n              }\n              greetingTbx {\n                assertIsDisplayed()\n                assertIsEnabled()\n                assertTextEquals(\"Greeting\", \"Mr.\")\n              }\n              firstnameTbx {\n                assertIsDisplayed()\n                assertIsEnabled()\n                assertTextEquals(\"Firstname\", \"Jones\")\n              }\n              lastnameTbx {\n                assertIsDisplayed()\n                assertIsEnabled()\n                assertTextEquals(\"Lastname\", \"Douses\")\n              }\n              emailTbx {\n                assertIsDisplayed()\n                assertIsEnabled()\n                assertTextEquals(\"Email\", \"Jones.Douses@example.com\")\n              }\n              phoneNumberTbx {\n                assertIsDisplayed()\n                assertIsEnabled()\n                assertTextEquals(\"Phone\", \"+41234567890\")\n              }\n              confirmBtn {\n                assertIsDisplayed()\n                assertIsEnabled()\n                assertTextEquals(\"Save\")\n              }\n              dismissBtn {\n                assertIsDisplayed()\n                assertIsEnabled()\n                assertTextEquals(\"Cancel\")\n              }\n            }\n            step(\"\") {\n              confirmBtn {\n                assertIsDisplayed()\n                assertIsEnabled()\n                assertTextEquals(\"Save\")\n                performClick()\n              }\n            }\n          }\n        }\n      }\n\n  @Test\n  fun testEditDismiss() =\n      run(testName = \"test alert display\") {\n        composeTestRule.setContent {\n          EditProfileDialog(\n              { Log.d(\"EditProfileTest_Dismiss\", \"User info discarded\") },\n              { Log.d(\"EditProfileTest_Save\", \"User info saved ${it.printFullname()}\") },\n              DataUser(\n                  \"M.\",\n                  \"John\",\n                  \"Doe\",\n                  \"John.Doe@example.com\",\n                  \"+41223456789\",\n                  0.0,\n                  0.0,\n                  \"dummyPic.png\",\n                  \"dummyUUID0000\"))\n        }\n        step(\"try editing the textbox values then cancelling the changes\") {\n          ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {\n            titleTxt {\n              assertIsDisplayed()\n              assertTextEquals(\"Edit Profile\")\n            }\n            greetingTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              performClick()\n              performTextClearance()\n              performTextInput(\"Mr.\")\n            }\n            firstnameTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              performClick()\n              performTextClearance()\n              performTextInput(\"Jones\")\n            }\n            lastnameTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              performClick()\n              performTextClearance()\n              performTextInput(\"Douses\")\n            }\n            emailTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              performClick()\n              performTextClearance()\n              performTextInput(\"Jones.Douses@example.com\")\n            }\n            phoneNumberTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              performClick()\n              performTextClearance()\n              performTextInput(\"+41234567890\")\n            }\n            confirmBtn {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextEquals(\"Save\")\n            }\n            dismissBtn {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextEquals(\"Cancel\")\n            }\n          }\n        }\n        step(\"test if the values are edited\") {\n          ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {\n            titleTxt {\n              assertIsDisplayed()\n              assertTextEquals(\"Edit Profile\")\n            }\n            greetingTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextEquals(\"Greeting\", \"Mr.\")\n            }\n            firstnameTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextEquals(\"Firstname\", \"Jones\")\n            }\n            lastnameTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextEquals(\"Lastname\", \"Douses\")\n            }\n            emailTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextEquals(\"Email\", \"Jones.Douses@example.com\")\n            }\n            phoneNumberTbx {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextEquals(\"Phone\", \"+41234567890\")\n            }\n            confirmBtn {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextEquals(\"Save\")\n            }\n            dismissBtn {\n              assertIsDisplayed()\n              assertIsEnabled()\n              assertTextEquals(\"Cancel\")\n            }\n          }\n        }\n        step(\"try pressing on cancel\") {\n          ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {\n            step(\"\") {\n              titleTxt {\n                assertIsDisplayed()\n                assertTextEquals(\"Edit Profile\")\n              }\n              greetingTbx {\n                assertIsDisplayed()\n                assertIsEnabled()\n                assertTextEquals(\"Greeting\", \"Mr.\")\n              }\n              firstnameTbx {\n                assertIsDisplayed()\n                assertIsEnabled()\n                assertTextEquals(\"Firstname\", \"Jones\")\n              }\n              lastnameTbx {\n                assertIsDisplayed()\n                assertIsEnabled()\n                assertTextEquals(\"Lastname\", \"Douses\")\n              }\n              emailTbx {\n                assertIsDisplayed()\n                assertIsEnabled()\n                assertTextEquals(\"Email\", \"Jones.Douses@example.com\")\n              }\n              phoneNumberTbx {\n                assertIsDisplayed()\n                assertIsEnabled()\n                assertTextEquals(\"Phone\", \"+41234567890\")\n              }\n              confirmBtn {\n                assertIsDisplayed()\n                assertIsEnabled()\n                assertTextEquals(\"Save\")\n              }\n              dismissBtn {\n                assertIsDisplayed()\n                assertIsEnabled()\n                assertTextEquals(\"Cancel\")\n              }\n            }\n            step(\"\") {\n              dismissBtn {\n                assertIsDisplayed()\n                assertIsEnabled()\n                assertTextEquals(\"Cancel\")\n                performClick()\n              }\n            }\n          }\n        }\n      }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/profile/EditProfileScreenTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/profile/EditProfileScreenTest.kt
--- a/app/src/androidTest/java/com/android/bookswap/ui/profile/EditProfileScreenTest.kt	
+++ b/app/src/androidTest/java/com/android/bookswap/ui/profile/EditProfileScreenTest.kt	
@@ -7,7 +7,7 @@
 import com.android.bookswap.screen.EditProfileScreen
 import com.kaspersky.kaspresso.testcases.api.testcase.TestCase
 import io.github.kakaocup.compose.node.element.ComposeScreen
-import org.junit.Before
+import java.util.UUID
 import org.junit.Rule
 import org.junit.Test
 import org.junit.runner.RunWith
@@ -21,16 +21,27 @@
 class EditProfileScreenTest : TestCase() {
   @get:Rule val composeTestRule = createComposeRule()
 
-  @Before fun setup() {}
+  private val standardUser =
+      DataUser(
+          UUID.randomUUID(),
+          "M.",
+          "John",
+          "Doe",
+          "John.Doe@example.com",
+          "+41223456789",
+          0.0,
+          0.0,
+          "dummyPic.png")
 
   @Test
   fun testDisplay() =
       run(testName = "test alert display") {
+        val userUUID = UUID.randomUUID()
         composeTestRule.setContent {
           EditProfileDialog(
               { Log.d("EditProfileTest_Dismiss", "User info discarded") },
               { Log.d("EditProfileTest_Save", "User info saved ${it.printFullname()}") },
-              DataUser("", "", "", "", "", 0.0, 0.0, "", ""))
+              DataUser(userUUID, "", "", "", "", "", 0.0, 0.0, ""))
         }
         step("try displaying the alert box") {
           ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {
@@ -94,16 +105,7 @@
           EditProfileDialog(
               { Log.d("EditProfileTest_Dismiss", "User info discarded") },
               { Log.d("EditProfileTest_Save", "User info saved ${it.printFullname()}") },
-              DataUser(
-                  "M.",
-                  "John",
-                  "Doe",
-                  "John.Doe@example.com",
-                  "+41223456789",
-                  0.0,
-                  0.0,
-                  "dummyPic.png",
-                  "dummyUUID0000"))
+              standardUser)
         }
         step("try editing the textbox values") {
           ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {
@@ -177,16 +179,7 @@
           EditProfileDialog(
               { Log.d("EditProfileTest_Dismiss", "User info discarded") },
               { Log.d("EditProfileTest_Save", "User info saved ${it.printFullname()}") },
-              DataUser(
-                  "M.",
-                  "John",
-                  "Doe",
-                  "John.Doe@example.com",
-                  "+41223456789",
-                  0.0,
-                  0.0,
-                  "dummyPic.png",
-                  "dummyUUID0000"))
+              standardUser)
         }
         step("try editing the textbox values then confirming the changes") {
           ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {
@@ -293,16 +286,7 @@
           EditProfileDialog(
               { Log.d("EditProfileTest_Dismiss", "User info discarded") },
               { Log.d("EditProfileTest_Save", "User info saved ${it.printFullname()}") },
-              DataUser(
-                  "M.",
-                  "John",
-                  "Doe",
-                  "John.Doe@example.com",
-                  "+41223456789",
-                  0.0,
-                  0.0,
-                  "dummyPic.png",
-                  "dummyUUID0000"))
+              standardUser)
         }
         step("try editing the textbox values then cancelling the changes") {
           ComposeScreen.onComposeScreen<EditProfileScreen>(composeTestRule) {
Index: app/src/main/java/com/android/bookswap/data/repository/BookRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.data.repository\n\nimport com.android.bookswap.data.DataBook\nimport java.util.UUID\n\n// Interface defining a contract for managing book-related operations in a repository.\ninterface BooksRepository {\n\n  // Function to initialize the repository. This can be used to set up data or resources.\n  // This default implementation does nothing, but subclasses can override it.\n  fun init(OnSucess: () -> Unit)\n\n  // Function to generate and return a new unique identifier (UID) for a book.\n  // This default implementation returns an empty string, but it should be overridden to generate\n  // actual UIDs.\n  fun getNewUid(): UUID\n\n  // Function to fetch a list of books from the repository.\n  // Parameters:\n  // - OnSucess: A callback function that receives the list of books when the operation succeeds.\n  // - onFailure: A callback function that receives an exception if the operation fails.\n  fun getBook(OnSucess: (List<DataBook>) -> Unit, onFailure: (Exception) -> Unit)\n\n  // Function to add a new book to the repository.\n  // Parameters:\n  // - dataBook: The book data to be added.\n  // - OnSucess: A callback function that receives the updated list of books when the operation\n  // succeeds.\n  // - onFailure: A callback function that receives an exception if the operation fails.\n  fun addBook(dataBook: DataBook, OnSucess: () -> Unit, onFailure: (Exception) -> Unit)\n\n  // Function to update an existing book in the repository.\n  // Parameters:\n  // - dataBook: The book data to be updated.\n  // - OnSucess: A callback function that receives the updated list of books when the operation\n  // succeeds.\n  // - onFailure: A callback function that receives an exception if the operation fails.\n  fun updateBook(dataBook: DataBook, OnSucess: () -> Unit, onFailure: (Exception) -> Unit)\n\n  // Function to delete a book from the repository.\n  // Parameters:\n  // - id: The unique identifier of the book to be deleted.\n  // - dataBook: The book data to be deleted (can also just use the ID).\n  // - OnSucess: A callback function that receives the updated list of books when the operation\n  // succeeds.\n  // - onFailure: A callback function that receives an exception if the operation fails.\n  fun deleteBooks(\n      id: String,\n      dataBook: DataBook,\n      OnSucess: () -> Unit,\n      onFailure: (Exception) -> Unit\n  )\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/repository/BookRepository.kt b/app/src/main/java/com/android/bookswap/data/repository/BookRepository.kt
--- a/app/src/main/java/com/android/bookswap/data/repository/BookRepository.kt	
+++ b/app/src/main/java/com/android/bookswap/data/repository/BookRepository.kt	
@@ -3,51 +3,51 @@
 import com.android.bookswap.data.DataBook
 import java.util.UUID
 
-// Interface defining a contract for managing book-related operations in a repository.
+/** Interface defining a contract for managing book-related operations in a repository. */
 interface BooksRepository {
 
-  // Function to initialize the repository. This can be used to set up data or resources.
-  // This default implementation does nothing, but subclasses can override it.
-  fun init(OnSucess: () -> Unit)
+  /**
+   * Function to initialize the repository. This can be used to set up data or resources. This
+   * default implementation does nothing, but subclasses can override it.
+   */
+  fun init(onSuccess: () -> Unit)
 
-  // Function to generate and return a new unique identifier (UID) for a book.
-  // This default implementation returns an empty string, but it should be overridden to generate
-  // actual UIDs.
-  fun getNewUid(): UUID
+  /**
+   * Function to generate and return a new unique identifier (UUID) for a book. This default
+   * implementation returns an empty string, but it should be overridden to generate actual UUIDs.
+   */
+  fun getNewUUID(): UUID
 
-  // Function to fetch a list of books from the repository.
-  // Parameters:
-  // - OnSucess: A callback function that receives the list of books when the operation succeeds.
-  // - onFailure: A callback function that receives an exception if the operation fails.
-  fun getBook(OnSucess: (List<DataBook>) -> Unit, onFailure: (Exception) -> Unit)
+  /**
+   * Function to fetch a list of books from the repository.
+   *
+   * @param callback A callback function that receives the list of books when the operation succeeds
+   *   or an exception if it fails
+   */
+  fun getBook(callback: (Result<List<DataBook>>) -> Unit)
 
-  // Function to add a new book to the repository.
-  // Parameters:
-  // - dataBook: The book data to be added.
-  // - OnSucess: A callback function that receives the updated list of books when the operation
-  // succeeds.
-  // - onFailure: A callback function that receives an exception if the operation fails.
-  fun addBook(dataBook: DataBook, OnSucess: () -> Unit, onFailure: (Exception) -> Unit)
+  /**
+   * Function to add a new book to the repository
+   *
+   * @param dataBook The book data to be added
+   * @param callback A callback function that receives an exception if the operation fails
+   */
+  fun addBook(dataBook: DataBook, callback: (Result<Unit>) -> Unit)
 
-  // Function to update an existing book in the repository.
-  // Parameters:
-  // - dataBook: The book data to be updated.
-  // - OnSucess: A callback function that receives the updated list of books when the operation
-  // succeeds.
-  // - onFailure: A callback function that receives an exception if the operation fails.
-  fun updateBook(dataBook: DataBook, OnSucess: () -> Unit, onFailure: (Exception) -> Unit)
+  /**
+   * Function to update an existing book in the repository.
+   *
+   * @param dataBook The book data to be updated
+   * @param callback A callback function that receives an exception if the operation fails
+   */
+  fun updateBook(dataBook: DataBook, callback: (Result<Unit>) -> Unit)
 
-  // Function to delete a book from the repository.
-  // Parameters:
-  // - id: The unique identifier of the book to be deleted.
-  // - dataBook: The book data to be deleted (can also just use the ID).
-  // - OnSucess: A callback function that receives the updated list of books when the operation
-  // succeeds.
-  // - onFailure: A callback function that receives an exception if the operation fails.
-  fun deleteBooks(
-      id: String,
-      dataBook: DataBook,
-      OnSucess: () -> Unit,
-      onFailure: (Exception) -> Unit
-  )
+  /**
+   * Function to delete a book from the repository.
+   *
+   * @param uuid The unique identifier of the book to be deleted.
+   * @param dataBook The book data to be deleted (can also just use the uuid).
+   * @param callback A callback function that receives an exception if the operation fails.
+   */
+  fun deleteBooks(uuid: UUID, dataBook: DataBook, callback: (Result<Unit>) -> Unit)
 }
Index: app/src/main/java/com/android/bookswap/data/DataBook.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.data\n\nimport java.util.UUID\n\n/**\n * Represent a book with various properties\n *\n * @param uuid Internal id for the book\n * @param title Title of the book\n * @param author Author of the book\n * @param description Short description of the book\n * @param rating Rating of the book out of 5 (if applicable)\n * @param photo Photo of a book\n * @param language Language of the book\n * @param isbn ISBN of the book (International Standard Book Number)\n */\ndata class DataBook(\n    val uuid: UUID,\n    val title: String,\n    val author: String?,\n    val description: String?,\n    val rating: Int?,\n    val photo: String?,\n    val language: BookLanguages,\n    val isbn: String?,\n    val genres: List<BookGenres> = emptyList()\n)\n\n/** All supported book language type */\nenum class BookLanguages(val languageCode: String) {\n  FRENCH(\"FR\"), // French language\n  GERMAN(\"DE\"), // German language\n  ENGLISH(\"EN\"), // English language\n  SPANISH(\"ES\"), // Spanish language\n  ITALIAN(\"IT\"), // Italian language\n  ROMANSH(\"RM\"), // Romansh, a language spoken in Switzerland\n  OTHER(\"OTHER\") // All languages that are not yet implemented\n}\n/** Genre of a book */\nenum class BookGenres(val Genre: String = \"Other\") {\n  FICTION(\"Fiction\"),\n  NONFICTION(\"Non-Fiction\"),\n  FANTASY(\"Fantasy\"),\n  SCIENCEFICTION(\"Science-Fiction\"),\n  MYSTERY(\"Mystery\"),\n  THRILLER(\"Thriller\"),\n  ROMANCE(\"Romance\"),\n  HORROR(\"Horror\"),\n  HISTORICAL(\"Historical\"),\n  WESTERN(\"Western\"),\n  DYSTOPIAN(\"Dystopian\"),\n  MEMOIR(\"Memoir\"),\n  BIOGRAPHY(\"Biography\"),\n  AUTOBIOGRAPHY(\"Autobiography\"),\n  SELFHELP(\"Self-Help\"),\n  HEALTH(\"Health\"),\n  TRAVEL(\"Travel\"),\n  GUIDE(\"Guide\"),\n  OTHER(\"Other\") // Allows custom genre name\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/DataBook.kt b/app/src/main/java/com/android/bookswap/data/DataBook.kt
--- a/app/src/main/java/com/android/bookswap/data/DataBook.kt	
+++ b/app/src/main/java/com/android/bookswap/data/DataBook.kt	
@@ -5,7 +5,7 @@
 /**
  * Represent a book with various properties
  *
- * @param uuid Internal id for the book
+ * @param uuid Internal uuid for the book
  * @param title Title of the book
  * @param author Author of the book
  * @param description Short description of the book
Index: app/src/main/java/com/android/bookswap/ui/chat/ListChat.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.chat\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxHeight\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Person\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.HorizontalDivider\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.material3.TopAppBarDefaults\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.testTag\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.text.style.TextOverflow\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport com.android.bookswap.model.chat.MessageBox\nimport com.android.bookswap.ui.navigation.BottomNavigationMenu\nimport com.android.bookswap.ui.navigation.List_Navigation_Bar_Destinations\nimport com.android.bookswap.ui.navigation.NavigationActions\nimport com.android.bookswap.ui.navigation.Screen\nimport com.android.bookswap.ui.profile.ProfileIcon\nimport com.android.bookswap.ui.theme.ColorVariable\n\n/** This is the main screen for the chat feature. It displays the list of messages */\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun ListChatScreen(\n    placeHolderData: List<MessageBox> = emptyList(),\n    navigationActions: NavigationActions\n) {\n  Scaffold(\n      modifier = Modifier.testTag(\"chat_listScreen\"),\n      topBar = {\n        TopAppBar(\n            colors =\n                TopAppBarDefaults.smallTopAppBarColors(\n                    containerColor = ColorVariable.BackGround,\n                ),\n            title = {\n              Box(\n                  modifier = Modifier.fillMaxSize().testTag(\"chat_messageScreenTitle\"),\n                  contentAlignment = Alignment.Center) {\n                    Text(\n                        text = \"Messages\",\n                        style =\n                            TextStyle(\n                                fontSize = 30.sp,\n                                lineHeight = 20.sp,\n                                fontWeight = FontWeight(700),\n                                color = ColorVariable.Accent,\n                                letterSpacing = 0.3.sp,\n                            ))\n                  }\n            },\n            actions = { ProfileIcon() })\n      },\n      content = { pv ->\n        LazyColumn(\n            contentPadding = pv,\n            modifier =\n                Modifier.fillMaxSize()\n                    .background(color = ColorVariable.BackGround)\n                    .testTag(\"chat_messageList\")) {\n              item { MessageDivider() }\n              if (placeHolderData.isEmpty()) {\n                item {\n                  Text(\n                      text = \"No messages yet\",\n                      modifier = Modifier.fillMaxWidth().padding(16.dp),\n                      color = ColorVariable.Primary,\n                      fontSize = 20.sp,\n                      fontWeight = FontWeight.Bold,\n                      textAlign = TextAlign.Center)\n                }\n              } else {\n                items(placeHolderData.size) { message ->\n                  MessageBoxDisplay(placeHolderData[message]) {\n                    navigationActions.navigateTo(\n                        Screen.CHAT, \"user123\", placeHolderData[message].contactName)\n                  }\n                  MessageDivider()\n                }\n              }\n            }\n      },\n      bottomBar = {\n        BottomNavigationMenu(\n            onTabSelect = { destination -> navigationActions.navigateTo(destination) },\n            tabList = List_Navigation_Bar_Destinations,\n            selectedItem = navigationActions.currentRoute())\n      })\n}\n\n/*\nThis function is used to display the message box\n */\n@Composable\nfun MessageBoxDisplay(message: MessageBox, onClick: () -> Unit = {}) {\n  Row(\n      Modifier.fillMaxWidth()\n          .height(55.dp)\n          .background(color = ColorVariable.BackGround)\n          .clickable(onClick = onClick)\n          .testTag(\"chat_messageBox\"),\n  ) {\n    Icon(\n        imageVector = Icons.Filled.Person,\n        contentDescription = \"Contact Icon\",\n        modifier = Modifier.size(40.dp).align(Alignment.CenterVertically).fillMaxHeight(),\n    )\n    Column(\n        modifier = Modifier.weight(1f).padding(start = 8.dp, end = 8.dp, top = 4.dp),\n        verticalArrangement = Arrangement.Center) {\n          Row(\n              modifier = Modifier.fillMaxWidth(),\n              horizontalArrangement = Arrangement.SpaceBetween) {\n                Text(\n                    text = message.contactName,\n                    fontWeight = FontWeight.Medium,\n                    fontSize = 18.sp,\n                    color = ColorVariable.Accent,\n                    modifier = Modifier.testTag(\"chat_messageContactName\"))\n                Text(\n                    text = message.date,\n                    fontSize = 14.sp,\n                    color = ColorVariable.AccentSecondary,\n                    modifier = Modifier.testTag(\"chat_messageDate\"))\n              }\n\n          Text(\n              text = message.message,\n              fontSize = 14.sp,\n              color = ColorVariable.AccentSecondary,\n              maxLines = 1,\n              overflow = TextOverflow.Ellipsis,\n              modifier = Modifier.testTag(\"chat_messageContent\"))\n        }\n  }\n}\n\n/** This function is used to display a divider between the messages */\n@Composable\nfun MessageDivider() {\n  HorizontalDivider(\n      modifier = Modifier.fillMaxWidth().border(width = 2.dp, color = Color(0xFF6C584C)))\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/chat/ListChat.kt b/app/src/main/java/com/android/bookswap/ui/chat/ListChat.kt
--- a/app/src/main/java/com/android/bookswap/ui/chat/ListChat.kt	
+++ b/app/src/main/java/com/android/bookswap/ui/chat/ListChat.kt	
@@ -4,7 +4,6 @@
 import androidx.compose.foundation.border
 import androidx.compose.foundation.clickable
 import androidx.compose.foundation.layout.Arrangement
-import androidx.compose.foundation.layout.Box
 import androidx.compose.foundation.layout.Column
 import androidx.compose.foundation.layout.Row
 import androidx.compose.foundation.layout.fillMaxHeight
@@ -21,25 +20,19 @@
 import androidx.compose.material3.Icon
 import androidx.compose.material3.Scaffold
 import androidx.compose.material3.Text
-import androidx.compose.material3.TopAppBar
-import androidx.compose.material3.TopAppBarDefaults
 import androidx.compose.runtime.Composable
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.platform.testTag
-import androidx.compose.ui.text.TextStyle
 import androidx.compose.ui.text.font.FontWeight
 import androidx.compose.ui.text.style.TextAlign
 import androidx.compose.ui.text.style.TextOverflow
 import androidx.compose.ui.unit.dp
 import androidx.compose.ui.unit.sp
-import com.android.bookswap.model.chat.MessageBox
-import com.android.bookswap.ui.navigation.BottomNavigationMenu
-import com.android.bookswap.ui.navigation.List_Navigation_Bar_Destinations
+import com.android.bookswap.data.MessageBox
 import com.android.bookswap.ui.navigation.NavigationActions
 import com.android.bookswap.ui.navigation.Screen
-import com.android.bookswap.ui.profile.ProfileIcon
 import com.android.bookswap.ui.theme.ColorVariable
 
 /** This is the main screen for the chat feature. It displays the list of messages */
@@ -47,34 +40,13 @@
 @Composable
 fun ListChatScreen(
     placeHolderData: List<MessageBox> = emptyList(),
-    navigationActions: NavigationActions
+    navigationActions: NavigationActions,
+    topAppBar: @Composable () -> Unit = {},
+    bottomAppBar: @Composable () -> Unit = {},
 ) {
   Scaffold(
       modifier = Modifier.testTag("chat_listScreen"),
-      topBar = {
-        TopAppBar(
-            colors =
-                TopAppBarDefaults.smallTopAppBarColors(
-                    containerColor = ColorVariable.BackGround,
-                ),
-            title = {
-              Box(
-                  modifier = Modifier.fillMaxSize().testTag("chat_messageScreenTitle"),
-                  contentAlignment = Alignment.Center) {
-                    Text(
-                        text = "Messages",
-                        style =
-                            TextStyle(
-                                fontSize = 30.sp,
-                                lineHeight = 20.sp,
-                                fontWeight = FontWeight(700),
-                                color = ColorVariable.Accent,
-                                letterSpacing = 0.3.sp,
-                            ))
-                  }
-            },
-            actions = { ProfileIcon() })
-      },
+      topBar = topAppBar,
       content = { pv ->
         LazyColumn(
             contentPadding = pv,
@@ -97,19 +69,14 @@
                 items(placeHolderData.size) { message ->
                   MessageBoxDisplay(placeHolderData[message]) {
                     navigationActions.navigateTo(
-                        Screen.CHAT, "user123", placeHolderData[message].contactName)
+                        Screen.CHAT, placeHolderData[message].contact.userUUID.toString())
                   }
                   MessageDivider()
                 }
               }
             }
       },
-      bottomBar = {
-        BottomNavigationMenu(
-            onTabSelect = { destination -> navigationActions.navigateTo(destination) },
-            tabList = List_Navigation_Bar_Destinations,
-            selectedItem = navigationActions.currentRoute())
-      })
+      bottomBar = bottomAppBar)
 }
 
 /*
@@ -136,7 +103,7 @@
               modifier = Modifier.fillMaxWidth(),
               horizontalArrangement = Arrangement.SpaceBetween) {
                 Text(
-                    text = message.contactName,
+                    text = message.contact.firstName + " " + message.contact.lastName,
                     fontWeight = FontWeight.Medium,
                     fontSize = 18.sp,
                     color = ColorVariable.Accent,
Index: app/src/main/java/com/android/bookswap/ui/profile/profileIcon.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.android.bookswap.ui.profile\n\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.AccountCircle\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.testTag\nimport androidx.compose.ui.unit.dp\nimport com.android.bookswap.ui.theme.ColorVariable\n\n/** Profile Icon for the top app bar */\n@Composable\nfun ProfileIcon() {\n  IconButton(onClick = { /*TODO*/}, modifier = Modifier.testTag(\"profileIconButton\")) {\n    Icon(\n        Icons.Filled.AccountCircle,\n        contentDescription = \"Profile Icon\",\n        tint = ColorVariable.Accent,\n        modifier = Modifier.size(32.dp).testTag(\"profileIcon\"))\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/profile/profileIcon.kt b/app/src/main/java/com/android/bookswap/ui/profile/profileIcon.kt
--- a/app/src/main/java/com/android/bookswap/ui/profile/profileIcon.kt	
+++ b/app/src/main/java/com/android/bookswap/ui/profile/profileIcon.kt	
@@ -9,16 +9,19 @@
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.platform.testTag
 import androidx.compose.ui.unit.dp
+import com.android.bookswap.ui.navigation.NavigationActions
 import com.android.bookswap.ui.theme.ColorVariable
 
 /** Profile Icon for the top app bar */
 @Composable
-fun ProfileIcon() {
-  IconButton(onClick = { /*TODO*/}, modifier = Modifier.testTag("profileIconButton")) {
-    Icon(
-        Icons.Filled.AccountCircle,
-        contentDescription = "Profile Icon",
-        tint = ColorVariable.Accent,
-        modifier = Modifier.size(32.dp).testTag("profileIcon"))
-  }
+fun ProfileIcon(navigationActions: NavigationActions) {
+  IconButton(
+      onClick = { navigationActions.navigateTo("Profile Screen") },
+      modifier = Modifier.testTag("profileIconButton")) {
+        Icon(
+            Icons.Filled.AccountCircle,
+            contentDescription = "Profile Icon",
+            tint = ColorVariable.Accent,
+            modifier = Modifier.size(32.dp).testTag("profileIcon"))
+      }
 }
Index: app/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><resources>\n    <string name=\"app_name\">BookSwapApp</string>\n    <string name=\"title_activity_main\">MainActivity</string>\n    <string name=\"default_web_client_id\">53350524991-rim3tpfdgv2ghibl586ku7fvq6ngcddn.apps.googleusercontent.com</string>\n</resources>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/values/strings.xml b/app/src/main/res/values/strings.xml
--- a/app/src/main/res/values/strings.xml	
+++ b/app/src/main/res/values/strings.xml	
@@ -2,4 +2,7 @@
     <string name="app_name">BookSwapApp</string>
     <string name="title_activity_main">MainActivity</string>
     <string name="default_web_client_id">53350524991-rim3tpfdgv2ghibl586ku7fvq6ngcddn.apps.googleusercontent.com</string>
+    <string name="prompt">You are an AI designed to analyze images of book covers. Given an image of a book\'s back cover in URL format, extract the following information in a structured format (JSON) with the specified fields: title, author, description, language, and ISBN. Please ensure that: 1. If any of the fields are not present or cannot be confidently identified, indicate them with \"N/A\". 2. If the image does not appear to be a book cover, return an error message stating \"The image does not appear to be a valid book cover.\" 3. If the title, author, description, or other fields are in a different language, keep the original text for reference, and provide the appropriate language code using the following classification: - FRENCH (\"FR\") - GERMAN (\"DE\") - ENGLISH (\"EN\") - SPANISH (\"ES\") - ITALIAN (\"IT\") - ROMANSH (\"RM\") - OTHER (\"OTHER\") 4. The description should be the one written on the book\'s. 5. The ISBN is often over a barcode, in the bottom left or right corner. Example output format: { \"title\": \"Example Title\", \"author\": \"Example Author\", \"description\": \"An example description of the book.\", \"language\": \"EN\", \"isbn\": \"1234567890\" } The image URL:
+</string>
+
 </resources>
\ No newline at end of file
Index: app/src/main/java/com/android/bookswap/data/source/api/ChatGPTApiService.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/source/api/ChatGPTApiService.kt b/app/src/main/java/com/android/bookswap/data/source/api/ChatGPTApiService.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/data/source/api/ChatGPTApiService.kt	
@@ -0,0 +1,88 @@
+package com.android.bookswap.data.source.api
+
+import android.content.Context
+import android.util.Log
+import com.android.bookswap.BuildConfig
+import com.android.volley.RequestQueue
+import com.android.volley.Response
+import com.android.volley.toolbox.JsonObjectRequest
+import com.android.volley.toolbox.Volley
+import org.json.JSONArray
+import org.json.JSONObject
+
+data class ChatGPTMessage(
+    val role: String, // "user" or "assistant"
+    val content: String
+)
+
+data class ChatGPTRequest(val model: String, val messages: List<ChatGPTMessage>)
+
+/**
+ * Service to interact with the OpenAI ChatGPT API.
+ *
+ * @param context the context from where the request is made
+ * @param mode true for production mode, false for testing mode
+ */
+class ChatGPTApiService(context: Context, mode: Boolean = true) : ApiService {
+  private val requestQueue: RequestQueue = Volley.newRequestQueue(context)
+  private val apiKey = if (mode) BuildConfig.OPENAI_API_KEY else ""
+  private val apiUrl = "https://api.openai.com/v1/chat/completions"
+
+  // Send a chat request to the OpenAI API
+  override fun sendChatRequest(
+      userMessages: List<String>,
+      onSuccess: (String) -> Unit,
+      onError: (String) -> Unit
+  ) {
+    val messageList = userMessages.map { m -> ChatGPTMessage(role = "user", content = m) }
+    val chatGPTRequest = ChatGPTRequest(model = "gpt-4o-mini", messages = messageList)
+
+    // Create the JSON body for the request
+    val jsonBody =
+        JSONObject().apply {
+          put("model", chatGPTRequest.model)
+          put(
+              "messages",
+              JSONArray().apply {
+                chatGPTRequest.messages.forEach { message ->
+                  put(
+                      JSONObject().apply {
+                        put("role", message.role)
+                        put("content", message.content)
+                      })
+                }
+              })
+        }
+
+    // Create the request and listen for the response
+    val jsonObjectRequest =
+        object :
+            JsonObjectRequest(
+                Method.POST,
+                apiUrl,
+                jsonBody,
+                Response.Listener { response ->
+                  try {
+                    val choicesArray = response.getJSONArray("choices")
+                    val messageContent =
+                        choicesArray.getJSONObject(0).getJSONObject("message").getString("content")
+
+                    onSuccess(messageContent)
+                  } catch (e: Exception) {
+                    Log.e("ChatGPTApiService", "Error: ${e.localizedMessage}")
+                    onError("Parsing error: ${e.localizedMessage}")
+                  }
+                },
+                Response.ErrorListener { error ->
+                  Log.e("ChatGPTApiService", "Error: ${error.localizedMessage}")
+                  onError("Request error: ${error.localizedMessage}")
+                }) {
+          // Add the API key and content type to the request headers
+          override fun getHeaders(): MutableMap<String, String> {
+            return hashMapOf(
+                "Authorization" to "Bearer $apiKey", "Content-Type" to "application/json")
+          }
+        }
+    requestQueue.add(jsonObjectRequest)
+  }
+}
Index: app/src/main/java/com/android/bookswap/data/source/api/ApiService.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/source/api/ApiService.kt b/app/src/main/java/com/android/bookswap/data/source/api/ApiService.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/data/source/api/ApiService.kt	
@@ -0,0 +1,18 @@
+package com.android.bookswap.data.source.api
+/*
+  This interface is used to send a chat request to the API
+*/
+interface ApiService {
+  /**
+   * Send a chat request to the API
+   *
+   * @param userMessages List of user messages to send
+   * @param onSuccess Callback for a successful response
+   * @param onError Callback for handling errors
+   */
+  fun sendChatRequest(
+      userMessages: List<String>,
+      onSuccess: (String) -> Unit,
+      onError: (String) -> Unit
+  )
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/MainActivityTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/MainActivityTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/MainActivityTest.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/androidTest/java/com/android/bookswap/ui/MainActivityTest.kt	
@@ -0,0 +1,17 @@
+package com.android.bookswap.ui
+
+import androidx.compose.ui.test.junit4.createAndroidComposeRule
+import androidx.compose.ui.test.onNodeWithTag
+import com.android.bookswap.MainActivity
+import org.junit.Rule
+import org.junit.Test
+
+class MainActivityTest {
+  @get:Rule val androidComposeRule = createAndroidComposeRule<MainActivity>()
+
+  @Test
+  fun testMainActivity() {
+    androidComposeRule.onNodeWithTag("main_screen_container").assertExists()
+    androidComposeRule.onNodeWithTag("SignInScreen").assertExists()
+  }
+}
Index: app/src/main/java/com/android/bookswap/ui/books/edit/EditBookScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/books/edit/EditBookScreen.kt b/app/src/main/java/com/android/bookswap/ui/books/edit/EditBookScreen.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/ui/books/edit/EditBookScreen.kt	
@@ -0,0 +1,323 @@
+package com.android.bookswap.ui.books.edit
+
+import android.widget.Toast
+import androidx.compose.foundation.background
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.widthIn
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.automirrored.filled.ArrowBack
+import androidx.compose.material3.Button
+import androidx.compose.material3.ButtonDefaults
+import androidx.compose.material3.DropdownMenuItem
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.ExposedDropdownMenuBox
+import androidx.compose.material3.ExposedDropdownMenuDefaults
+import androidx.compose.material3.Icon
+import androidx.compose.material3.IconButton
+import androidx.compose.material3.OutlinedTextField
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.Text
+import androidx.compose.material3.TextFieldDefaults
+import androidx.compose.material3.TopAppBar
+import androidx.compose.material3.TopAppBarDefaults
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.setValue
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.platform.LocalConfiguration
+import androidx.compose.ui.platform.LocalContext
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.unit.dp
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.source.network.BooksFirestoreSource
+import com.android.bookswap.ui.books.add.createDataBook
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.theme.ColorVariable
+
+/** Constants * */
+private val SCREEN_PADDING = 16.dp
+private val ELEMENT_SPACING = 8.dp
+private val BUTTON_SPACER_HEIGHT = 16.dp
+private const val COLUMN_WIDTH_RATIO = 0.9f // Column width as 90% of screen width
+
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun EditBookScreen(
+    booksRepository: BooksFirestoreSource,
+    navigationActions: NavigationActions,
+    book: DataBook
+) {
+
+  val configuration = LocalConfiguration.current
+  val screenWidth = configuration.screenWidthDp.dp
+  val columnMaxWidth = screenWidth * COLUMN_WIDTH_RATIO
+  /*val book =
+      booksRepository.selectedBook.collectAsState().value
+          ?: return Text(text = "No Book selected. Should not happen", color = Color.Red)
+  */
+  // Use this and modify the editBookScreen structure if needed when incorporating in the app
+  // navigation
+
+  var title by remember { mutableStateOf(book.title) }
+  var author by remember { mutableStateOf(book.author ?: "") }
+  var description by remember { mutableStateOf(book.description ?: "") }
+  var rating by remember { mutableStateOf(book.rating?.toString() ?: "") }
+  var photo by remember { mutableStateOf(book.photo ?: "") }
+  var language by remember { mutableStateOf(book.language.toString()) }
+  var genres by remember { mutableStateOf(book.genres) }
+  var selectedGenre by remember { mutableStateOf<BookGenres?>(null) } // Genre selection state
+  var expanded by remember { mutableStateOf(false) } // State for dropdown menu
+
+  val context = LocalContext.current
+
+  Scaffold(
+      modifier = Modifier.testTag("editBookScreen").background(ColorVariable.BackGround),
+      containerColor = ColorVariable.BackGround, // Sets entire Scaffold background color
+      topBar = {
+        TopAppBar(
+            title = { Text("Edit your Book", modifier = Modifier.testTag("editBookTitle")) },
+            navigationIcon = {
+              IconButton(
+                  modifier = Modifier.testTag("goBackButton"),
+                  onClick = { navigationActions.goBack() }) {
+                    Icon(
+                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
+                        contentDescription = "Back")
+                  }
+            },
+            colors = TopAppBarDefaults.topAppBarColors(containerColor = ColorVariable.BackGround))
+      },
+      content = { paddingValues ->
+        LazyColumn(
+            modifier =
+                Modifier.fillMaxWidth()
+                    .padding(paddingValues)
+                    .padding(SCREEN_PADDING)
+                    .widthIn(max = columnMaxWidth)
+                    .background(ColorVariable.BackGround)
+                    .testTag("editBookScreenColumn"),
+            verticalArrangement = Arrangement.spacedBy(ELEMENT_SPACING)) {
+              // Title Edit Field
+              item {
+                OutlinedTextField(
+                    value = title,
+                    onValueChange = { title = it },
+                    label = { Text("Title") },
+                    placeholder = { Text("Enter the book title") },
+                    modifier = Modifier.fillMaxWidth().testTag("inputBookTitle"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+
+              item {
+                // Genre Dropdown Edit Field
+                ExposedDropdownMenuBox(
+                    expanded = expanded,
+                    onExpandedChange = { expanded = !expanded },
+                    modifier = Modifier.fillMaxWidth().testTag("GenreDropdown")) {
+                      OutlinedTextField(
+                          value = selectedGenre?.Genre ?: "Select Genre",
+                          onValueChange = {},
+                          label = { Text("Genre") },
+                          readOnly = true,
+                          trailingIcon = {
+                            ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)
+                          },
+                          modifier = Modifier.menuAnchor().testTag("SelectedGenre"),
+                          colors =
+                              TextFieldDefaults.outlinedTextFieldColors(
+                                  containerColor = ColorVariable.Secondary,
+                                  focusedBorderColor = Color.Black,
+                                  unfocusedBorderColor = Color.Black))
+                      ExposedDropdownMenu(
+                          expanded = expanded, onDismissRequest = { expanded = false }) {
+                            BookGenres.values().forEach { genre ->
+                              DropdownMenuItem(
+                                  text = { Text(text = genre.Genre) },
+                                  modifier = Modifier.testTag("GenreDropdownItem_${genre.Genre}"),
+                                  onClick = {
+                                    selectedGenre = genre
+                                    genres = listOf(genre) // Update genres list with selected genre
+                                    expanded = false
+                                  })
+                            }
+                          }
+                    }
+              }
+
+              item {
+                // Author Edit Field
+                OutlinedTextField(
+                    value = author,
+                    onValueChange = { author = it },
+                    label = { Text("Author") },
+                    placeholder = { Text("Enter the author's name") },
+                    modifier = Modifier.fillMaxWidth().testTag("inputBookAuthor"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+
+              item {
+                // Description Edit Field
+                OutlinedTextField(
+                    value = description,
+                    onValueChange = { description = it },
+                    label = { Text("Description") },
+                    placeholder = { Text("Provide a description of the book") },
+                    modifier = Modifier.fillMaxWidth().testTag("inputBookDescription"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+
+              item {
+                // Rating Edit Field
+                OutlinedTextField(
+                    value = rating,
+                    onValueChange = { rating = it },
+                    label = { Text("Rating") },
+                    placeholder = { Text("Rate the book (e.g. 4.5)") },
+                    modifier = Modifier.fillMaxWidth().testTag("inputBookRating"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+              // ISBN Edit Field
+              /*OutlinedTextField(
+                  value = isbn,
+                  onValueChange = { isbn = it },
+                  label = { Text("ISBN") },
+                  placeholder = { Text("ISBN Number") },
+                  modifier = Modifier.fillMaxWidth().testTag("inputBookISBN")
+              )*/
+              // Remove for now but could be added later
+
+              item {
+                // Photo Edit Field
+                OutlinedTextField(
+                    value = photo,
+                    onValueChange = { photo = it },
+                    label = { Text("Photo ") },
+                    placeholder = { Text("Enter a photo of the books") },
+                    modifier = Modifier.testTag("inputBookPhoto"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+
+              item {
+                // Language Edit Field
+                OutlinedTextField(
+                    value = language,
+                    onValueChange = { language = it },
+                    label = { Text("Language ") },
+                    placeholder = { Text("In which language are the book") },
+                    modifier = Modifier.testTag("inputBookLanguage"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+              item { Spacer(modifier = Modifier.height(BUTTON_SPACER_HEIGHT)) }
+
+              item {
+                Button(
+                    onClick = {
+                      try {
+                        if (title.isBlank())
+                            throw IllegalArgumentException("Title cannot be null or blank")
+                        if (author.isBlank())
+                            throw IllegalArgumentException("Author cannot be null or blank")
+                        if (description.isBlank())
+                            throw IllegalArgumentException("Description cannot be null or blank")
+                        if (rating.isBlank())
+                            throw IllegalArgumentException("Rating cannot be null or blank")
+                        if (photo.isBlank())
+                            throw IllegalArgumentException("Photo cannot be null or blank")
+                        if (language.isBlank())
+                            throw IllegalArgumentException("Language cannot be null or blank")
+                        if (book.isbn.isNullOrBlank())
+                            throw IllegalArgumentException("ISBN cannot be null or blank")
+                        if (genres.isEmpty())
+                            throw IllegalArgumentException("Genres cannot be empty")
+
+                        val updatedBook =
+                            createDataBook(
+                                context = context,
+                                uuid = book.uuid,
+                                title = title,
+                                author = author,
+                                description = description,
+                                ratingStr = rating,
+                                photo = photo,
+                                bookLanguageStr = language,
+                                isbn = book.isbn,
+                                genres = genres)
+
+                        booksRepository.updateBook(
+                            updatedBook!!,
+                            callback = { result ->
+                              if (result.isSuccess) {
+                                navigationActions.goBack()
+                              } else {
+                                Toast.makeText(
+                                        context, "Failed to update book.", Toast.LENGTH_SHORT)
+                                    .show()
+                              }
+                            })
+                      } catch (e: Exception) {
+                        Toast.makeText(context, "Error: ${e.message}", Toast.LENGTH_SHORT).show()
+                      }
+                    },
+                    modifier = Modifier.fillMaxWidth().testTag("bookSave"),
+                    enabled = title.isNotBlank(),
+                    colors = ButtonDefaults.buttonColors(containerColor = ColorVariable.Primary)) {
+                      Text("Save", color = Color.White)
+                    }
+              }
+
+              item {
+                Button(
+                    onClick = {
+                      booksRepository.deleteBooks(
+                          book.uuid,
+                          book,
+                          callback = { result ->
+                            if (result.isSuccess) {
+                              navigationActions.goBack()
+                            } else {
+                              Toast.makeText(context, "Failed to delete book.", Toast.LENGTH_SHORT)
+                                  .show()
+                            }
+                          })
+                    },
+                    modifier = Modifier.fillMaxWidth().testTag("bookDelete"),
+                    colors = ButtonDefaults.buttonColors(containerColor = ColorVariable.Primary)) {
+                      Text("Delete", color = Color.White)
+                    }
+              }
+            }
+      })
+}
Index: app/src/main/java/com/android/bookswap/data/DataPhoto.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/DataPhoto.kt b/app/src/main/java/com/android/bookswap/data/DataPhoto.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/data/DataPhoto.kt	
@@ -0,0 +1,10 @@
+package com.android.bookswap.data
+
+import java.util.UUID
+
+data class DataPhoto(
+    val uuid: UUID, // UUID,
+    val url: String,
+    val timestamp: Long,
+    val base64: String,
+)
Index: app/src/main/java/com/android/bookswap/data/MessageBox.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/MessageBox.kt b/app/src/main/java/com/android/bookswap/data/MessageBox.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/data/MessageBox.kt	
@@ -0,0 +1,4 @@
+package com.android.bookswap.data
+
+/** Data class for the message box */
+data class MessageBox(val contact: DataUser, val message: String, val date: String)
Index: app/src/main/java/com/android/bookswap/data/UserBooksWithLocation.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/UserBooksWithLocation.kt b/app/src/main/java/com/android/bookswap/data/UserBooksWithLocation.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/data/UserBooksWithLocation.kt	
@@ -0,0 +1,18 @@
+package com.android.bookswap.data
+
+import java.util.UUID
+
+/**
+ * Represents a user's book collection along with their geographical location.
+ *
+ * @property userUUID Unique identifier for the user.
+ * @property longitude The user's longitude coordinate.
+ * @property latitude The user's latitude coordinate.
+ * @property books List of books associated with the user.
+ */
+data class UserBooksWithLocation(
+    val userUUID: UUID,
+    val longitude: Double,
+    val latitude: Double,
+    val books: List<DataBook>
+)
Index: app/src/main/java/com/android/bookswap/data/source/network/PhotoFirestoreSource.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/source/network/PhotoFirestoreSource.kt b/app/src/main/java/com/android/bookswap/data/source/network/PhotoFirestoreSource.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/data/source/network/PhotoFirestoreSource.kt	
@@ -0,0 +1,167 @@
+package com.android.bookswap.data.source.network
+
+import android.graphics.Bitmap
+import android.graphics.BitmapFactory
+import android.util.Base64
+import android.util.Log
+import com.android.bookswap.data.DataPhoto
+import com.android.bookswap.data.repository.PhotoRepository
+import com.google.android.gms.tasks.Task
+import com.google.firebase.firestore.DocumentSnapshot
+import com.google.firebase.firestore.FirebaseFirestore
+import java.io.ByteArrayOutputStream
+import java.util.UUID
+
+/** Constants : */
+/** Name of the Firestore collection that stores users */
+const val PHOTO_COLLECTION_PATH = "photos"
+/** Quality of the compressed image */
+const val COMPRESSION_QUALITY = 70
+/** Offset for the byte array */
+const val OFFSET = 0
+
+/**
+ * A class that implements the PhotoRepository interface using Firebase Firestore as the data
+ * source.
+ *
+ * @property db The Firestore database instance.
+ */
+class PhotoFirestoreSource(private val db: FirebaseFirestore) : PhotoRepository {
+
+  /**
+   * Generates and returns a new unique ID for a photo in Firestore.
+   *
+   * @return A new UUID.
+   */
+  override fun getNewUUID(): UUID {
+    return UUID.randomUUID()
+  }
+
+  /**
+   * Initializes the PhotoFirestoreSource.
+   *
+   * @param callback A callback function that receives Result.success(Unit) on success or
+   *   Result.failure(exception) on failure.
+   */
+  override fun init(callback: (Result<Unit>) -> Unit) {
+    try {
+      callback(Result.success(Unit))
+    } catch (e: Exception) {
+      Log.e("PhotoSource", "Initialization failed: ${e.message}")
+      callback(Result.failure(e))
+    }
+  }
+
+  /**
+   * Fetches a specific photo from Firestore by UUID.
+   *
+   * @param uuid the UUID of the photo to fetch
+   * @param callback callback function that receives Result.success(DataPhoto) when operation
+   *   succeed of Result.failure(exception) if error
+   */
+  override fun getPhoto(uuid: UUID, callback: (Result<DataPhoto>) -> Unit) {
+    db.collection(PHOTO_COLLECTION_PATH).document(uuid.toString()).get().addOnCompleteListener {
+        task ->
+      if (task.isSuccessful) {
+        val photo = task.result?.let { documentToPhoto(it) }
+        if (photo != null) {
+          callback(Result.success(photo))
+        } else {
+          callback(Result.failure(Exception("Photo not found or failed to convert")))
+        }
+      } else {
+        task.exception?.let { callback(Result.failure(it)) }
+      }
+    }
+  }
+
+  // Maybe not in the repository (I think it should be in the viewmodel)
+  /**
+   * Converts a Bitmap object to a Base64 encoded string.
+   *
+   * @param bitmap The Bitmap object to convert.
+   * @return The Base64 encoded string representation of the bitmap.
+   */
+  override fun bitmapToBase64(bitmap: Bitmap): String {
+    val baos = ByteArrayOutputStream()
+    bitmap.compress(Bitmap.CompressFormat.JPEG, COMPRESSION_QUALITY, baos)
+    val byteArray = baos.toByteArray()
+    return Base64.encodeToString(byteArray, Base64.DEFAULT)
+  }
+
+  // Same, maybe not in the repository (I think it should be in the viewmodel)
+  /**
+   * Converts a Base64 encoded string to a Bitmap object.
+   *
+   * @param base64 The Base64 encoded string to convert.
+   * @return The Bitmap object representation of the Base64 string.
+   */
+  override fun base64ToBitmap(base64: String): Bitmap {
+    val byteArray = Base64.decode(base64, Base64.DEFAULT)
+    return BitmapFactory.decodeByteArray(byteArray, OFFSET, byteArray.size)
+  }
+
+  /**
+   * Uploads a photo to Firestore.
+   *
+   * @param dataPhoto The DataPhoto object to be added to Firestore.
+   * @param callback Callback function that is called when the photo is successfully added or error
+   *   otherwise.
+   */
+  override fun addPhoto(dataPhoto: DataPhoto, callback: (Result<Unit>) -> Unit) {
+    Log.d("PhotoFirestoreRepository", "Attempting to add photo with UUID: ${dataPhoto.uuid}")
+
+    performFirestoreOperation(
+        db.collection(PHOTO_COLLECTION_PATH).document(dataPhoto.uuid.toString()).set(dataPhoto),
+        {
+          Log.d("PhotoFirestoreRepository", "Photo added successfully with UUID: ${dataPhoto.uuid}")
+          callback(Result.success(Unit))
+        },
+        { e ->
+          Log.e("PhotoFirestoreRepository", "Failed to add photo: ${e.message}", e)
+          callback(Result.failure(e))
+        })
+  }
+
+  /**
+   * Converts a Firestore document to a DataPhoto object.
+   *
+   * @param document The Firestore document to convert.
+   * @return The DataPhoto object if conversion is successful, otherwise null.
+   */
+  fun documentToPhoto(document: DocumentSnapshot): DataPhoto? {
+    return try {
+      val uuid = UUID.fromString(document.getString("uuid")) ?: return null
+      val url = document.getString("url") ?: ""
+      val timestamp = document.getLong("timestamp") ?: System.currentTimeMillis()
+      val base64 = document.getString("base64") ?: return null
+
+      DataPhoto(uuid = uuid, url = url, timestamp = timestamp, base64 = base64)
+    } catch (e: Exception) {
+      Log.e("PhotoFirestoreRepository", "Error converting document to DataPhoto", e)
+      null
+    }
+  }
+
+  /**
+   * Helper function to perform Firestore operations (add, update, delete). Executes the provided
+   * Firestore task and triggers success or failure callbacks.
+   *
+   * @param task The Firestore task to execute.
+   * @param onSuccess Callback function that is called when the task is successful.
+   * @param onFailure Callback function that is called when the task fails.
+   */
+  private fun performFirestoreOperation(
+      task: Task<Void>,
+      onSuccess: () -> Unit,
+      onFailure: (Exception) -> Unit
+  ) {
+    task.addOnCompleteListener { result ->
+      if (result.isSuccessful) {
+        onSuccess()
+      } else {
+        result.exception?.let { onFailure(it) }
+      }
+    }
+  }
+}
Index: app/src/main/java/com/android/bookswap/data/source/network/ImageToDataSource.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/source/network/ImageToDataSource.kt b/app/src/main/java/com/android/bookswap/data/source/network/ImageToDataSource.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/data/source/network/ImageToDataSource.kt	
@@ -0,0 +1,69 @@
+package com.android.bookswap.data.source.network
+
+import com.android.bookswap.R
+import com.android.bookswap.data.source.api.ApiService
+import org.json.JSONObject
+
+/**
+ * Class to send an image URL to ChatGPT API and parse the response for book information.
+ *
+ * @param apiService The API service to send the request
+ */
+class ImageToDataSource(private val apiService: ApiService) {
+  // The specific prompt for the image analysis
+  private val PROMPT = R.string.prompt
+
+  /**
+   * Function to send an image URL to ChatGPT API and parse the response for book information.
+   *
+   * @param imageUrl URL of the image to analyze
+   * @param onSuccess Callback for a successful response, returns structured book data
+   * @param onError Callback for handling errors
+   */
+  fun analyzeImage(
+      imageUrl: String,
+      onSuccess: (Map<String, String>) -> Unit,
+      onError: (String) -> Unit
+  ) {
+    // Complete the prompt by appending the image URL
+    val fullPrompt = "$PROMPT $imageUrl"
+
+    // Send the request to ChatGPTApiService
+    apiService.sendChatRequest(
+        userMessages = listOf(fullPrompt),
+        onSuccess = { responseContent ->
+          try {
+            // Parse the JSON response into a Map
+            val parsedData = parseResponse(responseContent)
+            onSuccess(parsedData)
+          } catch (e: Exception) {
+            onError("Parsing error: ${e.localizedMessage}")
+          }
+        },
+        onError = { error -> onError("API Request Error: $error") })
+  }
+
+  /**
+   * Parses the ChatGPT response JSON string into a map of book information.
+   *
+   * @param response JSON string returned by the ChatGPT API
+   * @return A map with keys: "title", "author", "description", "language", and "isbn"
+   */
+  private fun parseResponse(response: String): Map<String, String> {
+    val jsonObject = JSONObject(response)
+
+    // Extract the fields as specified
+    val title = jsonObject.optString("title", "N/A")
+    val author = jsonObject.optString("author", "N/A")
+    val description = jsonObject.optString("description", "N/A")
+    val language = jsonObject.optString("language", "N/A")
+    val isbn = jsonObject.optString("isbn", "N/A")
+
+    return mapOf(
+        "title" to title,
+        "author" to author,
+        "description" to description,
+        "language" to language,
+        "isbn" to isbn)
+  }
+}
Index: app/src/main/java/com/android/bookswap/model/map/BookManagerViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/map/BookManagerViewModel.kt b/app/src/main/java/com/android/bookswap/model/map/BookManagerViewModel.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/model/map/BookManagerViewModel.kt	
@@ -0,0 +1,150 @@
+package com.android.bookswap.model.map
+
+import android.location.Location
+import android.util.Log
+import androidx.lifecycle.ViewModel
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.UserBooksWithLocation
+import com.android.bookswap.data.repository.BooksRepository
+import com.android.bookswap.data.repository.UsersRepository
+import kotlinx.coroutines.*
+import kotlinx.coroutines.flow.*
+
+private const val REFRESH_TIME_DELAY = 5000L
+private const val RETRY_TIME_DELAY = 250L
+private const val MAXIMUM_RETRIES = 3
+
+/**
+ * The `BookManagerViewModel` class is responsible for managing book data and user data with
+ * location information, fetching data from the `BooksRepository`, computing distances between the
+ * current location and user locations, and filtering books based on user preferences. The list of
+ * all books can be obtained with the filteredBooks and the list of the list of books with the
+ * location of its owner with the filteredUsers
+ *
+ * @param geolocation the geolocation of the current user
+ * @param booksRepository an instance of [BooksRepository] to retrieve the books from the database.
+ * @param userRepository an instance of [UsersRepository] to retrieve the users from the database.
+ * @param bookFilter an instance of [BookFilter] that manages the filter that needs to be applied.
+ * @param computingDistanceMethod optional : a computation method for distances for testing purposes
+ */
+class BookManagerViewModel(
+    private val geolocation: IGeolocation,
+    private val booksRepository: BooksRepository,
+    private val userRepository: UsersRepository,
+    private val bookFilter: BookFilter,
+    // For the unit tests, the Android framework cannot be interacted with. The
+    // Location.distanceBetween needs to be replaced for testing.
+    private val computingDistanceMethod: (Double, Double, Double, Double) -> Double =
+        { startLatitude, startLongitude, endLatitude, endLongitude ->
+          val result = FloatArray(1)
+          Location.distanceBetween(startLatitude, startLongitude, endLatitude, endLongitude, result)
+          result[0].toDouble()
+        }
+) : ViewModel() {
+  // Internal MutableStateFlows to manage dynamic data
+  private val _allBooks = MutableStateFlow<List<DataBook>>(emptyList())
+  private val _allUsers = MutableStateFlow<List<DataUser>>(emptyList())
+  private val _allUserDistance = MutableStateFlow<List<Pair<DataUser, Double>>>(emptyList())
+  private val _filteredBooks = MutableStateFlow<List<DataBook>>(emptyList())
+  private val _filteredUsers = MutableStateFlow<List<UserBooksWithLocation>>(emptyList())
+
+  // Public StateFlows for UI to observe
+  val filteredBooks: StateFlow<List<DataBook>> = _filteredBooks.asStateFlow()
+  val filteredUsers: StateFlow<List<UserBooksWithLocation>> = _filteredUsers.asStateFlow()
+
+  private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())
+
+  fun startUpdatingBooks() {
+    scope.launch {
+      while (true) {
+        fetchBooksFromRepository()
+        delay(REFRESH_TIME_DELAY)
+      }
+    }
+    computeDistanceOfUsers()
+    combineFlowsAndFilterBooks()
+  }
+
+  fun stopUpdatingBooks() {
+    scope.cancel()
+  }
+
+  // Fetch books and users from the repository and update `_allBooks` and `_allUsers`
+  private suspend fun fetchBooksFromRepository() {
+    var successBooks = false
+    var successUsers = false
+    var currentAttempt = 0
+    while ((!successBooks || !successUsers) && currentAttempt < MAXIMUM_RETRIES) {
+      userRepository.getUsers { users ->
+        if (users.isSuccess) {
+          _allUsers.value = users.getOrNull()!!
+          successUsers = true
+        } else {
+          Log.e("BookManagerViewModel", "Failed to fetch users.")
+        }
+      }
+      booksRepository.getBook(
+          callback = { result ->
+            if (result.isSuccess) {
+              _allBooks.value = result.getOrThrow()
+              successBooks = true
+            } else {
+              Log.e(
+                  "BookManagerViewModel",
+                  "Failed to fetch books: ${result.exceptionOrNull()!!.message}")
+            }
+          })
+
+      if (!successBooks || !successUsers) {
+        currentAttempt++
+        delay(RETRY_TIME_DELAY)
+      }
+      if (currentAttempt == MAXIMUM_RETRIES) {
+        Log.e("BookManagerViewModel", "All retries failed.")
+      }
+    }
+  }
+
+  // Combine books and filter flows and apply filtering logic
+  private fun combineFlowsAndFilterBooks() {
+    scope.launch {
+      combine(_allBooks, _allUserDistance, bookFilter.genresFilter, bookFilter.languagesFilter) {
+              books,
+              userDistance,
+              _,
+              _ ->
+            val userBooksWithLocation =
+                userDistance.map { user ->
+                  UserBooksWithLocation(
+                      userUUID = user.first.userUUID,
+                      longitude = user.first.longitude,
+                      latitude = user.first.latitude,
+                      books =
+                          bookFilter.filterBooks(books).filter { book ->
+                            book.uuid in user.first.bookList
+                          })
+                }
+
+            _filteredBooks.value = userBooksWithLocation.flatMap { it.books }
+            _filteredUsers.value = userBooksWithLocation
+          }
+          .collect()
+    }
+  }
+
+  private fun computeDistanceOfUsers() {
+    scope.launch {
+      combine(_allUsers, geolocation.latitude, geolocation.longitude) { users, latitude, longitude
+            ->
+            val userDistance =
+                users.map { user ->
+                  user to
+                      computingDistanceMethod(latitude, longitude, user.latitude, user.longitude)
+                }
+            userDistance.sortedBy { it.second }
+          }
+          .collect { sortedUserDistance -> _allUserDistance.value = sortedUserDistance }
+    }
+  }
+}
Index: app/src/main/java/com/android/bookswap/model/PhotoRequester.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/PhotoRequester.kt b/app/src/main/java/com/android/bookswap/model/PhotoRequester.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/model/PhotoRequester.kt	
@@ -0,0 +1,88 @@
+package com.android.bookswap.model
+
+import android.Manifest
+import android.content.Context
+import android.graphics.ImageDecoder
+import android.net.Uri
+import androidx.activity.compose.ManagedActivityResultLauncher
+import androidx.activity.compose.rememberLauncherForActivityResult
+import androidx.activity.result.contract.ActivityResultContracts
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.graphics.ImageBitmap
+import androidx.compose.ui.graphics.asImageBitmap
+import androidx.core.content.FileProvider
+import com.android.bookswap.BuildConfig
+import java.io.File
+
+const val IMAGE_TYPE = ".jpg"
+const val IMAGE_PREFIX = "temp_image_"
+/**
+ * Easy code abstraction allowing the user to open their photo app and take a photo of their choice
+ * and then confirm it. Please call [Init] (Composable) in your UI (doesn't matter where)
+ *
+ * @param context the ui context
+ * @param callback what to do when the user has finished (or failed) taking a photo
+ */
+class PhotoRequester(
+    private val context: Context,
+    private val callback: (Result<ImageBitmap>) -> Unit
+) {
+  private var initialized = false // Confirm that init was called
+
+  private lateinit var permissionLauncher: ManagedActivityResultLauncher<String, Boolean>
+  private lateinit var cameraLauncher: ManagedActivityResultLauncher<Uri, Boolean>
+
+  private var fileUri: Uri? = null // Temp file path
+
+  @Composable
+  fun Init() {
+    initialized = true
+
+    // When a photo is called
+    cameraLauncher =
+        rememberLauncherForActivityResult(ActivityResultContracts.TakePicture()) { isImageSaved ->
+          if (isImageSaved) {
+            val source = ImageDecoder.createSource(context.contentResolver, fileUri!!)
+
+            callback(Result.success(ImageDecoder.decodeBitmap(source).asImageBitmap()))
+          } else {
+            fileUri = null
+            callback(Result.failure(Exception("Image could not be saved in phone.")))
+          }
+        }
+    // Ask for permission before using the camera.
+    permissionLauncher =
+        rememberLauncherForActivityResult(ActivityResultContracts.RequestPermission()) {
+            permissionGranted ->
+          if (permissionGranted) {
+            fileUri = getTempUri()
+            cameraLauncher.launch(fileUri)
+          } else {
+            callback(Result.failure(Exception("Permission denied.")))
+          }
+        }
+  }
+
+  /** Request a photo from the user, this will ends-up calling [callback] */
+  fun requestPhoto() {
+    if (!initialized) throw Error("Always call Init() before using requestPhoto()")
+
+    permissionLauncher.launch(Manifest.permission.CAMERA)
+  }
+
+  /** Generate a Uri for temporary file storage in the app cache. */
+  private fun getTempUri(): Uri {
+    val tempFile =
+        File.createTempFile(IMAGE_PREFIX, IMAGE_TYPE, context.cacheDir /* cache directory */)
+
+    // Create sandboxed url for this temp file - needed for the camera API
+    val uri =
+        FileProvider.getUriForFile(
+            context,
+            "${BuildConfig.APPLICATION_ID}.provider", // matches the provider information in the
+            // manifest
+            tempFile)
+
+    return uri
+  }
+}
