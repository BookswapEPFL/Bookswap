Index: app/src/main/java/com/android/bookswap/ui/books/edit/EditBookScreen 2.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/books/edit/EditBookScreen 2.kt b/app/src/main/java/com/android/bookswap/ui/books/edit/EditBookScreen 2.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/ui/books/edit/EditBookScreen 2.kt	
@@ -0,0 +1,323 @@
+package com.android.bookswap.ui.books.edit
+
+import android.widget.Toast
+import androidx.compose.foundation.background
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.widthIn
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.automirrored.filled.ArrowBack
+import androidx.compose.material3.Button
+import androidx.compose.material3.ButtonDefaults
+import androidx.compose.material3.DropdownMenuItem
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.ExposedDropdownMenuBox
+import androidx.compose.material3.ExposedDropdownMenuDefaults
+import androidx.compose.material3.Icon
+import androidx.compose.material3.IconButton
+import androidx.compose.material3.OutlinedTextField
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.Text
+import androidx.compose.material3.TextFieldDefaults
+import androidx.compose.material3.TopAppBar
+import androidx.compose.material3.TopAppBarDefaults
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.setValue
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.platform.LocalConfiguration
+import androidx.compose.ui.platform.LocalContext
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.unit.dp
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.source.network.BooksFirestoreSource
+import com.android.bookswap.ui.books.add.createDataBook
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.theme.ColorVariable
+
+/** Constants * */
+private val SCREEN_PADDING = 16.dp
+private val ELEMENT_SPACING = 8.dp
+private val BUTTON_SPACER_HEIGHT = 16.dp
+private const val COLUMN_WIDTH_RATIO = 0.9f // Column width as 90% of screen width
+
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun EditBookScreen(
+    booksRepository: BooksFirestoreSource,
+    navigationActions: NavigationActions,
+    book: DataBook
+) {
+
+  val configuration = LocalConfiguration.current
+  val screenWidth = configuration.screenWidthDp.dp
+  val columnMaxWidth = screenWidth * COLUMN_WIDTH_RATIO
+  /*val book =
+      booksRepository.selectedBook.collectAsState().value
+          ?: return Text(text = "No Book selected. Should not happen", color = Color.Red)
+  */
+  // Use this and modify the editBookScreen structure if needed when incorporating in the app
+  // navigation
+
+  var title by remember { mutableStateOf(book.title) }
+  var author by remember { mutableStateOf(book.author ?: "") }
+  var description by remember { mutableStateOf(book.description ?: "") }
+  var rating by remember { mutableStateOf(book.rating?.toString() ?: "") }
+  var photo by remember { mutableStateOf(book.photo ?: "") }
+  var language by remember { mutableStateOf(book.language.toString()) }
+  var genres by remember { mutableStateOf(book.genres) }
+  var selectedGenre by remember { mutableStateOf<BookGenres?>(null) } // Genre selection state
+  var expanded by remember { mutableStateOf(false) } // State for dropdown menu
+
+  val context = LocalContext.current
+
+  Scaffold(
+      modifier = Modifier.testTag("editBookScreen").background(ColorVariable.BackGround),
+      containerColor = ColorVariable.BackGround, // Sets entire Scaffold background color
+      topBar = {
+        TopAppBar(
+            title = { Text("Edit your Book", modifier = Modifier.testTag("editBookTitle")) },
+            navigationIcon = {
+              IconButton(
+                  modifier = Modifier.testTag("goBackButton"),
+                  onClick = { navigationActions.goBack() }) {
+                    Icon(
+                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
+                        contentDescription = "Back")
+                  }
+            },
+            colors = TopAppBarDefaults.topAppBarColors(containerColor = ColorVariable.BackGround))
+      },
+      content = { paddingValues ->
+        LazyColumn(
+            modifier =
+                Modifier.fillMaxWidth()
+                    .padding(paddingValues)
+                    .padding(SCREEN_PADDING)
+                    .widthIn(max = columnMaxWidth)
+                    .background(ColorVariable.BackGround)
+                    .testTag("editBookScreenColumn"),
+            verticalArrangement = Arrangement.spacedBy(ELEMENT_SPACING)) {
+              // Title Edit Field
+              item {
+                OutlinedTextField(
+                    value = title,
+                    onValueChange = { title = it },
+                    label = { Text("Title") },
+                    placeholder = { Text("Enter the book title") },
+                    modifier = Modifier.fillMaxWidth().testTag("inputBookTitle"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+
+              item {
+                // Genre Dropdown Edit Field
+                ExposedDropdownMenuBox(
+                    expanded = expanded,
+                    onExpandedChange = { expanded = !expanded },
+                    modifier = Modifier.fillMaxWidth().testTag("GenreDropdown")) {
+                      OutlinedTextField(
+                          value = selectedGenre?.Genre ?: "Select Genre",
+                          onValueChange = {},
+                          label = { Text("Genre") },
+                          readOnly = true,
+                          trailingIcon = {
+                            ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)
+                          },
+                          modifier = Modifier.menuAnchor().testTag("SelectedGenre"),
+                          colors =
+                              TextFieldDefaults.outlinedTextFieldColors(
+                                  containerColor = ColorVariable.Secondary,
+                                  focusedBorderColor = Color.Black,
+                                  unfocusedBorderColor = Color.Black))
+                      ExposedDropdownMenu(
+                          expanded = expanded, onDismissRequest = { expanded = false }) {
+                            BookGenres.values().forEach { genre ->
+                              DropdownMenuItem(
+                                  text = { Text(text = genre.Genre) },
+                                  modifier = Modifier.testTag("GenreDropdownItem_${genre.Genre}"),
+                                  onClick = {
+                                    selectedGenre = genre
+                                    genres = listOf(genre) // Update genres list with selected genre
+                                    expanded = false
+                                  })
+                            }
+                          }
+                    }
+              }
+
+              item {
+                // Author Edit Field
+                OutlinedTextField(
+                    value = author,
+                    onValueChange = { author = it },
+                    label = { Text("Author") },
+                    placeholder = { Text("Enter the author's name") },
+                    modifier = Modifier.fillMaxWidth().testTag("inputBookAuthor"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+
+              item {
+                // Description Edit Field
+                OutlinedTextField(
+                    value = description,
+                    onValueChange = { description = it },
+                    label = { Text("Description") },
+                    placeholder = { Text("Provide a description of the book") },
+                    modifier = Modifier.fillMaxWidth().testTag("inputBookDescription"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+
+              item {
+                // Rating Edit Field
+                OutlinedTextField(
+                    value = rating,
+                    onValueChange = { rating = it },
+                    label = { Text("Rating") },
+                    placeholder = { Text("Rate the book (e.g. 4.5)") },
+                    modifier = Modifier.fillMaxWidth().testTag("inputBookRating"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+              // ISBN Edit Field
+              /*OutlinedTextField(
+                  value = isbn,
+                  onValueChange = { isbn = it },
+                  label = { Text("ISBN") },
+                  placeholder = { Text("ISBN Number") },
+                  modifier = Modifier.fillMaxWidth().testTag("inputBookISBN")
+              )*/
+              // Remove for now but could be added later
+
+              item {
+                // Photo Edit Field
+                OutlinedTextField(
+                    value = photo,
+                    onValueChange = { photo = it },
+                    label = { Text("Photo ") },
+                    placeholder = { Text("Enter a photo of the books") },
+                    modifier = Modifier.testTag("inputBookPhoto"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+
+              item {
+                // Language Edit Field
+                OutlinedTextField(
+                    value = language,
+                    onValueChange = { language = it },
+                    label = { Text("Language ") },
+                    placeholder = { Text("In which language are the book") },
+                    modifier = Modifier.testTag("inputBookLanguage"),
+                    colors =
+                        TextFieldDefaults.outlinedTextFieldColors(
+                            containerColor = ColorVariable.Secondary,
+                            focusedBorderColor = Color.Black,
+                            unfocusedBorderColor = Color.Black))
+              }
+              item { Spacer(modifier = Modifier.height(BUTTON_SPACER_HEIGHT)) }
+
+              item {
+                Button(
+                    onClick = {
+                      try {
+                        if (title.isBlank())
+                            throw IllegalArgumentException("Title cannot be null or blank")
+                        if (author.isBlank())
+                            throw IllegalArgumentException("Author cannot be null or blank")
+                        if (description.isBlank())
+                            throw IllegalArgumentException("Description cannot be null or blank")
+                        if (rating.isBlank())
+                            throw IllegalArgumentException("Rating cannot be null or blank")
+                        if (photo.isBlank())
+                            throw IllegalArgumentException("Photo cannot be null or blank")
+                        if (language.isBlank())
+                            throw IllegalArgumentException("Language cannot be null or blank")
+                        if (book.isbn.isNullOrBlank())
+                            throw IllegalArgumentException("ISBN cannot be null or blank")
+                        if (genres.isEmpty())
+                            throw IllegalArgumentException("Genres cannot be empty")
+
+                        val updatedBook =
+                            createDataBook(
+                                context = context,
+                                uuid = book.uuid,
+                                title = title,
+                                author = author,
+                                description = description,
+                                ratingStr = rating,
+                                photo = photo,
+                                bookLanguageStr = language,
+                                isbn = book.isbn,
+                                genres = genres)
+
+                        booksRepository.updateBook(
+                            updatedBook!!,
+                            callback = { result ->
+                              if (result.isSuccess) {
+                                navigationActions.goBack()
+                              } else {
+                                Toast.makeText(
+                                        context, "Failed to update book.", Toast.LENGTH_SHORT)
+                                    .show()
+                              }
+                            })
+                      } catch (e: Exception) {
+                        Toast.makeText(context, "Error: ${e.message}", Toast.LENGTH_SHORT).show()
+                      }
+                    },
+                    modifier = Modifier.fillMaxWidth().testTag("bookSave"),
+                    enabled = title.isNotBlank(),
+                    colors = ButtonDefaults.buttonColors(containerColor = ColorVariable.Primary)) {
+                      Text("Save", color = Color.White)
+                    }
+              }
+
+              item {
+                Button(
+                    onClick = {
+                      booksRepository.deleteBooks(
+                          book.uuid,
+                          book,
+                          callback = { result ->
+                            if (result.isSuccess) {
+                              navigationActions.goBack()
+                            } else {
+                              Toast.makeText(context, "Failed to delete book.", Toast.LENGTH_SHORT)
+                                  .show()
+                            }
+                          })
+                    },
+                    modifier = Modifier.fillMaxWidth().testTag("bookDelete"),
+                    colors = ButtonDefaults.buttonColors(containerColor = ColorVariable.Primary)) {
+                      Text("Delete", color = Color.White)
+                    }
+              }
+            }
+      })
+}
Index: app/src/main/java/com/android/bookswap/data/source/network/PhotoFirestoreSource 2.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/source/network/PhotoFirestoreSource 2.kt b/app/src/main/java/com/android/bookswap/data/source/network/PhotoFirestoreSource 2.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/data/source/network/PhotoFirestoreSource 2.kt	
@@ -0,0 +1,167 @@
+package com.android.bookswap.data.source.network
+
+import android.graphics.Bitmap
+import android.graphics.BitmapFactory
+import android.util.Base64
+import android.util.Log
+import com.android.bookswap.data.DataPhoto
+import com.android.bookswap.data.repository.PhotoRepository
+import com.google.android.gms.tasks.Task
+import com.google.firebase.firestore.DocumentSnapshot
+import com.google.firebase.firestore.FirebaseFirestore
+import java.io.ByteArrayOutputStream
+import java.util.UUID
+
+/** Constants : */
+/** Name of the Firestore collection that stores users */
+const val PHOTO_COLLECTION_PATH = "photos"
+/** Quality of the compressed image */
+const val COMPRESSION_QUALITY = 70
+/** Offset for the byte array */
+const val OFFSET = 0
+
+/**
+ * A class that implements the PhotoRepository interface using Firebase Firestore as the data
+ * source.
+ *
+ * @property db The Firestore database instance.
+ */
+class PhotoFirestoreSource(private val db: FirebaseFirestore) : PhotoRepository {
+
+  /**
+   * Generates and returns a new unique ID for a photo in Firestore.
+   *
+   * @return A new UUID.
+   */
+  override fun getNewUUID(): UUID {
+    return UUID.randomUUID()
+  }
+
+  /**
+   * Initializes the PhotoFirestoreSource.
+   *
+   * @param callback A callback function that receives Result.success(Unit) on success or
+   *   Result.failure(exception) on failure.
+   */
+  override fun init(callback: (Result<Unit>) -> Unit) {
+    try {
+      callback(Result.success(Unit))
+    } catch (e: Exception) {
+      Log.e("PhotoSource", "Initialization failed: ${e.message}")
+      callback(Result.failure(e))
+    }
+  }
+
+  /**
+   * Fetches a specific photo from Firestore by UUID.
+   *
+   * @param uuid the UUID of the photo to fetch
+   * @param callback callback function that receives Result.success(DataPhoto) when operation
+   *   succeed of Result.failure(exception) if error
+   */
+  override fun getPhoto(uuid: UUID, callback: (Result<DataPhoto>) -> Unit) {
+    db.collection(PHOTO_COLLECTION_PATH).document(uuid.toString()).get().addOnCompleteListener {
+        task ->
+      if (task.isSuccessful) {
+        val photo = task.result?.let { documentToPhoto(it) }
+        if (photo != null) {
+          callback(Result.success(photo))
+        } else {
+          callback(Result.failure(Exception("Photo not found or failed to convert")))
+        }
+      } else {
+        task.exception?.let { callback(Result.failure(it)) }
+      }
+    }
+  }
+
+  // Maybe not in the repository (I think it should be in the viewmodel)
+  /**
+   * Converts a Bitmap object to a Base64 encoded string.
+   *
+   * @param bitmap The Bitmap object to convert.
+   * @return The Base64 encoded string representation of the bitmap.
+   */
+  override fun bitmapToBase64(bitmap: Bitmap): String {
+    val baos = ByteArrayOutputStream()
+    bitmap.compress(Bitmap.CompressFormat.JPEG, COMPRESSION_QUALITY, baos)
+    val byteArray = baos.toByteArray()
+    return Base64.encodeToString(byteArray, Base64.DEFAULT)
+  }
+
+  // Same, maybe not in the repository (I think it should be in the viewmodel)
+  /**
+   * Converts a Base64 encoded string to a Bitmap object.
+   *
+   * @param base64 The Base64 encoded string to convert.
+   * @return The Bitmap object representation of the Base64 string.
+   */
+  override fun base64ToBitmap(base64: String): Bitmap {
+    val byteArray = Base64.decode(base64, Base64.DEFAULT)
+    return BitmapFactory.decodeByteArray(byteArray, OFFSET, byteArray.size)
+  }
+
+  /**
+   * Uploads a photo to Firestore.
+   *
+   * @param dataPhoto The DataPhoto object to be added to Firestore.
+   * @param callback Callback function that is called when the photo is successfully added or error
+   *   otherwise.
+   */
+  override fun addPhoto(dataPhoto: DataPhoto, callback: (Result<Unit>) -> Unit) {
+    Log.d("PhotoFirestoreRepository", "Attempting to add photo with UUID: ${dataPhoto.uuid}")
+
+    performFirestoreOperation(
+        db.collection(PHOTO_COLLECTION_PATH).document(dataPhoto.uuid.toString()).set(dataPhoto),
+        {
+          Log.d("PhotoFirestoreRepository", "Photo added successfully with UUID: ${dataPhoto.uuid}")
+          callback(Result.success(Unit))
+        },
+        { e ->
+          Log.e("PhotoFirestoreRepository", "Failed to add photo: ${e.message}", e)
+          callback(Result.failure(e))
+        })
+  }
+
+  /**
+   * Converts a Firestore document to a DataPhoto object.
+   *
+   * @param document The Firestore document to convert.
+   * @return The DataPhoto object if conversion is successful, otherwise null.
+   */
+  fun documentToPhoto(document: DocumentSnapshot): DataPhoto? {
+    return try {
+      val uuid = UUID.fromString(document.getString("uuid")) ?: return null
+      val url = document.getString("url") ?: ""
+      val timestamp = document.getLong("timestamp") ?: System.currentTimeMillis()
+      val base64 = document.getString("base64") ?: return null
+
+      DataPhoto(uuid = uuid, url = url, timestamp = timestamp, base64 = base64)
+    } catch (e: Exception) {
+      Log.e("PhotoFirestoreRepository", "Error converting document to DataPhoto", e)
+      null
+    }
+  }
+
+  /**
+   * Helper function to perform Firestore operations (add, update, delete). Executes the provided
+   * Firestore task and triggers success or failure callbacks.
+   *
+   * @param task The Firestore task to execute.
+   * @param onSuccess Callback function that is called when the task is successful.
+   * @param onFailure Callback function that is called when the task fails.
+   */
+  private fun performFirestoreOperation(
+      task: Task<Void>,
+      onSuccess: () -> Unit,
+      onFailure: (Exception) -> Unit
+  ) {
+    task.addOnCompleteListener { result ->
+      if (result.isSuccessful) {
+        onSuccess()
+      } else {
+        result.exception?.let { onFailure(it) }
+      }
+    }
+  }
+}
Index: app/src/main/java/com/android/bookswap/data/repository/PhotoFirebaseStorageRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/repository/PhotoFirebaseStorageRepository.kt b/app/src/main/java/com/android/bookswap/data/repository/PhotoFirebaseStorageRepository.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/data/repository/PhotoFirebaseStorageRepository.kt	
@@ -0,0 +1,11 @@
+package com.android.bookswap.data.repository
+
+import android.graphics.Bitmap
+
+interface PhotoFirebaseStorageRepository {
+
+  fun init(callback: (Result<Unit>) -> Unit)
+
+  fun addPhotoToStorage(photoId: String, bitmap: Bitmap, callback: (Result<String>) -> Unit)
+  // getphoto is useless (as we can use the url to directly retrieve the picture and show it )
+}
Index: app/src/androidTest/java/com/android/bookswap/endtoend/ChatEndToEnd.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/endtoend/ChatEndToEnd.kt b/app/src/androidTest/java/com/android/bookswap/endtoend/ChatEndToEnd.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/androidTest/java/com/android/bookswap/endtoend/ChatEndToEnd.kt	
@@ -0,0 +1,367 @@
+package com.android.bookswap.endtoend
+
+import android.content.Context
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.ui.geometry.Offset
+import androidx.compose.ui.semantics.SemanticsActions
+import androidx.compose.ui.semantics.SemanticsProperties
+import androidx.compose.ui.semantics.getOrNull
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.assertTextEquals
+import androidx.compose.ui.test.down
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.moveBy
+import androidx.compose.ui.test.onAllNodesWithTag
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.compose.ui.test.performClick
+import androidx.compose.ui.test.performGesture
+import androidx.compose.ui.test.performSemanticsAction
+import androidx.compose.ui.test.performTextClearance
+import androidx.compose.ui.test.performTextInput
+import androidx.compose.ui.test.up
+import com.android.bookswap.data.DataMessage
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.MessageBox
+import com.android.bookswap.data.MessageType
+import com.android.bookswap.data.repository.MessageRepository
+import com.android.bookswap.ui.chat.ChatScreen
+import com.android.bookswap.ui.chat.ListChatScreen
+import com.android.bookswap.ui.chat.imageTestMessageUUID
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.navigation.TopLevelDestination
+import com.google.firebase.firestore.ListenerRegistration
+import io.mockk.every
+import io.mockk.mockk
+import java.util.UUID
+import org.junit.Assert.assertEquals
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+class ChatEndToEnd {
+  @get:Rule val composeTestRule = createComposeRule()
+
+  private lateinit var mockNavigationActions: NavigationActions
+  private lateinit var mockMessageRepository: MockMessageRepository
+  private val navigateToChatScreen = mutableStateOf(false)
+  private val currentUserUUID = UUID.fromString("550e8400-e29b-41d4-a716-446655440002") // John Doe
+  private val otherUserUUID = UUID.fromString("550e8400-e29b-41d4-a716-446655440001") // Other user
+
+  @Before
+  fun setup() {
+    // Initialize the mock message repository with placeholder messages
+    mockMessageRepository = MockMessageRepository()
+
+    // Initialize mock navigation actions
+    mockNavigationActions = mockk(relaxed = true)
+
+    // Mock the `navigateTo(destination: TopLevelDestination)` method
+    every { mockNavigationActions.navigateTo(any<TopLevelDestination>()) } answers
+        {
+          // Update the navigation state to switch screens
+          navigateToChatScreen.value = true
+        }
+
+    // Mock the `navigateTo(screen: String, otherUserUUID: String)` method
+    every { mockNavigationActions.navigateTo(any<String>(), any<String>()) } answers
+        {
+          navigateToChatScreen.value = true
+        }
+
+    // Mock the `navigateTo(screen: String)` method
+    every { mockNavigationActions.navigateTo(any<String>()) } answers
+        {
+          navigateToChatScreen.value = true
+        }
+
+    // Mock `goBack()` to update the state to simulate going back to the previous screen
+    every { mockNavigationActions.goBack() } answers { navigateToChatScreen.value = false }
+
+    val placeholderMessages =
+        listOf(
+            DataMessage(
+                messageType = MessageType.TEXT,
+                uuid = UUID.randomUUID(),
+                senderUUID = otherUserUUID,
+                receiverUUID = currentUserUUID,
+                text = "Welcome to the chat!",
+                timestamp = System.currentTimeMillis() - 100000),
+            DataMessage(
+                messageType = MessageType.TEXT,
+                uuid = UUID.randomUUID(),
+                senderUUID = currentUserUUID,
+                receiverUUID = otherUserUUID,
+                text = "Thank you!",
+                timestamp = System.currentTimeMillis() - 50000),
+            DataMessage(
+                messageType = MessageType.IMAGE,
+                uuid = imageTestMessageUUID,
+                senderUUID = otherUserUUID,
+                receiverUUID = currentUserUUID,
+                text = "Image Message",
+                timestamp = System.currentTimeMillis()))
+
+    placeholderMessages.forEach { mockMessageRepository.sendMessage(it) { /* No-op */} }
+  }
+
+  @Test
+  fun testChatNavigationAndMessageManipulation() {
+
+    composeTestRule.setContent {
+      if (navigateToChatScreen.value) {
+        ChatScreen(
+            messageRepository = mockMessageRepository,
+            currentUser =
+                DataUser(
+                    userUUID = currentUserUUID,
+                    greeting = "Mr.",
+                    firstName = "John",
+                    lastName = "Doe",
+                    email = "",
+                    phoneNumber = "",
+                    longitude = 0.0,
+                    latitude = 0.0,
+                    profilePictureUrl = "",
+                    bookList = emptyList(),
+                    googleUid = ""),
+            otherUser =
+                DataUser(
+                    userUUID = otherUserUUID,
+                    greeting = "Mr.",
+                    firstName = "Tester",
+                    lastName = "User",
+                    email = "",
+                    phoneNumber = "",
+                    longitude = 0.0,
+                    latitude = 0.0,
+                    profilePictureUrl = "",
+                    bookList = emptyList(),
+                    googleUid = ""),
+            navController = mockNavigationActions)
+      } else {
+        ListChatScreen(
+            placeHolderData =
+                listOf(
+                    MessageBox(
+                        contact =
+                            DataUser(
+                                userUUID = currentUserUUID,
+                                greeting = "Mr.",
+                                firstName = "John",
+                                lastName = "Doe",
+                                email = "",
+                                phoneNumber = "",
+                                longitude = 0.0,
+                                latitude = 0.0,
+                                profilePictureUrl = "",
+                                bookList = emptyList(),
+                                googleUid = ""),
+                        message = "Hello",
+                        date = "Today")),
+            navigationActions = mockNavigationActions,
+            topAppBar = {},
+            bottomAppBar = {})
+      }
+    }
+    // Simulate navigating to the chat screen by clicking on John Doe's message box
+    composeTestRule.onNodeWithTag("chat_messageBox").assertExists().performClick()
+
+    // Wait until placeholder messages appear
+    val firstPlaceholderUUID = mockMessageRepository.messages[0].uuid
+    val secondPlaceholderUUID = mockMessageRepository.messages[1].uuid
+
+    composeTestRule.waitUntil(timeoutMillis = 5000) {
+      composeTestRule
+          .onAllNodesWithTag("message_text $firstPlaceholderUUID", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isNotEmpty()
+    }
+
+    // Assert that ChatScreen is displayed by checking for placeholder messages
+    composeTestRule
+        .onNodeWithTag("message_text $firstPlaceholderUUID", useUnmergedTree = true)
+        .assertExists()
+    composeTestRule
+        .onNodeWithTag("message_text $secondPlaceholderUUID", useUnmergedTree = true)
+        .assertExists()
+
+    composeTestRule.waitUntil(timeoutMillis = 5001) {
+      composeTestRule
+          .onAllNodesWithTag("hobbit", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isNotEmpty()
+    }
+    composeTestRule.onNodeWithTag("hobbit", useUnmergedTree = true).assertExists()
+
+    // Send a new text message
+    val newMessage = "Hello, World!"
+    composeTestRule.onNodeWithTag("message_input_field").performTextInput(newMessage)
+    composeTestRule.onNodeWithTag("send_button").performClick()
+
+    // Wait until the new message appears
+    val newMessageUUID = mockMessageRepository.messages.first().uuid
+    // **DATA LAYER CHECK**: Verify that the message was added to the mockMessageRepository
+    composeTestRule.runOnIdle {
+      val addedMessage = mockMessageRepository.messages.lastOrNull()
+      assertEquals(newMessage, addedMessage?.text)
+      assertEquals(currentUserUUID.toString(), addedMessage?.senderUUID.toString())
+      assertEquals(otherUserUUID.toString(), addedMessage?.receiverUUID.toString())
+    }
+
+    // **EDIT STEP**: Long-press to edit the message
+    composeTestRule
+        .onNodeWithTag("message_item $newMessageUUID", useUnmergedTree = true)
+        .performSemanticsAction(SemanticsActions.OnLongClick)
+
+    // Click on the edit button, modify the message text, and save
+    composeTestRule.onNodeWithTag("editButton", useUnmergedTree = true).performClick()
+    val editedMessage = "Updated Message"
+    composeTestRule
+        .onNodeWithTag("message_input_field", useUnmergedTree = true)
+        .performTextClearance()
+    composeTestRule
+        .onNodeWithTag("message_input_field", useUnmergedTree = true)
+        .performTextInput(editedMessage)
+    composeTestRule.onNodeWithTag("send_button", useUnmergedTree = true).performClick()
+
+    // Wait for the edited message to appear
+    composeTestRule.waitUntil(timeoutMillis = 5003) {
+      composeTestRule
+          .onAllNodesWithTag("message_text $newMessageUUID", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .any {
+            it.config.getOrNull(SemanticsProperties.Text)?.firstOrNull()?.text == editedMessage
+          }
+    }
+
+    // Assert the message text is updated
+    composeTestRule
+        .onNodeWithTag("message_text $newMessageUUID", useUnmergedTree = true)
+        .assertExists()
+        .assertTextEquals(editedMessage)
+
+    // **DELETE STEP**: Long-press to delete the edited message
+    composeTestRule
+        .onNodeWithTag("message_item $newMessageUUID", useUnmergedTree = true)
+        .performSemanticsAction(SemanticsActions.OnLongClick)
+
+    // Click on the delete button
+    composeTestRule.onNodeWithTag("deleteButton", useUnmergedTree = true).performClick()
+
+    // Wait until the message is deleted
+    composeTestRule.waitUntil(timeoutMillis = 5004) {
+      composeTestRule
+          .onAllNodesWithTag("message_text $newMessageUUID", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isEmpty()
+    }
+
+    // Assert the message no longer exists
+    composeTestRule
+        .onNodeWithTag("message_text $newMessageUUID", useUnmergedTree = true)
+        .assertDoesNotExist()
+
+    // **IMAGE INTERACTION STEP**: Locate and click on the image message
+    val imageMessageUUID =
+        mockMessageRepository.messages[2].uuid // Assuming this is the image message's UUID
+    composeTestRule.onNodeWithTag("hobbit", useUnmergedTree = true).assertExists().performClick()
+
+    // Wait for the popup to appear
+    composeTestRule.waitUntil(timeoutMillis = 5005) {
+      composeTestRule
+          .onAllNodesWithTag("popupImage", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isNotEmpty()
+    }
+    composeTestRule.onNodeWithTag("popupImage", useUnmergedTree = true).assertIsDisplayed()
+
+    // **SIMULATED ZOOM STEP**: Perform scaling on the image popup to simulate zoom
+    composeTestRule.onNodeWithTag("popupImage", useUnmergedTree = true).performGesture {
+      down(Offset(150f, 150f)) // Simulate a finger press at the center of the image
+      moveBy(Offset(50f, 50f)) // Simulate a drag to increase the scale
+      up() // Release the finger to end the gesture
+    }
+
+    // Wait until the popup is closed
+    composeTestRule.waitUntil(timeoutMillis = 5006) {
+      composeTestRule
+          .onAllNodesWithTag("popupImage", useUnmergedTree = true)
+          .fetchSemanticsNodes()
+          .isEmpty()
+    }
+    composeTestRule.onNodeWithTag("popupImage", useUnmergedTree = true).assertDoesNotExist()
+
+    // Go back to the chat list screen
+    composeTestRule.onNodeWithTag("backIcon", useUnmergedTree = true).performClick()
+    composeTestRule.onNodeWithTag("chat_listScreen", useUnmergedTree = true).assertExists()
+  }
+
+  class MockMessageRepository : MessageRepository {
+    val messages = mutableListOf<DataMessage>()
+    private var nextUUID = UUID.randomUUID()
+
+    override fun getNewUUID(): UUID {
+      val currentUUID = nextUUID
+      nextUUID = UUID.randomUUID()
+      return currentUUID
+    }
+
+    override fun init(callback: (Result<Unit>) -> Unit) {
+      callback(Result.success(Unit)) // Simulates successful initialization
+    }
+
+    override fun getMessages(callback: (Result<List<DataMessage>>) -> Unit) {
+      callback(Result.success(messages))
+    }
+
+    override fun sendMessage(message: DataMessage, callback: (Result<Unit>) -> Unit) {
+      messages.add(message)
+      callback(Result.success(Unit))
+    }
+
+    override fun deleteMessage(
+        messageUUID: UUID,
+        callback: (Result<Unit>) -> Unit,
+        context: Context
+    ) {
+      messages.removeIf { it.uuid == messageUUID }
+      callback(Result.success(Unit))
+    }
+
+    override fun deleteAllMessages(
+        user1UUID: UUID,
+        user2UUID: UUID,
+        callback: (Result<Unit>) -> Unit
+    ) {
+      messages.removeIf {
+        (it.senderUUID == user1UUID && it.receiverUUID == user2UUID) ||
+            (it.senderUUID == user2UUID && it.receiverUUID == user1UUID)
+      }
+      callback(Result.success(Unit))
+    }
+
+    override fun updateMessage(
+        message: DataMessage,
+        callback: (Result<Unit>) -> Unit,
+        context: Context
+    ) {
+      val index = messages.indexOfFirst { it.uuid == message.uuid }
+      if (index != -1) {
+        messages[index] = message.copy(text = message.text) // Update the message text
+        callback(Result.success(Unit))
+      } else {
+        callback(Result.failure(Exception("Message not found")))
+      }
+    }
+
+    override fun addMessagesListener(
+        otherUserUUID: UUID,
+        currentUserUUID: UUID,
+        callback: (Result<List<DataMessage>>) -> Unit
+    ): ListenerRegistration {
+      // Immediately provide the existing messages for testing
+      callback(Result.success(messages))
+      return mockk() // Return a mock ListenerRegistration
+    }
+  }
+}
Index: app/src/main/java/com/android/bookswap/data/source/network/PhotoFirebaseStorageSource.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/source/network/PhotoFirebaseStorageSource.kt b/app/src/main/java/com/android/bookswap/data/source/network/PhotoFirebaseStorageSource.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/data/source/network/PhotoFirebaseStorageSource.kt	
@@ -0,0 +1,70 @@
+package com.android.bookswap.data.source.network
+
+import android.graphics.Bitmap
+import android.util.Log
+import com.android.bookswap.data.repository.PhotoFirebaseStorageRepository
+import com.google.firebase.storage.FirebaseStorage
+import java.io.ByteArrayOutputStream
+
+/** Constants : */
+/** Quality of the compressed image */
+const val QUALITY_COMPRESSION = 100
+
+/**
+ * A class that implements the PhotoFirebaseStorageRepository interface using Firebase Storage as
+ * the data source.
+ *
+ * @property storage The Firebase Storage instance.
+ */
+class PhotoFirebaseStorageSource(private val storage: FirebaseStorage) :
+    PhotoFirebaseStorageRepository {
+
+  /**
+   * Initializes the PhotoFirebaseStorageSource.
+   *
+   * @param callback A callback function that receives Result.success(Unit) on success or
+   *   Result.failure(exception) on failure.
+   */
+  override fun init(callback: (Result<Unit>) -> Unit) {
+    try {
+      callback(Result.success(Unit))
+    } catch (e: Exception) {
+      Log.e("PhotoSource", "Initialization failed: ${e.message}")
+      callback(Result.failure(e))
+    }
+  }
+
+  /**
+   * Adds a photo to Firebase Storage.
+   *
+   * @param photoId The ID of the photo to add.
+   * @param bitmap The photo to add.
+   * @param callback A callback function that receives Result.success(String) with the URL of the
+   *   photo on success or Result.failure(exception) on failure.
+   */
+  override fun addPhotoToStorage(
+      photoId: String,
+      bitmap: Bitmap,
+      callback: (Result<String>) -> Unit
+  ) {
+    // Convert Bitmap to a JPEG Byte Array
+    val baos = ByteArrayOutputStream()
+    bitmap.compress(Bitmap.CompressFormat.JPEG, QUALITY_COMPRESSION, baos)
+    val imageData = baos.toByteArray()
+
+    // Define a storage reference with a unique photoId
+    val storageRef = storage.reference.child("images/$photoId.jpg")
+
+    storageRef
+        .putBytes(imageData)
+        .addOnSuccessListener {
+          // Get the download URL after successful upload
+          storageRef.downloadUrl
+              .addOnSuccessListener { url ->
+                callback(Result.success(url.toString())) // Return the URL
+              }
+              .addOnFailureListener { e -> callback(Result.failure(e)) }
+        }
+        .addOnFailureListener { e -> callback(Result.failure(e)) }
+  }
+}
Index: app/src/test/java/com/android/bookswap/ui/navigation/NavigationCurrentLocation.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/ui/navigation/NavigationCurrentLocation.kt b/app/src/test/java/com/android/bookswap/ui/navigation/NavigationCurrentLocation.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/test/java/com/android/bookswap/ui/navigation/NavigationCurrentLocation.kt	
@@ -0,0 +1,56 @@
+package com.android.bookswap.ui.navigation
+
+import androidx.navigation.NavBackStackEntry
+import androidx.navigation.NavDestination
+import androidx.navigation.NavHostController
+import androidx.navigation.NavOptionsBuilder
+import io.mockk.*
+import org.junit.Before
+import org.junit.Test
+
+class NavigationCurrentLocation {
+
+  private lateinit var navController: NavHostController
+  private lateinit var navigationActions: NavigationActions
+
+  @Before
+  fun setup() {
+    navController = mockk(relaxed = true)
+    navigationActions = NavigationActions(navController)
+
+    val currentBackStackEntry = mockk<NavBackStackEntry>()
+    every { navController.currentBackStackEntry } returns currentBackStackEntry
+
+    val destination = mockk<NavDestination>()
+    every { currentBackStackEntry.destination } returns destination
+  }
+
+  @Test
+  fun `navigateTo does not navigate when already on destination`() {
+    // Arrange: Set up the current route to match the target destination
+    every { navController.currentBackStackEntry?.destination?.route } returns
+        TopLevelDestinations.MAP.route
+
+    // Act: Try to navigate to the MAP screen
+    navigationActions.navigateTo(TopLevelDestinations.MAP)
+
+    // Assert: Verify that navigate is not called since we are already on MAP
+    verify(exactly = 0) { navController.navigate(any<String>()) }
+  }
+
+  @Test
+  fun `navigateTo navigates when not on destination`() {
+    // Arrange: Set up the current route to be different from the target destination
+    every { navController.currentBackStackEntry?.destination?.route } returns
+        TopLevelDestinations.CHAT.route
+
+    // Act: Try to navigate to the MAP screen
+    navigationActions.navigateTo(TopLevelDestinations.MAP)
+
+    // Assert: Verify that navigate is called since we are not on MAP
+    verify(exactly = 1) {
+      navController.navigate(
+          eq(TopLevelDestinations.MAP.route), any<NavOptionsBuilder.() -> Unit>())
+    }
+  }
+}
Index: app/src/test/java/com/android/bookswap/data/source/network/PhotoFirebaseStorageSourceTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/source/network/PhotoFirebaseStorageSourceTest.kt b/app/src/test/java/com/android/bookswap/data/source/network/PhotoFirebaseStorageSourceTest.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/test/java/com/android/bookswap/data/source/network/PhotoFirebaseStorageSourceTest.kt	
@@ -0,0 +1,132 @@
+package com.android.bookswap.data.source.network
+
+import android.content.Context
+import android.graphics.BitmapFactory
+import android.net.Uri
+import android.os.Looper
+import androidx.test.core.app.ApplicationProvider
+import com.android.bookswap.R
+import com.google.android.gms.tasks.OnFailureListener
+import com.google.android.gms.tasks.OnSuccessListener
+import com.google.android.gms.tasks.Tasks
+import com.google.firebase.FirebaseApp
+import com.google.firebase.storage.FirebaseStorage
+import com.google.firebase.storage.StorageReference
+import com.google.firebase.storage.UploadTask
+import io.mockk.MockKAnnotations
+import io.mockk.every
+import io.mockk.impl.annotations.MockK
+import io.mockk.mockk
+import io.mockk.slot
+import io.mockk.verify
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.RobolectricTestRunner
+import org.robolectric.Shadows.shadowOf
+
+@RunWith(RobolectricTestRunner::class)
+class PhotoFirebaseStorageSourceTest {
+  @MockK private lateinit var mockFirebaseStorage: FirebaseStorage
+  @MockK private lateinit var mockStorageReference: StorageReference
+
+  private lateinit var photoStorageSource: PhotoFirebaseStorageSource
+  private val photoId = "etranger_test"
+
+  @Before
+  fun setup() {
+    MockKAnnotations.init(this)
+
+    // Initialize Firebase if necessary
+    FirebaseApp.initializeApp(ApplicationProvider.getApplicationContext())
+
+    // Set up Firebase storage mocks
+    every { mockFirebaseStorage.reference } returns mockStorageReference
+    photoStorageSource = PhotoFirebaseStorageSource(mockFirebaseStorage)
+  }
+
+  @Test
+  fun `addPhotoToStorage uploads photo and returns URL on success`() {
+    // Load a real bitmap from resources
+    val context = ApplicationProvider.getApplicationContext<Context>()
+    val testBitmap = BitmapFactory.decodeResource(context.resources, R.drawable.etranger_test)
+
+    val mockDownloadUrl = "https://mockurl.com/test_photo.jpg" // url we expect to receive
+    val callback = mockk<(Result<String>) -> Unit>(relaxed = true)
+
+    // Mock storage reference behavior
+    val photoStorageReference = mockk<StorageReference>()
+    every { mockStorageReference.child("images/$photoId.jpg") } returns photoStorageReference
+
+    // Mock successful upload task with both listeners
+    val mockUploadTask = mockk<UploadTask>()
+    every { photoStorageReference.putBytes(any()) } returns mockUploadTask
+    val successListenerSlot = slot<OnSuccessListener<UploadTask.TaskSnapshot>>()
+    val failureListenerSlot = slot<OnFailureListener>()
+
+    every { mockUploadTask.addOnSuccessListener(capture(successListenerSlot)) } answers
+        {
+          successListenerSlot.captured.onSuccess(mockk())
+          mockUploadTask
+        }
+    every { mockUploadTask.addOnFailureListener(capture(failureListenerSlot)) } answers
+        {
+          mockUploadTask
+        }
+
+    // Mock successful download URL retrieval
+    every { photoStorageReference.downloadUrl } returns Tasks.forResult(Uri.parse(mockDownloadUrl))
+
+    // Add photo to storage
+    photoStorageSource.addPhotoToStorage(photoId, testBitmap, callback)
+
+    // Force Robolectric to process any pending tasks on the main thread
+    shadowOf(Looper.getMainLooper()).idle()
+
+    verify { callback(Result.success(mockDownloadUrl)) }
+  }
+
+  @Test
+  fun `addPhotoToStorage returns failure on upload error`() {
+    // Load a real bitmap from resources
+    val context = ApplicationProvider.getApplicationContext<Context>()
+    val testBitmap = BitmapFactory.decodeResource(context.resources, R.drawable.etranger_test)
+
+    val callback = mockk<(Result<String>) -> Unit>(relaxed = true)
+    val exception = Exception("Upload failed")
+
+    // Mock storage reference behavior
+    val photoStorageReference = mockk<StorageReference>()
+    every { mockStorageReference.child("images/$photoId.jpg") } returns photoStorageReference
+
+    // Mock upload failure task with both listeners
+    val mockUploadTask = mockk<UploadTask>()
+    every { photoStorageReference.putBytes(any()) } returns mockUploadTask
+    val successListenerSlot = slot<OnSuccessListener<UploadTask.TaskSnapshot>>()
+    val failureListenerSlot = slot<OnFailureListener>()
+
+    every { mockUploadTask.addOnSuccessListener(capture(successListenerSlot)) } answers
+        {
+          mockUploadTask
+        }
+    every { mockUploadTask.addOnFailureListener(capture(failureListenerSlot)) } answers
+        {
+          failureListenerSlot.captured.onFailure(exception)
+          mockUploadTask
+        }
+
+    // Add photo to storage
+    photoStorageSource.addPhotoToStorage(photoId, testBitmap, callback)
+
+    verify { callback(Result.failure(exception)) }
+  }
+
+  @Test
+  fun `init calls callback with success`() {
+    val callback = mockk<(Result<Unit>) -> Unit>(relaxed = true)
+
+    photoStorageSource.init(callback)
+
+    verify { callback(Result.success(Unit)) }
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/profile/NewUserScreenTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/profile/NewUserScreenTest.kt b/app/src/androidTest/java/com/android/bookswap/ui/profile/NewUserScreenTest.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/androidTest/java/com/android/bookswap/ui/profile/NewUserScreenTest.kt	
@@ -0,0 +1,149 @@
+package com.android.bookswap.ui.profile
+
+import androidx.compose.ui.test.assertHasClickAction
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.assertTextContains
+import androidx.compose.ui.test.assertTextEquals
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.compose.ui.test.performClick
+import androidx.compose.ui.test.performTextInput
+import com.android.bookswap.model.UserViewModel
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.navigation.Route
+import io.mockk.justRun
+import io.mockk.mockk
+import io.mockk.verify
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.mockito.kotlin.any
+
+class NewUserScreenTest {
+  @get:Rule val composeTestRule = createComposeRule()
+  private lateinit var navigationActions: NavigationActions
+  private lateinit var userVM: UserViewModel
+
+  @Before
+  fun setUp() {
+    navigationActions = mockk(relaxed = true)
+    userVM = mockk(relaxed = true)
+  }
+
+  @Test
+  fun allComponentsAreDisplayedWithCorrectTexts() {
+    composeTestRule.setContent { NewUserScreen(navigationActions, userVM) }
+    composeTestRule
+        .onNodeWithTag("welcomeTxt")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextEquals("Welcome")
+
+    composeTestRule
+        .onNodeWithTag("personalInfoTxt")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextEquals("Please fill in your personal information to start BookSwapping")
+
+    composeTestRule
+        .onNodeWithTag("profilPics")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertHasClickAction()
+
+    composeTestRule
+        .onNodeWithTag("greetingTF")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Greeting")
+
+    composeTestRule
+        .onNodeWithTag("firstnameTF")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Firstname")
+
+    composeTestRule
+        .onNodeWithTag("lastnameTF")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Lastname")
+
+    composeTestRule
+        .onNodeWithTag("emailTF")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Email")
+
+    composeTestRule
+        .onNodeWithTag("phoneTF")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Phone")
+
+    composeTestRule
+        .onNodeWithTag("CreateButton")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextEquals("Create")
+        .assertHasClickAction()
+  }
+
+  @Test
+  fun clickOnCreateButtonWithInvalidEmailDoesNotNavigate() {
+
+    composeTestRule.setContent { NewUserScreen(navigationActions, userVM) }
+
+    composeTestRule.onNodeWithTag("greetingTF").performTextInput("Mr.")
+    composeTestRule.onNodeWithTag("firstnameTF").performTextInput("John")
+    composeTestRule.onNodeWithTag("lastnameTF").performTextInput("Doe")
+    composeTestRule.onNodeWithTag("emailTF").performTextInput("john.doe.com") // Email invalide
+    composeTestRule.onNodeWithTag("phoneTF").performTextInput("+4122345678")
+
+    composeTestRule.onNodeWithTag("CreateButton").performClick()
+
+    verify(exactly = 0) { navigationActions.navigateTo(Route.MAP) }
+
+    composeTestRule
+        .onNodeWithTag("emailError")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Invalid email format")
+  }
+
+  @Test
+  fun clickOnCreateButtonWithEmptyFieldsShowsErrors() {
+    justRun {
+      userVM.updateUser(any(), any(), any(), any(), any(), any(), any(), any(), any(), any())
+    }
+    composeTestRule.setContent { NewUserScreen(navigationActions, userVM) }
+
+    composeTestRule.onNodeWithTag("greetingTF").performTextInput("")
+    composeTestRule.onNodeWithTag("firstnameTF").performTextInput("")
+    composeTestRule.onNodeWithTag("lastnameTF").performTextInput("")
+    composeTestRule.onNodeWithTag("emailTF").performTextInput("notanemail")
+    composeTestRule.onNodeWithTag("phoneTF").performTextInput("")
+
+    composeTestRule.onNodeWithTag("CreateButton").performClick()
+
+    verify(exactly = 0) { navigationActions.navigateTo(Route.MAP) }
+
+    composeTestRule
+        .onNodeWithTag("firstnameError")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("First name required")
+
+    composeTestRule
+        .onNodeWithTag("lastnameError")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Last name required")
+
+    composeTestRule
+        .onNodeWithTag("emailError")
+        .assertExists()
+        .assertIsDisplayed()
+        .assertTextContains("Invalid email format")
+  }
+}
Index: app/src/main/java/com/android/bookswap/data/UserBooksWithLocation.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/data/UserBooksWithLocation.kt b/app/src/main/java/com/android/bookswap/data/UserBooksWithLocation.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/data/UserBooksWithLocation.kt	
@@ -0,0 +1,18 @@
+package com.android.bookswap.data
+
+import java.util.UUID
+
+/**
+ * Represents a user's book collection along with their geographical location.
+ *
+ * @property userUUID Unique identifier for the user.
+ * @property longitude The user's longitude coordinate.
+ * @property latitude The user's latitude coordinate.
+ * @property books List of books associated with the user.
+ */
+data class UserBooksWithLocation(
+    val userUUID: UUID,
+    val longitude: Double,
+    val latitude: Double,
+    val books: List<DataBook>
+)
Index: app/src/main/java/com/android/bookswap/model/chat/Chat.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/chat/Chat.kt b/app/src/main/java/com/android/bookswap/model/chat/Chat.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/model/chat/Chat.kt	
@@ -0,0 +1,4 @@
+package com.android.bookswap.model.chat
+
+/** Data class for the message box */
+data class MessageBox(val contactName: String, val message: String, val date: String)
Index: app/src/main/java/com/android/bookswap/ui/components/BookListComponent.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/components/BookListComponent.kt b/app/src/main/java/com/android/bookswap/ui/components/BookListComponent.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/ui/components/BookListComponent.kt	
@@ -0,0 +1,48 @@
+package com.android.bookswap.ui.components
+
+import androidx.compose.foundation.gestures.ScrollableDefaults
+import androidx.compose.foundation.layout.PaddingValues
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.foundation.lazy.itemsIndexed
+import androidx.compose.foundation.lazy.rememberLazyListState
+import androidx.compose.material3.HorizontalDivider
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.unit.Dp
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.ui.books.BookProfileScreen
+
+val DIVIDER_THICKNESS_DP = Dp.Hairline
+
+@Composable
+fun BookListComponent(
+    modifier: Modifier = Modifier,
+    bookList: List<DataBook> = emptyList(),
+) {
+  LazyColumn(
+      modifier = modifier.fillMaxWidth().testTag("BookListColumn"),
+      state = rememberLazyListState(),
+      contentPadding = PaddingValues(PADDING_HORIZONTAL_DP, PADDING_VERTICAL_DP),
+      horizontalAlignment = Alignment.CenterHorizontally,
+      flingBehavior = ScrollableDefaults.flingBehavior(),
+      userScrollEnabled = true,
+  ) {
+    if (bookList.isEmpty()) {
+      item { Text(text = "No books to display", Modifier.testTag("mapDraggableMenuNoBook")) }
+    } else {
+      itemsIndexed(bookList) { i, book ->
+        BookDisplayComponent(Modifier.testTag("mapDraggableMenuBookBox${i}"), book = book)
+        if (i < bookList.size - 1) {
+          HorizontalDivider(
+              modifier = Modifier.testTag("mapDraggableMenuBookBoxDivider"),
+          )
+          BookProfileScreen(book,{}, {})
+        }
+      }
+    }
+  }
+}
Index: app/src/main/java/com/android/bookswap/ui/components/BookDisplayComponent.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/components/BookDisplayComponent.kt b/app/src/main/java/com/android/bookswap/ui/components/BookDisplayComponent.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/ui/components/BookDisplayComponent.kt	
@@ -0,0 +1,146 @@
+package com.android.bookswap.ui.components
+
+import androidx.compose.foundation.background
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.heightIn
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.requiredWidth
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.layout.width
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.filled.Star
+import androidx.compose.material.icons.twotone.Star
+import androidx.compose.material3.Icon
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.draw.clipToBounds
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.text.style.TextOverflow
+import androidx.compose.ui.unit.dp
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.ui.theme.ColorVariable
+
+val PADDING_HORIZONTAL_DP = 4.dp
+val PADDING_VERTICAL_DP = 4.dp
+val IMAGE_HEIGHT_DP = 82.dp
+val IMAGE_WIDTH_DP = 72.dp
+val MAX_RATING = 5
+val STAR_SIZE_DP = 26.dp
+
+@Composable
+fun BookDisplayComponent(modifier: Modifier = Modifier, book: DataBook) {
+  Row(
+      modifier =
+          modifier
+              .fillMaxWidth()
+              .heightIn(
+                  min = IMAGE_HEIGHT_DP + PADDING_VERTICAL_DP * 2,
+                  max = IMAGE_HEIGHT_DP + PADDING_VERTICAL_DP * 2)
+              .padding(PADDING_HORIZONTAL_DP, PADDING_VERTICAL_DP),
+      horizontalArrangement = Arrangement.Start,
+      verticalAlignment = Alignment.CenterVertically) {
+        // Image Box
+        Box(
+            modifier =
+                Modifier.height(IMAGE_HEIGHT_DP)
+                    .width(IMAGE_WIDTH_DP)
+                    .testTag("mapDraggableMenuBookBoxImage"),
+            contentAlignment = Alignment.Center,
+        ) {
+          // Image of the books, will be added at a later date
+          // We didn't discussed about how we will store the image or how we
+          // will
+          // encode them
+          Box(
+              modifier = Modifier.fillMaxSize().background(Color.Gray) // Placeholder for the image
+              )
+        }
+        Row(verticalAlignment = Alignment.CenterVertically) {
+
+          // Column for Title and Author text components
+          Column(
+              modifier =
+                  Modifier.weight(1f, true)
+                      .padding(horizontal = PADDING_HORIZONTAL_DP)
+                      .heightIn(max = IMAGE_HEIGHT_DP + PADDING_VERTICAL_DP * 2)
+                      .testTag("mapDraggableMenuBookBoxMiddle")) {
+                Text(
+                    text = book.title,
+                    overflow = TextOverflow.Ellipsis,
+                    style = MaterialTheme.typography.titleLarge,
+                    color = ColorVariable.Accent,
+                    modifier =
+                        Modifier.weight(1f, true)
+                            // .padding(bottom = PADDING_VERTICAL_DP)
+                            .testTag("mapDraggableMenuBookBoxTitle"))
+                Text(
+                    text = book.author ?: "",
+                    overflow = TextOverflow.Ellipsis,
+                    color = ColorVariable.AccentSecondary,
+                    maxLines = 1,
+                    modifier = Modifier.testTag("mapDraggableMenuBookBoxAuthor"))
+              }
+
+          // Column for rating and genres
+          Column(
+              modifier =
+                  Modifier.requiredWidth(STAR_SIZE_DP * MAX_RATING + PADDING_HORIZONTAL_DP * 2)
+                      .width(STAR_SIZE_DP * MAX_RATING + PADDING_HORIZONTAL_DP * 2)
+                      .testTag("mapDraggableMenuBookRight"),
+              horizontalAlignment = Alignment.CenterHorizontally) {
+                Row(
+                    modifier = Modifier.fillMaxWidth().testTag("mapDraggableMenuBookBoxRating"),
+                    horizontalArrangement = Arrangement.Center) {
+                      // leave all stars empty if no rating
+                      DisplayStarReview(book.rating ?: 0)
+                    }
+                // text for the tags of the book, will be added at a later date
+                // It isn't decided how we will handle the tag for the books
+                Text(
+                    text = book.genres.joinToString(separator = ", ") { it.Genre },
+                    modifier =
+                        Modifier.fillMaxWidth()
+                            .clipToBounds()
+                            .testTag("mapDraggableMenuBookBoxTag"),
+                    overflow = TextOverflow.Ellipsis,
+                    color = ColorVariable.AccentSecondary)
+              }
+        }
+      }
+}
+
+@Composable
+private fun DisplayStarReview(rating: Int) {
+  for (i in 1..rating) {
+    Box(modifier = Modifier.width(STAR_SIZE_DP).testTag("mapDraggableMenuBookBoxStar")) {
+      Icon(
+          imageVector = Icons.Filled.Star,
+          contentDescription = "Star Icon",
+          tint =
+              MaterialTheme.colorScheme.outline.let {
+                it.copy(1f, it.red * 0.75f, it.green * 0.75f, it.blue * 0.75f)
+              },
+          modifier = Modifier.size(STAR_SIZE_DP))
+    }
+  }
+  for (i in rating + 1..MAX_RATING) {
+    // Hollow star
+    Box(modifier = Modifier.width(STAR_SIZE_DP).testTag("mapDraggableMenuBookBoxEmptyStar")) {
+      Icon(
+          imageVector = Icons.TwoTone.Star,
+          contentDescription = "Star Icon",
+          tint = MaterialTheme.colorScheme.outline,
+          modifier = Modifier.size(STAR_SIZE_DP))
+    }
+  }
+}
Index: app/src/main/java/com/android/bookswap/ui/profile/NewUser.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/ui/profile/NewUser.kt b/app/src/main/java/com/android/bookswap/ui/profile/NewUser.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/ui/profile/NewUser.kt	
@@ -0,0 +1,272 @@
+package com.android.bookswap.ui.profile
+
+import android.widget.Toast
+import androidx.compose.foundation.background
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.PaddingValues
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.layout.width
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.foundation.text.KeyboardOptions
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.filled.AccountCircle
+import androidx.compose.material3.Button
+import androidx.compose.material3.ButtonDefaults
+import androidx.compose.material3.Card
+import androidx.compose.material3.Icon
+import androidx.compose.material3.IconButton
+import androidx.compose.material3.OutlinedTextField
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.platform.LocalContext
+import androidx.compose.ui.platform.testTag
+import androidx.compose.ui.text.TextStyle
+import androidx.compose.ui.text.font.FontWeight
+import androidx.compose.ui.text.input.KeyboardType
+import androidx.compose.ui.text.style.TextAlign
+import androidx.compose.ui.unit.dp
+import androidx.compose.ui.unit.sp
+import com.android.bookswap.model.UserViewModel
+import com.android.bookswap.ui.navigation.NavigationActions
+import com.android.bookswap.ui.navigation.Route
+import com.android.bookswap.ui.theme.ColorVariable
+import com.google.firebase.Firebase
+import com.google.firebase.auth.auth
+
+// Constants for magic numbers used in the UI layout
+private val CONTENT_PADDING = 16.dp
+private val ICON_SIZE = 80.dp
+private val TEXT_PADDING = PaddingValues(8.dp, 4.dp)
+private val BUTTON_WIDTH = 200.dp
+private val BUTTON_HEIGHT = 50.dp
+private val WELCOME_FONT_SIZE = 40.sp
+private val INFO_FONT_SIZE = 18.sp
+private val WELCOME_FONT_WEIGHT = FontWeight(600)
+private val INFO_FONT_WEIGHT = FontWeight(400)
+private val ERROR_FONT_SIZE = 12.sp
+
+/**
+ * NewUserScreen is the screen where the user can create a new account by filling in his personal
+ * information
+ *
+ * @param navigationActions: NavigationActions
+ */
+@Composable
+fun NewUserScreen(navigationActions: NavigationActions, userVM: UserViewModel) {
+  val context = LocalContext.current
+
+  // État des champs de saisie
+  val email = remember { mutableStateOf("") }
+  val phone = remember { mutableStateOf("") }
+  val greeting = remember { mutableStateOf("") }
+  val firstName = remember { mutableStateOf("") }
+  val lastName = remember { mutableStateOf("") }
+
+  // État des messages d'erreur pour chaque champ
+  val emailError = remember { mutableStateOf<String?>(null) }
+  val phoneError = remember { mutableStateOf<String?>(null) }
+  val firstNameError = remember { mutableStateOf<String?>(null) }
+  val lastNameError = remember { mutableStateOf<String?>(null) }
+
+  // Fonctions de validation
+  fun validateEmail(input: String): Boolean {
+    return android.util.Patterns.EMAIL_ADDRESS.matcher(input).matches()
+  }
+
+  fun validatePhone(input: String): Boolean {
+    return input.matches(
+        Regex("^\\+?\\d{10,15}$")) // Valide les numéros de téléphone de type +4122345678
+  }
+
+  fun validateNonEmpty(input: String): Boolean {
+    return input.isNotBlank()
+  }
+
+  // Fonction pour valider l'ensemble des champs
+  fun validateForm(): Boolean {
+    emailError.value = if (validateEmail(email.value)) null else "Invalid email format"
+    phoneError.value = if (validatePhone(phone.value)) null else "Invalid phone number"
+    firstNameError.value = if (validateNonEmpty(firstName.value)) null else "First name required"
+    lastNameError.value = if (validateNonEmpty(lastName.value)) null else "Last name required"
+
+    // Retourne `true` si tous les champs sont valides, sinon `false`
+    return emailError.value == null &&
+        phoneError.value == null &&
+        firstNameError.value == null &&
+        lastNameError.value == null
+  }
+
+  LazyColumn(
+      contentPadding = PaddingValues(CONTENT_PADDING),
+      modifier =
+          Modifier.fillMaxSize()
+              .background(color = ColorVariable.BackGround)
+              .testTag("NewUserScreen")) {
+        item {
+          Text(
+              "Welcome",
+              modifier = Modifier.testTag("welcomeTxt").fillMaxWidth(),
+              style =
+                  TextStyle(
+                      color = ColorVariable.Accent,
+                      fontWeight = WELCOME_FONT_WEIGHT,
+                      textAlign = TextAlign.Center,
+                      fontSize = WELCOME_FONT_SIZE,
+                  ))
+        }
+        item {
+          // The personal information text
+          Text(
+              "Please fill in your personal information to start BookSwapping",
+              modifier = Modifier.testTag("personalInfoTxt").fillMaxWidth(),
+              style =
+                  TextStyle(
+                      color = ColorVariable.Accent,
+                      fontWeight = INFO_FONT_WEIGHT,
+                      textAlign = TextAlign.Center,
+                      fontSize = INFO_FONT_SIZE,
+                  ))
+        }
+
+        item {
+          // Formulaire d'informations personnelles
+          Card(
+              Modifier.testTag("editProfileContainer").background(ColorVariable.BackGround),
+              colors =
+                  androidx.compose.material3.CardDefaults.cardColors()
+                      .copy(containerColor = ColorVariable.BackGround)) {
+                Column(
+                    Modifier.fillMaxWidth()
+                        .padding(CONTENT_PADDING)
+                        .background(ColorVariable.BackGround),
+                    Arrangement.Center,
+                    Alignment.CenterHorizontally) {
+                      IconButton(
+                          onClick = { /* TODO */},
+                          modifier = Modifier.size(ICON_SIZE).testTag("profilPics")) {
+                            Icon(
+                                imageVector = Icons.Default.AccountCircle,
+                                contentDescription = "profile picture",
+                                tint = ColorVariable.Accent,
+                                modifier = Modifier.size(ICON_SIZE))
+                          }
+                      OutlinedTextField(
+                          greeting.value,
+                          { greeting.value = it },
+                          Modifier.testTag("greetingTF").fillMaxWidth().padding(TEXT_PADDING),
+                          label = { Text("Greeting") },
+                          placeholder = { Text("Mr.", Modifier, Color.Gray) },
+                          keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Text),
+                          singleLine = true)
+
+                      OutlinedTextField(
+                          firstName.value,
+                          { firstName.value = it },
+                          Modifier.testTag("firstnameTF").fillMaxWidth().padding(TEXT_PADDING),
+                          label = { Text("Firstname") },
+                          placeholder = { Text("John", Modifier, Color.Gray) },
+                          keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Text),
+                          singleLine = true,
+                          isError = firstNameError.value != null)
+                      if (firstNameError.value != null) {
+                        Text(
+                            firstNameError.value!!,
+                            color = Color.Red,
+                            fontSize = ERROR_FONT_SIZE,
+                            modifier = Modifier.testTag("firstnameError"))
+                      }
+
+                      OutlinedTextField(
+                          lastName.value,
+                          { lastName.value = it },
+                          Modifier.testTag("lastnameTF").fillMaxWidth().padding(TEXT_PADDING),
+                          label = { Text("Lastname") },
+                          placeholder = { Text("Doe", Modifier, Color.Gray) },
+                          keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Text),
+                          singleLine = true,
+                          isError = lastNameError.value != null)
+                      if (lastNameError.value != null) {
+                        Text(
+                            lastNameError.value!!,
+                            color = Color.Red,
+                            fontSize = ERROR_FONT_SIZE,
+                            modifier = Modifier.testTag("lastnameError"))
+                      }
+
+                      OutlinedTextField(
+                          email.value,
+                          { email.value = it },
+                          Modifier.testTag("emailTF").fillMaxWidth().padding(TEXT_PADDING),
+                          label = { Text("Email") },
+                          placeholder = { Text("John.Doe@example.com", Modifier, Color.Gray) },
+                          keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),
+                          singleLine = true,
+                          isError = emailError.value != null)
+                      if (emailError.value != null) {
+                        Text(
+                            emailError.value!!,
+                            color = Color.Red,
+                            fontSize = ERROR_FONT_SIZE,
+                            modifier = Modifier.testTag("emailError"))
+                      }
+
+                      OutlinedTextField(
+                          phone.value,
+                          { phone.value = it },
+                          Modifier.testTag("phoneTF").fillMaxWidth().padding(TEXT_PADDING),
+                          label = { Text("Phone") },
+                          placeholder = { Text("+4122345678", Modifier, Color.Gray) },
+                          keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Phone),
+                          singleLine = true,
+                          isError = phoneError.value != null)
+                      if (phoneError.value != null) {
+                        Text(
+                            phoneError.value!!,
+                            color = Color.Red,
+                            fontSize = ERROR_FONT_SIZE,
+                            modifier = Modifier.testTag("phoneError"))
+                      }
+                    }
+              }
+        }
+
+        item {
+          Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
+            Button(
+                onClick = {
+                  if (validateForm()) {
+                    userVM.updateUser(
+                        greeting = greeting.value,
+                        firstName = firstName.value,
+                        lastName = lastName.value,
+                        email = email.value,
+                        phone = phone.value,
+                        googleUid = Firebase.auth.currentUser?.uid ?: "")
+                    navigationActions.navigateTo(Route.MAP)
+                  } else {
+                    Toast.makeText(context, "Please correct the errors", Toast.LENGTH_SHORT).show()
+                  }
+                },
+                colors = ButtonDefaults.buttonColors(ColorVariable.Primary),
+                modifier =
+                    Modifier.width(BUTTON_WIDTH).height(BUTTON_HEIGHT).testTag("CreateButton")) {
+                  Text(
+                      text = "Create",
+                      textAlign = TextAlign.Center,
+                      style = TextStyle(color = ColorVariable.BackGround))
+                }
+          }
+        }
+      }
+}
Index: app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreSourceTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreSourceTest.kt b/app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreSourceTest.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/test/java/com/android/bookswap/data/source/network/BooksFirestoreSourceTest.kt	
@@ -0,0 +1,160 @@
+package com.android.bookswap.data.source.network
+
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.utils.assertBookEquals
+import com.google.android.gms.tasks.Tasks
+import com.google.firebase.firestore.CollectionReference
+import com.google.firebase.firestore.DocumentReference
+import com.google.firebase.firestore.DocumentSnapshot
+import com.google.firebase.firestore.FirebaseFirestore
+import com.google.firebase.firestore.QuerySnapshot
+import io.mockk.every
+import io.mockk.mockk
+import io.mockk.verify
+import java.util.UUID
+import org.junit.Assert.*
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.RobolectricTestRunner
+
+@RunWith(RobolectricTestRunner::class)
+class BooksFirestoreSourceTest {
+
+  private val mockFirestore: FirebaseFirestore = mockk()
+  private val mockCollectionReference: CollectionReference = mockk()
+  private val mockDocumentReference: DocumentReference = mockk()
+  private val mockDocumentSnapshot: DocumentSnapshot = mockk()
+  private val mockQuerySnapshot: QuerySnapshot = mockk()
+
+  private val testBook =
+      DataBook(
+          uuid = UUID.randomUUID(),
+          title = "Test Book",
+          author = "Test Author",
+          description = "Test Description",
+          rating = 5,
+          photo = "http://example.com/photo.jpg",
+          language = BookLanguages.ENGLISH,
+          isbn = "1234567890")
+
+  @Before
+  fun setUp() {
+    every { mockFirestore.collection(any()) }.returns(mockCollectionReference)
+    every { mockCollectionReference.document(any()) }.returns(mockDocumentReference)
+    every { mockCollectionReference.get() }.returns(Tasks.forResult(mockQuerySnapshot))
+
+    // Mock of snapshot
+    every { mockDocumentSnapshot.getString("title") }.returns(testBook.title)
+    every { mockDocumentSnapshot.getString("author") }.returns(testBook.author)
+    every { mockDocumentSnapshot.getString("description") }.returns(testBook.description)
+    every { mockDocumentSnapshot.getLong("rating") }.returns(testBook.rating?.toLong())
+    every { mockDocumentSnapshot.getString("photo") }.returns(testBook.photo)
+    every { mockDocumentSnapshot.getString("language") }.returns(testBook.language.name)
+    every { mockDocumentSnapshot.getString("isbn") }.returns(testBook.isbn)
+    every { mockDocumentSnapshot.get("genres") }.returns(emptyList<String>())
+    every { mockDocumentSnapshot.getLong("uuid.mostSignificantBits") }
+        .returns(testBook.uuid.mostSignificantBits)
+    every { mockDocumentSnapshot.getLong("uuid.leastSignificantBits") }
+        .returns(testBook.uuid.leastSignificantBits)
+  }
+
+  @Test
+  fun `book get returns correct result`() {
+    val bookSource = BooksFirestoreSource(mockFirestore)
+    bookSource.getBook(
+        callback = { result ->
+          assertTrue(result.isSuccess)
+          val books = result.getOrThrow()
+          // Assert that the fetched books match the expected values
+          assertTrue(books.isNotEmpty())
+          assertBookEquals(books.first(), testBook, true)
+        })
+
+    // Verify that Firestore collection was called
+    verify { mockCollectionReference.get() }
+  }
+
+  @Test
+  fun `delete call firestore delete`() {
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    // Arrange
+    every { mockDocumentReference.delete() }.returns(Tasks.forResult(null))
+
+    // Act
+    bookSource.deleteBooks(testBook.uuid, testBook) {}
+
+    // Assert
+    verify { mockDocumentReference.delete() }
+  }
+
+  @Test
+  fun `book set is success`() {
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    // Arrange
+    every { mockDocumentReference.set(testBook) }.returns(Tasks.forResult(null))
+
+    // Act
+    bookSource.addBook(testBook) { result -> assertTrue(result.isSuccess) }
+
+    // Verify Firestore set operation
+    verify { mockDocumentReference.set(testBook) }
+  }
+
+  @Test
+  fun `book update success`() {
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    // Arrange
+    every { mockDocumentReference.set(testBook) }.returns(Tasks.forResult(null))
+
+    // Act
+    bookSource.updateBook(testBook) { result -> assertTrue(result.isSuccess) }
+
+    // Verify Firestore update operation
+    verify { mockDocumentReference.set(testBook) }
+  }
+
+  @Test
+  fun `documentToBooks is valid`() {
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    // Act
+    val result = bookSource.documentToBooks(mockDocumentSnapshot)
+
+    // Assert
+    assertNotNull(result)
+    assertBookEquals(testBook, result)
+  }
+
+  @Test
+  fun `documentToBooks null when missing value`() {
+    // Arrange - Missing "Title"
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    every { mockDocumentSnapshot.getString("title") }.returns(null)
+
+    // Act
+    val result = bookSource.documentToBooks(mockDocumentSnapshot)
+
+    // Assert
+    assertNull(result)
+  }
+
+  @Test
+  fun `documentToBooks null when invalid value`() {
+    // Arrange - Invalid language value
+    val bookSource = BooksFirestoreSource(mockFirestore)
+
+    every { mockDocumentSnapshot.getString("language") }.returns("INVALID_LANGUAGE")
+
+    // Act
+    val result = bookSource.documentToBooks(mockDocumentSnapshot)
+
+    // Assert
+    assertNull(result) // Should return null due to invalid language
+  }
+}
Index: app/src/test/java/com/android/bookswap/utils/BookUtils.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/android/bookswap/utils/BookUtils.kt b/app/src/test/java/com/android/bookswap/utils/BookUtils.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/test/java/com/android/bookswap/utils/BookUtils.kt	
@@ -0,0 +1,15 @@
+package com.android.bookswap.utils
+
+import com.android.bookswap.data.DataBook
+import org.junit.Assert.assertEquals
+
+/**
+ * Assert that two books are identical (uuid can be checked or not)
+ *
+ * @param expected the expected result
+ * @param result the result
+ * @param strict true if the two books should have the same UUID
+ */
+fun assertBookEquals(expected: DataBook, result: DataBook?, strict: Boolean = false) {
+  assertEquals(expected, if (strict) result else result?.copy(uuid = expected.uuid))
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/books/add/addBookTest 2.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/books/add/addBookTest 2.kt b/app/src/androidTest/java/com/android/bookswap/ui/books/add/addBookTest 2.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/androidTest/java/com/android/bookswap/ui/books/add/addBookTest 2.kt	
@@ -0,0 +1,150 @@
+package com.android.bookswap.ui.books.add
+
+import android.content.Context
+import android.widget.Toast
+import androidx.compose.ui.test.assertIsEnabled
+import androidx.compose.ui.test.assertIsNotEnabled
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onNodeWithText
+import androidx.compose.ui.test.performClick
+import androidx.compose.ui.test.performTextInput
+import androidx.navigation.compose.rememberNavController
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.repository.BooksRepository
+import com.android.bookswap.ui.navigation.NavigationActions
+import io.mockk.every
+import io.mockk.mockk
+import io.mockk.mockkStatic
+import java.util.UUID
+import junit.framework.TestCase.assertEquals
+import junit.framework.TestCase.assertNull
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+class AddToBookTest {
+  @get:Rule val composeTestRule = createComposeRule()
+  private val mockContext: Context = mockk()
+  private val mockBooksRepository: BooksRepository = mockk()
+
+  @Before
+  fun init() {
+    mockkStatic(Toast::class)
+    val toastMock = mockk<Toast>()
+    every { toastMock.show() } returns Unit
+    every { Toast.makeText(any(), any<String>(), any()) } returns toastMock
+  }
+
+  @Test
+  fun testSaveButtonDisabledInitially() {
+    composeTestRule.setContent { AddToBookScreen(mockBooksRepository) }
+    // Check if the Save button is initially disabled
+    composeTestRule.onNodeWithText("Save").assertIsNotEnabled()
+  }
+
+  @Test
+  fun testSaveButtonEnabledWhenRequiredFieldsAreFilled() {
+    composeTestRule.setContent { AddToBookScreen(mockBooksRepository) }
+    // Fill in the Title and ISBN fields
+    composeTestRule.onNodeWithText("Title").performTextInput("My Book Title")
+    composeTestRule.onNodeWithText("ISBN").performTextInput("1234567890")
+    // Check if the Save button is now enabled
+    composeTestRule.onNodeWithText("Select Genre").performClick()
+    composeTestRule.onNodeWithText("Save").assertIsEnabled()
+  }
+
+  @Test
+  fun testCreateDataBook_ValidData() {
+    // Test with valid data
+    val book =
+        createDataBook(
+            context = mockContext,
+            uuid = UUID.randomUUID(),
+            title = "My Book",
+            author = "Author Name",
+            description = "This is a description",
+            ratingStr = "4",
+            photo = "https://example.com/photo.jpg",
+            bookLanguageStr = "ENGLISH",
+            isbn = "1234567890",
+            genres = listOf(BookGenres.TRAVEL))
+
+    // Assert the book is created correctly
+    assertEquals("My Book", book?.title)
+    assertEquals("Author Name", book?.author)
+    assertEquals("This is a description", book?.description)
+    assertEquals(4, book?.rating)
+    assertEquals("https://example.com/photo.jpg", book?.photo)
+    assertEquals(BookLanguages.ENGLISH, book?.language)
+    assertEquals("1234567890", book?.isbn)
+  }
+
+  @Test
+  fun testCreateDataBook_InvalidData() {
+    // Test with invalid data (empty title)
+    var book =
+        createDataBook(
+            context = mockContext,
+            uuid = UUID.randomUUID(),
+            title = "",
+            author = "Author Name",
+            description = "This is a description",
+            ratingStr = "4",
+            photo = "https://example.com/photo.jpg",
+            bookLanguageStr = "ENGLISH",
+            isbn = "1234567890",
+            genres = listOf(BookGenres.TRAVEL))
+
+    // Assert that the book is null due to invalid title
+    assertNull(book)
+
+    // Test with invalid rating
+    book =
+        createDataBook(
+            context = mockContext,
+            uuid = UUID.randomUUID(),
+            title = "My Book",
+            author = "Author Name",
+            description = "This is a description",
+            ratingStr = "invalid_rating",
+            photo = "https://example.com/photo.jpg",
+            bookLanguageStr = "ENGLISH",
+            isbn = "1234567890",
+            genres = listOf(BookGenres.TRAVEL))
+
+    // Assert that the book is null due to invalid rating
+    assertNull(book)
+
+    // Test with invalid language
+    book =
+        createDataBook(
+            context = mockContext,
+            uuid = UUID.randomUUID(),
+            title = "My Book",
+            author = "Author Name",
+            description = "This is a description",
+            ratingStr = "4",
+            photo = "https://example.com/photo.jpg",
+            bookLanguageStr = "INVALID_LANGUAGE",
+            isbn = "1234567890",
+            genres = listOf(BookGenres.TRAVEL))
+
+    // Assert that the book is null due to invalid language
+    assertNull(book)
+  }
+
+  @Test
+  fun testSaveButtonDisabledWhenTitleIsEmpty() {
+    composeTestRule.setContent {
+      val navController = rememberNavController()
+      val navigationActions = NavigationActions(navController)
+      AddToBookScreen(mockBooksRepository)
+    }
+    // Fill in the ISBN field but leave the Title field empty
+    composeTestRule.onNodeWithText("ISBN").performTextInput("1234567890")
+
+    // Check if the Save button is still disabled
+    composeTestRule.onNodeWithText("Save").assertIsNotEnabled()
+  }
+}
Index: app/src/androidTest/java/com/android/bookswap/ui/books/edit/EditBookTest 2.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/android/bookswap/ui/books/edit/EditBookTest 2.kt b/app/src/androidTest/java/com/android/bookswap/ui/books/edit/EditBookTest 2.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/androidTest/java/com/android/bookswap/ui/books/edit/EditBookTest 2.kt	
@@ -0,0 +1,161 @@
+package com.android.bookswap.ui.books.edit
+
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.assertTextContains
+import androidx.compose.ui.test.assertTextEquals
+import androidx.compose.ui.test.hasTestTag
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.test.onNodeWithTag
+import androidx.compose.ui.test.performClick
+import androidx.compose.ui.test.performScrollToNode
+import com.android.bookswap.data.BookGenres
+import com.android.bookswap.data.BookLanguages
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.source.network.BooksFirestoreSource
+import com.android.bookswap.ui.navigation.NavigationActions
+import io.mockk.MockKAnnotations
+import io.mockk.every
+import io.mockk.impl.annotations.MockK
+import java.util.UUID
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+class EditBookScreenTest {
+
+  @MockK private lateinit var booksRepository: BooksFirestoreSource
+
+  @MockK private lateinit var navigationActions: NavigationActions
+
+  @get:Rule val composeTestRule = createComposeRule()
+
+  private val sampleBook =
+      DataBook(
+          uuid = UUID.randomUUID(),
+          title = "Sample Book",
+          author = "Sample Author",
+          description = "Sample Description",
+          rating = 4,
+          photo = "sample_photo_url",
+          language = BookLanguages.ENGLISH,
+          isbn = "123456789",
+          genres = listOf(BookGenres.FANTASY))
+
+  @Before
+  fun setUp() {
+    MockKAnnotations.init(this)
+
+    every { navigationActions.currentRoute() } returns "EDIT_BOOK"
+  }
+
+  @Test
+  fun displayEditScreenComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("editBookScreen").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditTitleComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("editBookTitle").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditTitleValueComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("editBookTitle").assertTextEquals("Edit your Book")
+  }
+
+  @Test
+  fun displayEditButtonComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("goBackButton").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditSaveValueComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule
+        .onNodeWithTag("editBookScreenColumn")
+        .performScrollToNode(hasTestTag("bookSave"))
+    composeTestRule.onNodeWithTag("bookSave").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("bookSave").assertTextEquals("Save")
+  }
+
+  @Test
+  fun displayEditDeleteValueComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule
+        .onNodeWithTag("editBookScreenColumn")
+        .performScrollToNode(hasTestTag("bookDelete"))
+    composeTestRule.onNodeWithTag("bookDelete").assertIsDisplayed()
+    composeTestRule.onNodeWithTag("bookDelete").assertTextEquals("Delete")
+  }
+
+  @Test
+  fun displayEditBookTitleComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("inputBookTitle").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookAuthorComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookAuthor").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookDescriptionComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookDescription").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookRatingComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookRating").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookPhotoComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookPhoto").assertIsDisplayed()
+  }
+
+  @Test
+  fun displayEditBookLanguageComponent() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+    composeTestRule.onNodeWithTag("inputBookLanguage").assertIsDisplayed()
+  }
+
+  @Test
+  fun inputsHaveInitialValue() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    composeTestRule.onNodeWithTag("inputBookTitle").assertTextContains(sampleBook.title)
+    composeTestRule.onNodeWithTag("inputBookAuthor").assertTextContains(sampleBook.author ?: "")
+    composeTestRule
+        .onNodeWithTag("inputBookDescription")
+        .assertTextContains(sampleBook.description ?: "")
+    composeTestRule.onNodeWithTag("inputBookPhoto").assertTextContains(sampleBook.photo ?: "")
+    composeTestRule
+        .onNodeWithTag("inputBookLanguage")
+        .assertTextContains(sampleBook.language.toString())
+  }
+
+  @Test
+  fun genreDropdownWorks() {
+    composeTestRule.setContent { EditBookScreen(booksRepository, navigationActions, sampleBook) }
+
+    // opens genre dropdown and select a genre
+    composeTestRule.onNodeWithTag("GenreDropdown").performClick()
+    composeTestRule.onNodeWithTag("GenreDropdownItem_Fantasy").performClick()
+
+    // verify the selected genre
+    composeTestRule.onNodeWithTag("SelectedGenre").assertTextContains("Fantasy")
+  }
+}
Index: app/src/main/java/com/android/bookswap/model/map/BookManagerViewModel 2.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/android/bookswap/model/map/BookManagerViewModel 2.kt b/app/src/main/java/com/android/bookswap/model/map/BookManagerViewModel 2.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/android/bookswap/model/map/BookManagerViewModel 2.kt	
@@ -0,0 +1,150 @@
+package com.android.bookswap.model.map
+
+import android.location.Location
+import android.util.Log
+import androidx.lifecycle.ViewModel
+import com.android.bookswap.data.DataBook
+import com.android.bookswap.data.DataUser
+import com.android.bookswap.data.UserBooksWithLocation
+import com.android.bookswap.data.repository.BooksRepository
+import com.android.bookswap.data.repository.UsersRepository
+import kotlinx.coroutines.*
+import kotlinx.coroutines.flow.*
+
+private const val REFRESH_TIME_DELAY = 5000L
+private const val RETRY_TIME_DELAY = 250L
+private const val MAXIMUM_RETRIES = 3
+
+/**
+ * The `BookManagerViewModel` class is responsible for managing book data and user data with
+ * location information, fetching data from the `BooksRepository`, computing distances between the
+ * current location and user locations, and filtering books based on user preferences. The list of
+ * all books can be obtained with the filteredBooks and the list of the list of books with the
+ * location of its owner with the filteredUsers
+ *
+ * @param geolocation the geolocation of the current user
+ * @param booksRepository an instance of [BooksRepository] to retrieve the books from the database.
+ * @param userRepository an instance of [UsersRepository] to retrieve the users from the database.
+ * @param bookFilter an instance of [BookFilter] that manages the filter that needs to be applied.
+ * @param computingDistanceMethod optional : a computation method for distances for testing purposes
+ */
+class BookManagerViewModel(
+    private val geolocation: IGeolocation,
+    private val booksRepository: BooksRepository,
+    private val userRepository: UsersRepository,
+    private val bookFilter: BookFilter,
+    // For the unit tests, the Android framework cannot be interacted with. The
+    // Location.distanceBetween needs to be replaced for testing.
+    private val computingDistanceMethod: (Double, Double, Double, Double) -> Double =
+        { startLatitude, startLongitude, endLatitude, endLongitude ->
+          val result = FloatArray(1)
+          Location.distanceBetween(startLatitude, startLongitude, endLatitude, endLongitude, result)
+          result[0].toDouble()
+        }
+) : ViewModel() {
+  // Internal MutableStateFlows to manage dynamic data
+  private val _allBooks = MutableStateFlow<List<DataBook>>(emptyList())
+  private val _allUsers = MutableStateFlow<List<DataUser>>(emptyList())
+  private val _allUserDistance = MutableStateFlow<List<Pair<DataUser, Double>>>(emptyList())
+  private val _filteredBooks = MutableStateFlow<List<DataBook>>(emptyList())
+  private val _filteredUsers = MutableStateFlow<List<UserBooksWithLocation>>(emptyList())
+
+  // Public StateFlows for UI to observe
+  val filteredBooks: StateFlow<List<DataBook>> = _filteredBooks.asStateFlow()
+  val filteredUsers: StateFlow<List<UserBooksWithLocation>> = _filteredUsers.asStateFlow()
+
+  private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())
+
+  fun startUpdatingBooks() {
+    scope.launch {
+      while (true) {
+        fetchBooksFromRepository()
+        delay(REFRESH_TIME_DELAY)
+      }
+    }
+    computeDistanceOfUsers()
+    combineFlowsAndFilterBooks()
+  }
+
+  fun stopUpdatingBooks() {
+    scope.cancel()
+  }
+
+  // Fetch books and users from the repository and update `_allBooks` and `_allUsers`
+  private suspend fun fetchBooksFromRepository() {
+    var successBooks = false
+    var successUsers = false
+    var currentAttempt = 0
+    while ((!successBooks || !successUsers) && currentAttempt < MAXIMUM_RETRIES) {
+      userRepository.getUsers { users ->
+        if (users.isSuccess) {
+          _allUsers.value = users.getOrNull()!!
+          successUsers = true
+        } else {
+          Log.e("BookManagerViewModel", "Failed to fetch users.")
+        }
+      }
+      booksRepository.getBook(
+          callback = { result ->
+            if (result.isSuccess) {
+              _allBooks.value = result.getOrThrow()
+              successBooks = true
+            } else {
+              Log.e(
+                  "BookManagerViewModel",
+                  "Failed to fetch books: ${result.exceptionOrNull()!!.message}")
+            }
+          })
+
+      if (!successBooks || !successUsers) {
+        currentAttempt++
+        delay(RETRY_TIME_DELAY)
+      }
+      if (currentAttempt == MAXIMUM_RETRIES) {
+        Log.e("BookManagerViewModel", "All retries failed.")
+      }
+    }
+  }
+
+  // Combine books and filter flows and apply filtering logic
+  private fun combineFlowsAndFilterBooks() {
+    scope.launch {
+      combine(_allBooks, _allUserDistance, bookFilter.genresFilter, bookFilter.languagesFilter) {
+              books,
+              userDistance,
+              _,
+              _ ->
+            val userBooksWithLocation =
+                userDistance.map { user ->
+                  UserBooksWithLocation(
+                      userUUID = user.first.userUUID,
+                      longitude = user.first.longitude,
+                      latitude = user.first.latitude,
+                      books =
+                          bookFilter.filterBooks(books).filter { book ->
+                            book.uuid in user.first.bookList
+                          })
+                }
+
+            _filteredBooks.value = userBooksWithLocation.flatMap { it.books }
+            _filteredUsers.value = userBooksWithLocation
+          }
+          .collect()
+    }
+  }
+
+  private fun computeDistanceOfUsers() {
+    scope.launch {
+      combine(_allUsers, geolocation.latitude, geolocation.longitude) { users, latitude, longitude
+            ->
+            val userDistance =
+                users.map { user ->
+                  user to
+                      computingDistanceMethod(latitude, longitude, user.latitude, user.longitude)
+                }
+            userDistance.sortedBy { it.second }
+          }
+          .collect { sortedUserDistance -> _allUserDistance.value = sortedUserDistance }
+    }
+  }
+}
